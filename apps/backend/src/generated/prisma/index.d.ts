
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserProfile
 * 
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model CraftIdea
 * 
 */
export type CraftIdea = $Result.DefaultSelection<Prisma.$CraftIdeaPayload>
/**
 * Model ChatbotConversation
 * 
 */
export type ChatbotConversation = $Result.DefaultSelection<Prisma.$ChatbotConversationPayload>
/**
 * Model ChatbotMessage
 * 
 */
export type ChatbotMessage = $Result.DefaultSelection<Prisma.$ChatbotMessagePayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Like
 * 
 */
export type Like = $Result.DefaultSelection<Prisma.$LikePayload>
/**
 * Model EcoChallenge
 * 
 */
export type EcoChallenge = $Result.DefaultSelection<Prisma.$EcoChallengePayload>
/**
 * Model UserChallenge
 * 
 */
export type UserChallenge = $Result.DefaultSelection<Prisma.$UserChallengePayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model Announcement
 * 
 */
export type Announcement = $Result.DefaultSelection<Prisma.$AnnouncementPayload>
/**
 * Model ModerationLog
 * 
 */
export type ModerationLog = $Result.DefaultSelection<Prisma.$ModerationLogPayload>
/**
 * Model Sponsor
 * 
 */
export type Sponsor = $Result.DefaultSelection<Prisma.$SponsorPayload>
/**
 * Model SponsorReward
 * 
 */
export type SponsorReward = $Result.DefaultSelection<Prisma.$SponsorRewardPayload>
/**
 * Model UserRedemption
 * 
 */
export type UserRedemption = $Result.DefaultSelection<Prisma.$UserRedemptionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  user: 'user',
  admin: 'admin'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ReportStatus: {
  pending: 'pending',
  in_review: 'in_review',
  resolved: 'resolved'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]


export const ModerationAction: {
  warn_user: 'warn_user',
  ban_user: 'ban_user',
  delete_post: 'delete_post',
  delete_comment: 'delete_comment'
};

export type ModerationAction = (typeof ModerationAction)[keyof typeof ModerationAction]


export const MessageSender: {
  user: 'user',
  ai: 'ai'
};

export type MessageSender = (typeof MessageSender)[keyof typeof MessageSender]


export const Category: {
  Social: 'Social',
  Tutorial: 'Tutorial',
  Challenge: 'Challenge',
  Marketplace: 'Marketplace',
  Other: 'Other'
};

export type Category = (typeof Category)[keyof typeof Category]


export const ChallengeStatus: {
  in_progress: 'in_progress',
  pending_verification: 'pending_verification',
  completed: 'completed',
  rejected: 'rejected'
};

export type ChallengeStatus = (typeof ChallengeStatus)[keyof typeof ChallengeStatus]


export const ChallengeSource: {
  admin: 'admin',
  ai: 'ai'
};

export type ChallengeSource = (typeof ChallengeSource)[keyof typeof ChallengeSource]


export const MaterialType: {
  plastic: 'plastic',
  paper: 'paper',
  glass: 'glass',
  metal: 'metal',
  electronics: 'electronics',
  organic: 'organic',
  textile: 'textile',
  mixed: 'mixed'
};

export type MaterialType = (typeof MaterialType)[keyof typeof MaterialType]


export const ChallengeCategory: {
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly'
};

export type ChallengeCategory = (typeof ChallengeCategory)[keyof typeof ChallengeCategory]


export const VerificationType: {
  manual: 'manual',
  ai: 'ai'
};

export type VerificationType = (typeof VerificationType)[keyof typeof VerificationType]


export const RedemptionStatus: {
  pending: 'pending',
  fulfilled: 'fulfilled',
  cancelled: 'cancelled'
};

export type RedemptionStatus = (typeof RedemptionStatus)[keyof typeof RedemptionStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

export type ModerationAction = $Enums.ModerationAction

export const ModerationAction: typeof $Enums.ModerationAction

export type MessageSender = $Enums.MessageSender

export const MessageSender: typeof $Enums.MessageSender

export type Category = $Enums.Category

export const Category: typeof $Enums.Category

export type ChallengeStatus = $Enums.ChallengeStatus

export const ChallengeStatus: typeof $Enums.ChallengeStatus

export type ChallengeSource = $Enums.ChallengeSource

export const ChallengeSource: typeof $Enums.ChallengeSource

export type MaterialType = $Enums.MaterialType

export const MaterialType: typeof $Enums.MaterialType

export type ChallengeCategory = $Enums.ChallengeCategory

export const ChallengeCategory: typeof $Enums.ChallengeCategory

export type VerificationType = $Enums.VerificationType

export const VerificationType: typeof $Enums.VerificationType

export type RedemptionStatus = $Enums.RedemptionStatus

export const RedemptionStatus: typeof $Enums.RedemptionStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.craftIdea`: Exposes CRUD operations for the **CraftIdea** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CraftIdeas
    * const craftIdeas = await prisma.craftIdea.findMany()
    * ```
    */
  get craftIdea(): Prisma.CraftIdeaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatbotConversation`: Exposes CRUD operations for the **ChatbotConversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatbotConversations
    * const chatbotConversations = await prisma.chatbotConversation.findMany()
    * ```
    */
  get chatbotConversation(): Prisma.ChatbotConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatbotMessage`: Exposes CRUD operations for the **ChatbotMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatbotMessages
    * const chatbotMessages = await prisma.chatbotMessage.findMany()
    * ```
    */
  get chatbotMessage(): Prisma.ChatbotMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.like`: Exposes CRUD operations for the **Like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Likes
    * const likes = await prisma.like.findMany()
    * ```
    */
  get like(): Prisma.LikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ecoChallenge`: Exposes CRUD operations for the **EcoChallenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EcoChallenges
    * const ecoChallenges = await prisma.ecoChallenge.findMany()
    * ```
    */
  get ecoChallenge(): Prisma.EcoChallengeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userChallenge`: Exposes CRUD operations for the **UserChallenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserChallenges
    * const userChallenges = await prisma.userChallenge.findMany()
    * ```
    */
  get userChallenge(): Prisma.UserChallengeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcement`: Exposes CRUD operations for the **Announcement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcement.findMany()
    * ```
    */
  get announcement(): Prisma.AnnouncementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moderationLog`: Exposes CRUD operations for the **ModerationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModerationLogs
    * const moderationLogs = await prisma.moderationLog.findMany()
    * ```
    */
  get moderationLog(): Prisma.ModerationLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sponsor`: Exposes CRUD operations for the **Sponsor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sponsors
    * const sponsors = await prisma.sponsor.findMany()
    * ```
    */
  get sponsor(): Prisma.SponsorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sponsorReward`: Exposes CRUD operations for the **SponsorReward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SponsorRewards
    * const sponsorRewards = await prisma.sponsorReward.findMany()
    * ```
    */
  get sponsorReward(): Prisma.SponsorRewardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRedemption`: Exposes CRUD operations for the **UserRedemption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRedemptions
    * const userRedemptions = await prisma.userRedemption.findMany()
    * ```
    */
  get userRedemption(): Prisma.UserRedemptionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserProfile: 'UserProfile',
    RefreshToken: 'RefreshToken',
    CraftIdea: 'CraftIdea',
    ChatbotConversation: 'ChatbotConversation',
    ChatbotMessage: 'ChatbotMessage',
    Post: 'Post',
    Comment: 'Comment',
    Like: 'Like',
    EcoChallenge: 'EcoChallenge',
    UserChallenge: 'UserChallenge',
    Report: 'Report',
    Announcement: 'Announcement',
    ModerationLog: 'ModerationLog',
    Sponsor: 'Sponsor',
    SponsorReward: 'SponsorReward',
    UserRedemption: 'UserRedemption'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userProfile" | "refreshToken" | "craftIdea" | "chatbotConversation" | "chatbotMessage" | "post" | "comment" | "like" | "ecoChallenge" | "userChallenge" | "report" | "announcement" | "moderationLog" | "sponsor" | "sponsorReward" | "userRedemption"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      CraftIdea: {
        payload: Prisma.$CraftIdeaPayload<ExtArgs>
        fields: Prisma.CraftIdeaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CraftIdeaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftIdeaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CraftIdeaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftIdeaPayload>
          }
          findFirst: {
            args: Prisma.CraftIdeaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftIdeaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CraftIdeaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftIdeaPayload>
          }
          findMany: {
            args: Prisma.CraftIdeaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftIdeaPayload>[]
          }
          create: {
            args: Prisma.CraftIdeaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftIdeaPayload>
          }
          createMany: {
            args: Prisma.CraftIdeaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CraftIdeaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftIdeaPayload>[]
          }
          delete: {
            args: Prisma.CraftIdeaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftIdeaPayload>
          }
          update: {
            args: Prisma.CraftIdeaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftIdeaPayload>
          }
          deleteMany: {
            args: Prisma.CraftIdeaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CraftIdeaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CraftIdeaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftIdeaPayload>[]
          }
          upsert: {
            args: Prisma.CraftIdeaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftIdeaPayload>
          }
          aggregate: {
            args: Prisma.CraftIdeaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCraftIdea>
          }
          groupBy: {
            args: Prisma.CraftIdeaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CraftIdeaGroupByOutputType>[]
          }
          count: {
            args: Prisma.CraftIdeaCountArgs<ExtArgs>
            result: $Utils.Optional<CraftIdeaCountAggregateOutputType> | number
          }
        }
      }
      ChatbotConversation: {
        payload: Prisma.$ChatbotConversationPayload<ExtArgs>
        fields: Prisma.ChatbotConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatbotConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatbotConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotConversationPayload>
          }
          findFirst: {
            args: Prisma.ChatbotConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatbotConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotConversationPayload>
          }
          findMany: {
            args: Prisma.ChatbotConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotConversationPayload>[]
          }
          create: {
            args: Prisma.ChatbotConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotConversationPayload>
          }
          createMany: {
            args: Prisma.ChatbotConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatbotConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotConversationPayload>[]
          }
          delete: {
            args: Prisma.ChatbotConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotConversationPayload>
          }
          update: {
            args: Prisma.ChatbotConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotConversationPayload>
          }
          deleteMany: {
            args: Prisma.ChatbotConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatbotConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatbotConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotConversationPayload>[]
          }
          upsert: {
            args: Prisma.ChatbotConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotConversationPayload>
          }
          aggregate: {
            args: Prisma.ChatbotConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatbotConversation>
          }
          groupBy: {
            args: Prisma.ChatbotConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatbotConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatbotConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ChatbotConversationCountAggregateOutputType> | number
          }
        }
      }
      ChatbotMessage: {
        payload: Prisma.$ChatbotMessagePayload<ExtArgs>
        fields: Prisma.ChatbotMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatbotMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatbotMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatbotMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatbotMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload>
          }
          findMany: {
            args: Prisma.ChatbotMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload>[]
          }
          create: {
            args: Prisma.ChatbotMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload>
          }
          createMany: {
            args: Prisma.ChatbotMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatbotMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatbotMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload>
          }
          update: {
            args: Prisma.ChatbotMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatbotMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatbotMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatbotMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload>[]
          }
          upsert: {
            args: Prisma.ChatbotMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatbotMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatbotMessage>
          }
          groupBy: {
            args: Prisma.ChatbotMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatbotMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatbotMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatbotMessageCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Like: {
        payload: Prisma.$LikePayload<ExtArgs>
        fields: Prisma.LikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findFirst: {
            args: Prisma.LikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findMany: {
            args: Prisma.LikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          create: {
            args: Prisma.LikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          createMany: {
            args: Prisma.LikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          delete: {
            args: Prisma.LikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          update: {
            args: Prisma.LikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          deleteMany: {
            args: Prisma.LikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LikeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          upsert: {
            args: Prisma.LikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          aggregate: {
            args: Prisma.LikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLike>
          }
          groupBy: {
            args: Prisma.LikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikeCountArgs<ExtArgs>
            result: $Utils.Optional<LikeCountAggregateOutputType> | number
          }
        }
      }
      EcoChallenge: {
        payload: Prisma.$EcoChallengePayload<ExtArgs>
        fields: Prisma.EcoChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EcoChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EcoChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoChallengePayload>
          }
          findFirst: {
            args: Prisma.EcoChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EcoChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoChallengePayload>
          }
          findMany: {
            args: Prisma.EcoChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoChallengePayload>[]
          }
          create: {
            args: Prisma.EcoChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoChallengePayload>
          }
          createMany: {
            args: Prisma.EcoChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EcoChallengeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoChallengePayload>[]
          }
          delete: {
            args: Prisma.EcoChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoChallengePayload>
          }
          update: {
            args: Prisma.EcoChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoChallengePayload>
          }
          deleteMany: {
            args: Prisma.EcoChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EcoChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EcoChallengeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoChallengePayload>[]
          }
          upsert: {
            args: Prisma.EcoChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoChallengePayload>
          }
          aggregate: {
            args: Prisma.EcoChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEcoChallenge>
          }
          groupBy: {
            args: Prisma.EcoChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EcoChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EcoChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<EcoChallengeCountAggregateOutputType> | number
          }
        }
      }
      UserChallenge: {
        payload: Prisma.$UserChallengePayload<ExtArgs>
        fields: Prisma.UserChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>
          }
          findFirst: {
            args: Prisma.UserChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>
          }
          findMany: {
            args: Prisma.UserChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>[]
          }
          create: {
            args: Prisma.UserChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>
          }
          createMany: {
            args: Prisma.UserChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserChallengeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>[]
          }
          delete: {
            args: Prisma.UserChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>
          }
          update: {
            args: Prisma.UserChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>
          }
          deleteMany: {
            args: Prisma.UserChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserChallengeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>[]
          }
          upsert: {
            args: Prisma.UserChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>
          }
          aggregate: {
            args: Prisma.UserChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserChallenge>
          }
          groupBy: {
            args: Prisma.UserChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<UserChallengeCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      Announcement: {
        payload: Prisma.$AnnouncementPayload<ExtArgs>
        fields: Prisma.AnnouncementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findFirst: {
            args: Prisma.AnnouncementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findMany: {
            args: Prisma.AnnouncementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          create: {
            args: Prisma.AnnouncementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          createMany: {
            args: Prisma.AnnouncementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnnouncementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          delete: {
            args: Prisma.AnnouncementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          update: {
            args: Prisma.AnnouncementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          deleteMany: {
            args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnnouncementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          upsert: {
            args: Prisma.AnnouncementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncement>
          }
          groupBy: {
            args: Prisma.AnnouncementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnouncementCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementCountAggregateOutputType> | number
          }
        }
      }
      ModerationLog: {
        payload: Prisma.$ModerationLogPayload<ExtArgs>
        fields: Prisma.ModerationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModerationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModerationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationLogPayload>
          }
          findFirst: {
            args: Prisma.ModerationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModerationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationLogPayload>
          }
          findMany: {
            args: Prisma.ModerationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationLogPayload>[]
          }
          create: {
            args: Prisma.ModerationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationLogPayload>
          }
          createMany: {
            args: Prisma.ModerationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModerationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationLogPayload>[]
          }
          delete: {
            args: Prisma.ModerationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationLogPayload>
          }
          update: {
            args: Prisma.ModerationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationLogPayload>
          }
          deleteMany: {
            args: Prisma.ModerationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModerationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModerationLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationLogPayload>[]
          }
          upsert: {
            args: Prisma.ModerationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationLogPayload>
          }
          aggregate: {
            args: Prisma.ModerationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModerationLog>
          }
          groupBy: {
            args: Prisma.ModerationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModerationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModerationLogCountArgs<ExtArgs>
            result: $Utils.Optional<ModerationLogCountAggregateOutputType> | number
          }
        }
      }
      Sponsor: {
        payload: Prisma.$SponsorPayload<ExtArgs>
        fields: Prisma.SponsorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SponsorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SponsorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          findFirst: {
            args: Prisma.SponsorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SponsorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          findMany: {
            args: Prisma.SponsorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>[]
          }
          create: {
            args: Prisma.SponsorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          createMany: {
            args: Prisma.SponsorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SponsorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>[]
          }
          delete: {
            args: Prisma.SponsorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          update: {
            args: Prisma.SponsorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          deleteMany: {
            args: Prisma.SponsorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SponsorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SponsorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>[]
          }
          upsert: {
            args: Prisma.SponsorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          aggregate: {
            args: Prisma.SponsorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSponsor>
          }
          groupBy: {
            args: Prisma.SponsorGroupByArgs<ExtArgs>
            result: $Utils.Optional<SponsorGroupByOutputType>[]
          }
          count: {
            args: Prisma.SponsorCountArgs<ExtArgs>
            result: $Utils.Optional<SponsorCountAggregateOutputType> | number
          }
        }
      }
      SponsorReward: {
        payload: Prisma.$SponsorRewardPayload<ExtArgs>
        fields: Prisma.SponsorRewardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SponsorRewardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorRewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SponsorRewardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorRewardPayload>
          }
          findFirst: {
            args: Prisma.SponsorRewardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorRewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SponsorRewardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorRewardPayload>
          }
          findMany: {
            args: Prisma.SponsorRewardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorRewardPayload>[]
          }
          create: {
            args: Prisma.SponsorRewardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorRewardPayload>
          }
          createMany: {
            args: Prisma.SponsorRewardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SponsorRewardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorRewardPayload>[]
          }
          delete: {
            args: Prisma.SponsorRewardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorRewardPayload>
          }
          update: {
            args: Prisma.SponsorRewardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorRewardPayload>
          }
          deleteMany: {
            args: Prisma.SponsorRewardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SponsorRewardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SponsorRewardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorRewardPayload>[]
          }
          upsert: {
            args: Prisma.SponsorRewardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorRewardPayload>
          }
          aggregate: {
            args: Prisma.SponsorRewardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSponsorReward>
          }
          groupBy: {
            args: Prisma.SponsorRewardGroupByArgs<ExtArgs>
            result: $Utils.Optional<SponsorRewardGroupByOutputType>[]
          }
          count: {
            args: Prisma.SponsorRewardCountArgs<ExtArgs>
            result: $Utils.Optional<SponsorRewardCountAggregateOutputType> | number
          }
        }
      }
      UserRedemption: {
        payload: Prisma.$UserRedemptionPayload<ExtArgs>
        fields: Prisma.UserRedemptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRedemptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRedemptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRedemptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRedemptionPayload>
          }
          findFirst: {
            args: Prisma.UserRedemptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRedemptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRedemptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRedemptionPayload>
          }
          findMany: {
            args: Prisma.UserRedemptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRedemptionPayload>[]
          }
          create: {
            args: Prisma.UserRedemptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRedemptionPayload>
          }
          createMany: {
            args: Prisma.UserRedemptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRedemptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRedemptionPayload>[]
          }
          delete: {
            args: Prisma.UserRedemptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRedemptionPayload>
          }
          update: {
            args: Prisma.UserRedemptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRedemptionPayload>
          }
          deleteMany: {
            args: Prisma.UserRedemptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRedemptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRedemptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRedemptionPayload>[]
          }
          upsert: {
            args: Prisma.UserRedemptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRedemptionPayload>
          }
          aggregate: {
            args: Prisma.UserRedemptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRedemption>
          }
          groupBy: {
            args: Prisma.UserRedemptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRedemptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRedemptionCountArgs<ExtArgs>
            result: $Utils.Optional<UserRedemptionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userProfile?: UserProfileOmit
    refreshToken?: RefreshTokenOmit
    craftIdea?: CraftIdeaOmit
    chatbotConversation?: ChatbotConversationOmit
    chatbotMessage?: ChatbotMessageOmit
    post?: PostOmit
    comment?: CommentOmit
    like?: LikeOmit
    ecoChallenge?: EcoChallengeOmit
    userChallenge?: UserChallengeOmit
    report?: ReportOmit
    announcement?: AnnouncementOmit
    moderationLog?: ModerationLogOmit
    sponsor?: SponsorOmit
    sponsorReward?: SponsorRewardOmit
    userRedemption?: UserRedemptionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    announcements: number
    comments: number
    craftIdeas: number
    createdChallenges: number
    likes: number
    moderationLogs: number
    moderationTargets: number
    posts: number
    reportsFiled: number
    reportsResolved: number
    userChallenges: number
    verifiedChallenges: number
    refreshTokens: number
    createdSponsors: number
    redemptions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    announcements?: boolean | UserCountOutputTypeCountAnnouncementsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    craftIdeas?: boolean | UserCountOutputTypeCountCraftIdeasArgs
    createdChallenges?: boolean | UserCountOutputTypeCountCreatedChallengesArgs
    likes?: boolean | UserCountOutputTypeCountLikesArgs
    moderationLogs?: boolean | UserCountOutputTypeCountModerationLogsArgs
    moderationTargets?: boolean | UserCountOutputTypeCountModerationTargetsArgs
    posts?: boolean | UserCountOutputTypeCountPostsArgs
    reportsFiled?: boolean | UserCountOutputTypeCountReportsFiledArgs
    reportsResolved?: boolean | UserCountOutputTypeCountReportsResolvedArgs
    userChallenges?: boolean | UserCountOutputTypeCountUserChallengesArgs
    verifiedChallenges?: boolean | UserCountOutputTypeCountVerifiedChallengesArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    createdSponsors?: boolean | UserCountOutputTypeCountCreatedSponsorsArgs
    redemptions?: boolean | UserCountOutputTypeCountRedemptionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCraftIdeasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CraftIdeaWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EcoChallengeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountModerationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModerationLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountModerationTargetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModerationLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsFiledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsResolvedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserChallengeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVerifiedChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserChallengeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedSponsorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SponsorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRedemptionWhereInput
  }


  /**
   * Count Type ChatbotConversationCountOutputType
   */

  export type ChatbotConversationCountOutputType = {
    messages: number
  }

  export type ChatbotConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatbotConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatbotConversationCountOutputType without action
   */
  export type ChatbotConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotConversationCountOutputType
     */
    select?: ChatbotConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatbotConversationCountOutputType without action
   */
  export type ChatbotConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatbotMessageWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    comments: number
    likes: number
    reports: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
    likes?: boolean | PostCountOutputTypeCountLikesArgs
    reports?: boolean | PostCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    reports: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | CommentCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }


  /**
   * Count Type EcoChallengeCountOutputType
   */

  export type EcoChallengeCountOutputType = {
    participants: number
  }

  export type EcoChallengeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | EcoChallengeCountOutputTypeCountParticipantsArgs
  }

  // Custom InputTypes
  /**
   * EcoChallengeCountOutputType without action
   */
  export type EcoChallengeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoChallengeCountOutputType
     */
    select?: EcoChallengeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EcoChallengeCountOutputType without action
   */
  export type EcoChallengeCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserChallengeWhereInput
  }


  /**
   * Count Type SponsorCountOutputType
   */

  export type SponsorCountOutputType = {
    rewards: number
  }

  export type SponsorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rewards?: boolean | SponsorCountOutputTypeCountRewardsArgs
  }

  // Custom InputTypes
  /**
   * SponsorCountOutputType without action
   */
  export type SponsorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsorCountOutputType
     */
    select?: SponsorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SponsorCountOutputType without action
   */
  export type SponsorCountOutputTypeCountRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SponsorRewardWhereInput
  }


  /**
   * Count Type SponsorRewardCountOutputType
   */

  export type SponsorRewardCountOutputType = {
    claims: number
  }

  export type SponsorRewardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claims?: boolean | SponsorRewardCountOutputTypeCountClaimsArgs
  }

  // Custom InputTypes
  /**
   * SponsorRewardCountOutputType without action
   */
  export type SponsorRewardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsorRewardCountOutputType
     */
    select?: SponsorRewardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SponsorRewardCountOutputType without action
   */
  export type SponsorRewardCountOutputTypeCountClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRedemptionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    user_id: number | null
  }

  export type UserSumAggregateOutputType = {
    user_id: number | null
  }

  export type UserMinAggregateOutputType = {
    user_id: number | null
    username: string | null
    email: string | null
    password_hash: string | null
    role: $Enums.UserRole | null
    is_email_verified: boolean | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    user_id: number | null
    username: string | null
    email: string | null
    password_hash: string | null
    role: $Enums.UserRole | null
    is_email_verified: boolean | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    user_id: number
    username: number
    email: number
    password_hash: number
    role: number
    is_email_verified: number
    is_active: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    user_id?: true
  }

  export type UserSumAggregateInputType = {
    user_id?: true
  }

  export type UserMinAggregateInputType = {
    user_id?: true
    username?: true
    email?: true
    password_hash?: true
    role?: true
    is_email_verified?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type UserMaxAggregateInputType = {
    user_id?: true
    username?: true
    email?: true
    password_hash?: true
    role?: true
    is_email_verified?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type UserCountAggregateInputType = {
    user_id?: true
    username?: true
    email?: true
    password_hash?: true
    role?: true
    is_email_verified?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    user_id: number
    username: string
    email: string
    password_hash: string
    role: $Enums.UserRole
    is_email_verified: boolean
    is_active: boolean
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    announcements?: boolean | User$announcementsArgs<ExtArgs>
    chatbotConversations?: boolean | User$chatbotConversationsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    craftIdeas?: boolean | User$craftIdeasArgs<ExtArgs>
    createdChallenges?: boolean | User$createdChallengesArgs<ExtArgs>
    likes?: boolean | User$likesArgs<ExtArgs>
    moderationLogs?: boolean | User$moderationLogsArgs<ExtArgs>
    moderationTargets?: boolean | User$moderationTargetsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    reportsFiled?: boolean | User$reportsFiledArgs<ExtArgs>
    reportsResolved?: boolean | User$reportsResolvedArgs<ExtArgs>
    userChallenges?: boolean | User$userChallengesArgs<ExtArgs>
    verifiedChallenges?: boolean | User$verifiedChallengesArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    createdSponsors?: boolean | User$createdSponsorsArgs<ExtArgs>
    redemptions?: boolean | User$redemptionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    user_id?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "username" | "email" | "password_hash" | "role" | "is_email_verified" | "is_active" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    announcements?: boolean | User$announcementsArgs<ExtArgs>
    chatbotConversations?: boolean | User$chatbotConversationsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    craftIdeas?: boolean | User$craftIdeasArgs<ExtArgs>
    createdChallenges?: boolean | User$createdChallengesArgs<ExtArgs>
    likes?: boolean | User$likesArgs<ExtArgs>
    moderationLogs?: boolean | User$moderationLogsArgs<ExtArgs>
    moderationTargets?: boolean | User$moderationTargetsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    reportsFiled?: boolean | User$reportsFiledArgs<ExtArgs>
    reportsResolved?: boolean | User$reportsResolvedArgs<ExtArgs>
    userChallenges?: boolean | User$userChallengesArgs<ExtArgs>
    verifiedChallenges?: boolean | User$verifiedChallengesArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    createdSponsors?: boolean | User$createdSponsorsArgs<ExtArgs>
    redemptions?: boolean | User$redemptionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      announcements: Prisma.$AnnouncementPayload<ExtArgs>[]
      chatbotConversations: Prisma.$ChatbotConversationPayload<ExtArgs> | null
      comments: Prisma.$CommentPayload<ExtArgs>[]
      craftIdeas: Prisma.$CraftIdeaPayload<ExtArgs>[]
      createdChallenges: Prisma.$EcoChallengePayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
      moderationLogs: Prisma.$ModerationLogPayload<ExtArgs>[]
      moderationTargets: Prisma.$ModerationLogPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      reportsFiled: Prisma.$ReportPayload<ExtArgs>[]
      reportsResolved: Prisma.$ReportPayload<ExtArgs>[]
      userChallenges: Prisma.$UserChallengePayload<ExtArgs>[]
      verifiedChallenges: Prisma.$UserChallengePayload<ExtArgs>[]
      profile: Prisma.$UserProfilePayload<ExtArgs> | null
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      createdSponsors: Prisma.$SponsorPayload<ExtArgs>[]
      redemptions: Prisma.$UserRedemptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      username: string
      email: string
      password_hash: string
      role: $Enums.UserRole
      is_email_verified: boolean
      is_active: boolean
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const userWithUser_idOnly = await prisma.user.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `user_id`
     * const userWithUser_idOnly = await prisma.user.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `user_id`
     * const userWithUser_idOnly = await prisma.user.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    announcements<T extends User$announcementsArgs<ExtArgs> = {}>(args?: Subset<T, User$announcementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatbotConversations<T extends User$chatbotConversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$chatbotConversationsArgs<ExtArgs>>): Prisma__ChatbotConversationClient<$Result.GetResult<Prisma.$ChatbotConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    craftIdeas<T extends User$craftIdeasArgs<ExtArgs> = {}>(args?: Subset<T, User$craftIdeasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CraftIdeaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdChallenges<T extends User$createdChallengesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdChallengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcoChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends User$likesArgs<ExtArgs> = {}>(args?: Subset<T, User$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    moderationLogs<T extends User$moderationLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$moderationLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModerationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    moderationTargets<T extends User$moderationTargetsArgs<ExtArgs> = {}>(args?: Subset<T, User$moderationTargetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModerationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportsFiled<T extends User$reportsFiledArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsFiledArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportsResolved<T extends User$reportsResolvedArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsResolvedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userChallenges<T extends User$userChallengesArgs<ExtArgs> = {}>(args?: Subset<T, User$userChallengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verifiedChallenges<T extends User$verifiedChallengesArgs<ExtArgs> = {}>(args?: Subset<T, User$verifiedChallengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdSponsors<T extends User$createdSponsorsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdSponsorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    redemptions<T extends User$redemptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$redemptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRedemptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly user_id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password_hash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly is_email_verified: FieldRef<"User", 'Boolean'>
    readonly is_active: FieldRef<"User", 'Boolean'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
    readonly deleted_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.announcements
   */
  export type User$announcementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    cursor?: AnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * User.chatbotConversations
   */
  export type User$chatbotConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotConversation
     */
    select?: ChatbotConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotConversation
     */
    omit?: ChatbotConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotConversationInclude<ExtArgs> | null
    where?: ChatbotConversationWhereInput
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.craftIdeas
   */
  export type User$craftIdeasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftIdea
     */
    select?: CraftIdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CraftIdea
     */
    omit?: CraftIdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftIdeaInclude<ExtArgs> | null
    where?: CraftIdeaWhereInput
    orderBy?: CraftIdeaOrderByWithRelationInput | CraftIdeaOrderByWithRelationInput[]
    cursor?: CraftIdeaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CraftIdeaScalarFieldEnum | CraftIdeaScalarFieldEnum[]
  }

  /**
   * User.createdChallenges
   */
  export type User$createdChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoChallenge
     */
    select?: EcoChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcoChallenge
     */
    omit?: EcoChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoChallengeInclude<ExtArgs> | null
    where?: EcoChallengeWhereInput
    orderBy?: EcoChallengeOrderByWithRelationInput | EcoChallengeOrderByWithRelationInput[]
    cursor?: EcoChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EcoChallengeScalarFieldEnum | EcoChallengeScalarFieldEnum[]
  }

  /**
   * User.likes
   */
  export type User$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * User.moderationLogs
   */
  export type User$moderationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationLog
     */
    select?: ModerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModerationLog
     */
    omit?: ModerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationLogInclude<ExtArgs> | null
    where?: ModerationLogWhereInput
    orderBy?: ModerationLogOrderByWithRelationInput | ModerationLogOrderByWithRelationInput[]
    cursor?: ModerationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModerationLogScalarFieldEnum | ModerationLogScalarFieldEnum[]
  }

  /**
   * User.moderationTargets
   */
  export type User$moderationTargetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationLog
     */
    select?: ModerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModerationLog
     */
    omit?: ModerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationLogInclude<ExtArgs> | null
    where?: ModerationLogWhereInput
    orderBy?: ModerationLogOrderByWithRelationInput | ModerationLogOrderByWithRelationInput[]
    cursor?: ModerationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModerationLogScalarFieldEnum | ModerationLogScalarFieldEnum[]
  }

  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * User.reportsFiled
   */
  export type User$reportsFiledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.reportsResolved
   */
  export type User$reportsResolvedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.userChallenges
   */
  export type User$userChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    where?: UserChallengeWhereInput
    orderBy?: UserChallengeOrderByWithRelationInput | UserChallengeOrderByWithRelationInput[]
    cursor?: UserChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserChallengeScalarFieldEnum | UserChallengeScalarFieldEnum[]
  }

  /**
   * User.verifiedChallenges
   */
  export type User$verifiedChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    where?: UserChallengeWhereInput
    orderBy?: UserChallengeOrderByWithRelationInput | UserChallengeOrderByWithRelationInput[]
    cursor?: UserChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserChallengeScalarFieldEnum | UserChallengeScalarFieldEnum[]
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.createdSponsors
   */
  export type User$createdSponsorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    where?: SponsorWhereInput
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    cursor?: SponsorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SponsorScalarFieldEnum | SponsorScalarFieldEnum[]
  }

  /**
   * User.redemptions
   */
  export type User$redemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRedemption
     */
    select?: UserRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRedemption
     */
    omit?: UserRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRedemptionInclude<ExtArgs> | null
    where?: UserRedemptionWhereInput
    orderBy?: UserRedemptionOrderByWithRelationInput | UserRedemptionOrderByWithRelationInput[]
    cursor?: UserRedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRedemptionScalarFieldEnum | UserRedemptionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileAvgAggregateOutputType = {
    user_id: number | null
    points: number | null
    total_waste_kg: number | null
    skipped_challenges: number | null
  }

  export type UserProfileSumAggregateOutputType = {
    user_id: number | null
    points: number | null
    total_waste_kg: number | null
    skipped_challenges: number[]
  }

  export type UserProfileMinAggregateOutputType = {
    user_id: number | null
    full_name: string | null
    bio: string | null
    profile_picture_url: string | null
    points: number | null
    total_waste_kg: number | null
    deleted_at: Date | null
  }

  export type UserProfileMaxAggregateOutputType = {
    user_id: number | null
    full_name: string | null
    bio: string | null
    profile_picture_url: string | null
    points: number | null
    total_waste_kg: number | null
    deleted_at: Date | null
  }

  export type UserProfileCountAggregateOutputType = {
    user_id: number
    full_name: number
    bio: number
    profile_picture_url: number
    points: number
    total_waste_kg: number
    skipped_challenges: number
    home_dashboard_layout: number
    deleted_at: number
    _all: number
  }


  export type UserProfileAvgAggregateInputType = {
    user_id?: true
    points?: true
    total_waste_kg?: true
    skipped_challenges?: true
  }

  export type UserProfileSumAggregateInputType = {
    user_id?: true
    points?: true
    total_waste_kg?: true
    skipped_challenges?: true
  }

  export type UserProfileMinAggregateInputType = {
    user_id?: true
    full_name?: true
    bio?: true
    profile_picture_url?: true
    points?: true
    total_waste_kg?: true
    deleted_at?: true
  }

  export type UserProfileMaxAggregateInputType = {
    user_id?: true
    full_name?: true
    bio?: true
    profile_picture_url?: true
    points?: true
    total_waste_kg?: true
    deleted_at?: true
  }

  export type UserProfileCountAggregateInputType = {
    user_id?: true
    full_name?: true
    bio?: true
    profile_picture_url?: true
    points?: true
    total_waste_kg?: true
    skipped_challenges?: true
    home_dashboard_layout?: true
    deleted_at?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _avg?: UserProfileAvgAggregateInputType
    _sum?: UserProfileSumAggregateInputType
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    user_id: number
    full_name: string | null
    bio: string | null
    profile_picture_url: string | null
    points: number
    total_waste_kg: number
    skipped_challenges: number[]
    home_dashboard_layout: JsonValue | null
    deleted_at: Date | null
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    full_name?: boolean
    bio?: boolean
    profile_picture_url?: boolean
    points?: boolean
    total_waste_kg?: boolean
    skipped_challenges?: boolean
    home_dashboard_layout?: boolean
    deleted_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    full_name?: boolean
    bio?: boolean
    profile_picture_url?: boolean
    points?: boolean
    total_waste_kg?: boolean
    skipped_challenges?: boolean
    home_dashboard_layout?: boolean
    deleted_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    full_name?: boolean
    bio?: boolean
    profile_picture_url?: boolean
    points?: boolean
    total_waste_kg?: boolean
    skipped_challenges?: boolean
    home_dashboard_layout?: boolean
    deleted_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectScalar = {
    user_id?: boolean
    full_name?: boolean
    bio?: boolean
    profile_picture_url?: boolean
    points?: boolean
    total_waste_kg?: boolean
    skipped_challenges?: boolean
    home_dashboard_layout?: boolean
    deleted_at?: boolean
  }

  export type UserProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "full_name" | "bio" | "profile_picture_url" | "points" | "total_waste_kg" | "skipped_challenges" | "home_dashboard_layout" | "deleted_at", ExtArgs["result"]["userProfile"]>
  export type UserProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      full_name: string | null
      bio: string | null
      profile_picture_url: string | null
      points: number
      total_waste_kg: number
      skipped_challenges: number[]
      home_dashboard_layout: Prisma.JsonValue | null
      deleted_at: Date | null
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const userProfileWithUser_idOnly = await prisma.userProfile.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfiles and returns the data saved in the database.
     * @param {UserProfileCreateManyAndReturnArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfiles and only return the `user_id`
     * const userProfileWithUser_idOnly = await prisma.userProfile.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles and returns the data updated in the database.
     * @param {UserProfileUpdateManyAndReturnArgs} args - Arguments to update many UserProfiles.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProfiles and only return the `user_id`
     * const userProfileWithUser_idOnly = await prisma.userProfile.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */
  interface UserProfileFieldRefs {
    readonly user_id: FieldRef<"UserProfile", 'Int'>
    readonly full_name: FieldRef<"UserProfile", 'String'>
    readonly bio: FieldRef<"UserProfile", 'String'>
    readonly profile_picture_url: FieldRef<"UserProfile", 'String'>
    readonly points: FieldRef<"UserProfile", 'Int'>
    readonly total_waste_kg: FieldRef<"UserProfile", 'Float'>
    readonly skipped_challenges: FieldRef<"UserProfile", 'Int[]'>
    readonly home_dashboard_layout: FieldRef<"UserProfile", 'Json'>
    readonly deleted_at: FieldRef<"UserProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile createManyAndReturn
   */
  export type UserProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
  }

  /**
   * UserProfile updateManyAndReturn
   */
  export type UserProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to delete.
     */
    limit?: number
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenAvgAggregateOutputType = {
    token_id: number | null
    user_id: number | null
  }

  export type RefreshTokenSumAggregateOutputType = {
    token_id: number | null
    user_id: number | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    token_id: number | null
    user_id: number | null
    token_hash: string | null
    expires_at: Date | null
    created_at: Date | null
    last_used: Date | null
    deleted_at: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    token_id: number | null
    user_id: number | null
    token_hash: string | null
    expires_at: Date | null
    created_at: Date | null
    last_used: Date | null
    deleted_at: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    token_id: number
    user_id: number
    token_hash: number
    expires_at: number
    created_at: number
    last_used: number
    deleted_at: number
    _all: number
  }


  export type RefreshTokenAvgAggregateInputType = {
    token_id?: true
    user_id?: true
  }

  export type RefreshTokenSumAggregateInputType = {
    token_id?: true
    user_id?: true
  }

  export type RefreshTokenMinAggregateInputType = {
    token_id?: true
    user_id?: true
    token_hash?: true
    expires_at?: true
    created_at?: true
    last_used?: true
    deleted_at?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    token_id?: true
    user_id?: true
    token_hash?: true
    expires_at?: true
    created_at?: true
    last_used?: true
    deleted_at?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    token_id?: true
    user_id?: true
    token_hash?: true
    expires_at?: true
    created_at?: true
    last_used?: true
    deleted_at?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefreshTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefreshTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _avg?: RefreshTokenAvgAggregateInputType
    _sum?: RefreshTokenSumAggregateInputType
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    token_id: number
    user_id: number
    token_hash: string
    expires_at: Date
    created_at: Date
    last_used: Date | null
    deleted_at: Date | null
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    token_id?: boolean
    user_id?: boolean
    token_hash?: boolean
    expires_at?: boolean
    created_at?: boolean
    last_used?: boolean
    deleted_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    token_id?: boolean
    user_id?: boolean
    token_hash?: boolean
    expires_at?: boolean
    created_at?: boolean
    last_used?: boolean
    deleted_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    token_id?: boolean
    user_id?: boolean
    token_hash?: boolean
    expires_at?: boolean
    created_at?: boolean
    last_used?: boolean
    deleted_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    token_id?: boolean
    user_id?: boolean
    token_hash?: boolean
    expires_at?: boolean
    created_at?: boolean
    last_used?: boolean
    deleted_at?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"token_id" | "user_id" | "token_hash" | "expires_at" | "created_at" | "last_used" | "deleted_at", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      token_id: number
      user_id: number
      token_hash: string
      expires_at: Date
      created_at: Date
      last_used: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `token_id`
     * const refreshTokenWithToken_idOnly = await prisma.refreshToken.findMany({ select: { token_id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `token_id`
     * const refreshTokenWithToken_idOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { token_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `token_id`
     * const refreshTokenWithToken_idOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { token_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly token_id: FieldRef<"RefreshToken", 'Int'>
    readonly user_id: FieldRef<"RefreshToken", 'Int'>
    readonly token_hash: FieldRef<"RefreshToken", 'String'>
    readonly expires_at: FieldRef<"RefreshToken", 'DateTime'>
    readonly created_at: FieldRef<"RefreshToken", 'DateTime'>
    readonly last_used: FieldRef<"RefreshToken", 'DateTime'>
    readonly deleted_at: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model CraftIdea
   */

  export type AggregateCraftIdea = {
    _count: CraftIdeaCountAggregateOutputType | null
    _avg: CraftIdeaAvgAggregateOutputType | null
    _sum: CraftIdeaSumAggregateOutputType | null
    _min: CraftIdeaMinAggregateOutputType | null
    _max: CraftIdeaMaxAggregateOutputType | null
  }

  export type CraftIdeaAvgAggregateOutputType = {
    idea_id: number | null
    generated_by_user_id: number | null
  }

  export type CraftIdeaSumAggregateOutputType = {
    idea_id: number | null
    generated_by_user_id: number | null
  }

  export type CraftIdeaMinAggregateOutputType = {
    idea_id: number | null
    generated_by_user_id: number | null
    generated_image_url: string | null
    is_saved: boolean | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type CraftIdeaMaxAggregateOutputType = {
    idea_id: number | null
    generated_by_user_id: number | null
    generated_image_url: string | null
    is_saved: boolean | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type CraftIdeaCountAggregateOutputType = {
    idea_id: number
    generated_by_user_id: number
    idea_json: number
    recycled_materials: number
    generated_image_url: number
    is_saved: number
    created_at: number
    deleted_at: number
    _all: number
  }


  export type CraftIdeaAvgAggregateInputType = {
    idea_id?: true
    generated_by_user_id?: true
  }

  export type CraftIdeaSumAggregateInputType = {
    idea_id?: true
    generated_by_user_id?: true
  }

  export type CraftIdeaMinAggregateInputType = {
    idea_id?: true
    generated_by_user_id?: true
    generated_image_url?: true
    is_saved?: true
    created_at?: true
    deleted_at?: true
  }

  export type CraftIdeaMaxAggregateInputType = {
    idea_id?: true
    generated_by_user_id?: true
    generated_image_url?: true
    is_saved?: true
    created_at?: true
    deleted_at?: true
  }

  export type CraftIdeaCountAggregateInputType = {
    idea_id?: true
    generated_by_user_id?: true
    idea_json?: true
    recycled_materials?: true
    generated_image_url?: true
    is_saved?: true
    created_at?: true
    deleted_at?: true
    _all?: true
  }

  export type CraftIdeaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CraftIdea to aggregate.
     */
    where?: CraftIdeaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CraftIdeas to fetch.
     */
    orderBy?: CraftIdeaOrderByWithRelationInput | CraftIdeaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CraftIdeaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CraftIdeas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CraftIdeas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CraftIdeas
    **/
    _count?: true | CraftIdeaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CraftIdeaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CraftIdeaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CraftIdeaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CraftIdeaMaxAggregateInputType
  }

  export type GetCraftIdeaAggregateType<T extends CraftIdeaAggregateArgs> = {
        [P in keyof T & keyof AggregateCraftIdea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCraftIdea[P]>
      : GetScalarType<T[P], AggregateCraftIdea[P]>
  }




  export type CraftIdeaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CraftIdeaWhereInput
    orderBy?: CraftIdeaOrderByWithAggregationInput | CraftIdeaOrderByWithAggregationInput[]
    by: CraftIdeaScalarFieldEnum[] | CraftIdeaScalarFieldEnum
    having?: CraftIdeaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CraftIdeaCountAggregateInputType | true
    _avg?: CraftIdeaAvgAggregateInputType
    _sum?: CraftIdeaSumAggregateInputType
    _min?: CraftIdeaMinAggregateInputType
    _max?: CraftIdeaMaxAggregateInputType
  }

  export type CraftIdeaGroupByOutputType = {
    idea_id: number
    generated_by_user_id: number | null
    idea_json: JsonValue
    recycled_materials: JsonValue | null
    generated_image_url: string | null
    is_saved: boolean
    created_at: Date
    deleted_at: Date | null
    _count: CraftIdeaCountAggregateOutputType | null
    _avg: CraftIdeaAvgAggregateOutputType | null
    _sum: CraftIdeaSumAggregateOutputType | null
    _min: CraftIdeaMinAggregateOutputType | null
    _max: CraftIdeaMaxAggregateOutputType | null
  }

  type GetCraftIdeaGroupByPayload<T extends CraftIdeaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CraftIdeaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CraftIdeaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CraftIdeaGroupByOutputType[P]>
            : GetScalarType<T[P], CraftIdeaGroupByOutputType[P]>
        }
      >
    >


  export type CraftIdeaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idea_id?: boolean
    generated_by_user_id?: boolean
    idea_json?: boolean
    recycled_materials?: boolean
    generated_image_url?: boolean
    is_saved?: boolean
    created_at?: boolean
    deleted_at?: boolean
    generated_by_user?: boolean | CraftIdea$generated_by_userArgs<ExtArgs>
  }, ExtArgs["result"]["craftIdea"]>

  export type CraftIdeaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idea_id?: boolean
    generated_by_user_id?: boolean
    idea_json?: boolean
    recycled_materials?: boolean
    generated_image_url?: boolean
    is_saved?: boolean
    created_at?: boolean
    deleted_at?: boolean
    generated_by_user?: boolean | CraftIdea$generated_by_userArgs<ExtArgs>
  }, ExtArgs["result"]["craftIdea"]>

  export type CraftIdeaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idea_id?: boolean
    generated_by_user_id?: boolean
    idea_json?: boolean
    recycled_materials?: boolean
    generated_image_url?: boolean
    is_saved?: boolean
    created_at?: boolean
    deleted_at?: boolean
    generated_by_user?: boolean | CraftIdea$generated_by_userArgs<ExtArgs>
  }, ExtArgs["result"]["craftIdea"]>

  export type CraftIdeaSelectScalar = {
    idea_id?: boolean
    generated_by_user_id?: boolean
    idea_json?: boolean
    recycled_materials?: boolean
    generated_image_url?: boolean
    is_saved?: boolean
    created_at?: boolean
    deleted_at?: boolean
  }

  export type CraftIdeaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idea_id" | "generated_by_user_id" | "idea_json" | "recycled_materials" | "generated_image_url" | "is_saved" | "created_at" | "deleted_at", ExtArgs["result"]["craftIdea"]>
  export type CraftIdeaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generated_by_user?: boolean | CraftIdea$generated_by_userArgs<ExtArgs>
  }
  export type CraftIdeaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generated_by_user?: boolean | CraftIdea$generated_by_userArgs<ExtArgs>
  }
  export type CraftIdeaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generated_by_user?: boolean | CraftIdea$generated_by_userArgs<ExtArgs>
  }

  export type $CraftIdeaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CraftIdea"
    objects: {
      generated_by_user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idea_id: number
      generated_by_user_id: number | null
      idea_json: Prisma.JsonValue
      recycled_materials: Prisma.JsonValue | null
      generated_image_url: string | null
      is_saved: boolean
      created_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["craftIdea"]>
    composites: {}
  }

  type CraftIdeaGetPayload<S extends boolean | null | undefined | CraftIdeaDefaultArgs> = $Result.GetResult<Prisma.$CraftIdeaPayload, S>

  type CraftIdeaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CraftIdeaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CraftIdeaCountAggregateInputType | true
    }

  export interface CraftIdeaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CraftIdea'], meta: { name: 'CraftIdea' } }
    /**
     * Find zero or one CraftIdea that matches the filter.
     * @param {CraftIdeaFindUniqueArgs} args - Arguments to find a CraftIdea
     * @example
     * // Get one CraftIdea
     * const craftIdea = await prisma.craftIdea.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CraftIdeaFindUniqueArgs>(args: SelectSubset<T, CraftIdeaFindUniqueArgs<ExtArgs>>): Prisma__CraftIdeaClient<$Result.GetResult<Prisma.$CraftIdeaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CraftIdea that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CraftIdeaFindUniqueOrThrowArgs} args - Arguments to find a CraftIdea
     * @example
     * // Get one CraftIdea
     * const craftIdea = await prisma.craftIdea.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CraftIdeaFindUniqueOrThrowArgs>(args: SelectSubset<T, CraftIdeaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CraftIdeaClient<$Result.GetResult<Prisma.$CraftIdeaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CraftIdea that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftIdeaFindFirstArgs} args - Arguments to find a CraftIdea
     * @example
     * // Get one CraftIdea
     * const craftIdea = await prisma.craftIdea.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CraftIdeaFindFirstArgs>(args?: SelectSubset<T, CraftIdeaFindFirstArgs<ExtArgs>>): Prisma__CraftIdeaClient<$Result.GetResult<Prisma.$CraftIdeaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CraftIdea that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftIdeaFindFirstOrThrowArgs} args - Arguments to find a CraftIdea
     * @example
     * // Get one CraftIdea
     * const craftIdea = await prisma.craftIdea.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CraftIdeaFindFirstOrThrowArgs>(args?: SelectSubset<T, CraftIdeaFindFirstOrThrowArgs<ExtArgs>>): Prisma__CraftIdeaClient<$Result.GetResult<Prisma.$CraftIdeaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CraftIdeas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftIdeaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CraftIdeas
     * const craftIdeas = await prisma.craftIdea.findMany()
     * 
     * // Get first 10 CraftIdeas
     * const craftIdeas = await prisma.craftIdea.findMany({ take: 10 })
     * 
     * // Only select the `idea_id`
     * const craftIdeaWithIdea_idOnly = await prisma.craftIdea.findMany({ select: { idea_id: true } })
     * 
     */
    findMany<T extends CraftIdeaFindManyArgs>(args?: SelectSubset<T, CraftIdeaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CraftIdeaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CraftIdea.
     * @param {CraftIdeaCreateArgs} args - Arguments to create a CraftIdea.
     * @example
     * // Create one CraftIdea
     * const CraftIdea = await prisma.craftIdea.create({
     *   data: {
     *     // ... data to create a CraftIdea
     *   }
     * })
     * 
     */
    create<T extends CraftIdeaCreateArgs>(args: SelectSubset<T, CraftIdeaCreateArgs<ExtArgs>>): Prisma__CraftIdeaClient<$Result.GetResult<Prisma.$CraftIdeaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CraftIdeas.
     * @param {CraftIdeaCreateManyArgs} args - Arguments to create many CraftIdeas.
     * @example
     * // Create many CraftIdeas
     * const craftIdea = await prisma.craftIdea.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CraftIdeaCreateManyArgs>(args?: SelectSubset<T, CraftIdeaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CraftIdeas and returns the data saved in the database.
     * @param {CraftIdeaCreateManyAndReturnArgs} args - Arguments to create many CraftIdeas.
     * @example
     * // Create many CraftIdeas
     * const craftIdea = await prisma.craftIdea.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CraftIdeas and only return the `idea_id`
     * const craftIdeaWithIdea_idOnly = await prisma.craftIdea.createManyAndReturn({
     *   select: { idea_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CraftIdeaCreateManyAndReturnArgs>(args?: SelectSubset<T, CraftIdeaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CraftIdeaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CraftIdea.
     * @param {CraftIdeaDeleteArgs} args - Arguments to delete one CraftIdea.
     * @example
     * // Delete one CraftIdea
     * const CraftIdea = await prisma.craftIdea.delete({
     *   where: {
     *     // ... filter to delete one CraftIdea
     *   }
     * })
     * 
     */
    delete<T extends CraftIdeaDeleteArgs>(args: SelectSubset<T, CraftIdeaDeleteArgs<ExtArgs>>): Prisma__CraftIdeaClient<$Result.GetResult<Prisma.$CraftIdeaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CraftIdea.
     * @param {CraftIdeaUpdateArgs} args - Arguments to update one CraftIdea.
     * @example
     * // Update one CraftIdea
     * const craftIdea = await prisma.craftIdea.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CraftIdeaUpdateArgs>(args: SelectSubset<T, CraftIdeaUpdateArgs<ExtArgs>>): Prisma__CraftIdeaClient<$Result.GetResult<Prisma.$CraftIdeaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CraftIdeas.
     * @param {CraftIdeaDeleteManyArgs} args - Arguments to filter CraftIdeas to delete.
     * @example
     * // Delete a few CraftIdeas
     * const { count } = await prisma.craftIdea.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CraftIdeaDeleteManyArgs>(args?: SelectSubset<T, CraftIdeaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CraftIdeas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftIdeaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CraftIdeas
     * const craftIdea = await prisma.craftIdea.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CraftIdeaUpdateManyArgs>(args: SelectSubset<T, CraftIdeaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CraftIdeas and returns the data updated in the database.
     * @param {CraftIdeaUpdateManyAndReturnArgs} args - Arguments to update many CraftIdeas.
     * @example
     * // Update many CraftIdeas
     * const craftIdea = await prisma.craftIdea.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CraftIdeas and only return the `idea_id`
     * const craftIdeaWithIdea_idOnly = await prisma.craftIdea.updateManyAndReturn({
     *   select: { idea_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CraftIdeaUpdateManyAndReturnArgs>(args: SelectSubset<T, CraftIdeaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CraftIdeaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CraftIdea.
     * @param {CraftIdeaUpsertArgs} args - Arguments to update or create a CraftIdea.
     * @example
     * // Update or create a CraftIdea
     * const craftIdea = await prisma.craftIdea.upsert({
     *   create: {
     *     // ... data to create a CraftIdea
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CraftIdea we want to update
     *   }
     * })
     */
    upsert<T extends CraftIdeaUpsertArgs>(args: SelectSubset<T, CraftIdeaUpsertArgs<ExtArgs>>): Prisma__CraftIdeaClient<$Result.GetResult<Prisma.$CraftIdeaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CraftIdeas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftIdeaCountArgs} args - Arguments to filter CraftIdeas to count.
     * @example
     * // Count the number of CraftIdeas
     * const count = await prisma.craftIdea.count({
     *   where: {
     *     // ... the filter for the CraftIdeas we want to count
     *   }
     * })
    **/
    count<T extends CraftIdeaCountArgs>(
      args?: Subset<T, CraftIdeaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CraftIdeaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CraftIdea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftIdeaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CraftIdeaAggregateArgs>(args: Subset<T, CraftIdeaAggregateArgs>): Prisma.PrismaPromise<GetCraftIdeaAggregateType<T>>

    /**
     * Group by CraftIdea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftIdeaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CraftIdeaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CraftIdeaGroupByArgs['orderBy'] }
        : { orderBy?: CraftIdeaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CraftIdeaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCraftIdeaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CraftIdea model
   */
  readonly fields: CraftIdeaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CraftIdea.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CraftIdeaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    generated_by_user<T extends CraftIdea$generated_by_userArgs<ExtArgs> = {}>(args?: Subset<T, CraftIdea$generated_by_userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CraftIdea model
   */
  interface CraftIdeaFieldRefs {
    readonly idea_id: FieldRef<"CraftIdea", 'Int'>
    readonly generated_by_user_id: FieldRef<"CraftIdea", 'Int'>
    readonly idea_json: FieldRef<"CraftIdea", 'Json'>
    readonly recycled_materials: FieldRef<"CraftIdea", 'Json'>
    readonly generated_image_url: FieldRef<"CraftIdea", 'String'>
    readonly is_saved: FieldRef<"CraftIdea", 'Boolean'>
    readonly created_at: FieldRef<"CraftIdea", 'DateTime'>
    readonly deleted_at: FieldRef<"CraftIdea", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CraftIdea findUnique
   */
  export type CraftIdeaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftIdea
     */
    select?: CraftIdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CraftIdea
     */
    omit?: CraftIdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftIdeaInclude<ExtArgs> | null
    /**
     * Filter, which CraftIdea to fetch.
     */
    where: CraftIdeaWhereUniqueInput
  }

  /**
   * CraftIdea findUniqueOrThrow
   */
  export type CraftIdeaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftIdea
     */
    select?: CraftIdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CraftIdea
     */
    omit?: CraftIdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftIdeaInclude<ExtArgs> | null
    /**
     * Filter, which CraftIdea to fetch.
     */
    where: CraftIdeaWhereUniqueInput
  }

  /**
   * CraftIdea findFirst
   */
  export type CraftIdeaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftIdea
     */
    select?: CraftIdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CraftIdea
     */
    omit?: CraftIdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftIdeaInclude<ExtArgs> | null
    /**
     * Filter, which CraftIdea to fetch.
     */
    where?: CraftIdeaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CraftIdeas to fetch.
     */
    orderBy?: CraftIdeaOrderByWithRelationInput | CraftIdeaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CraftIdeas.
     */
    cursor?: CraftIdeaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CraftIdeas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CraftIdeas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CraftIdeas.
     */
    distinct?: CraftIdeaScalarFieldEnum | CraftIdeaScalarFieldEnum[]
  }

  /**
   * CraftIdea findFirstOrThrow
   */
  export type CraftIdeaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftIdea
     */
    select?: CraftIdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CraftIdea
     */
    omit?: CraftIdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftIdeaInclude<ExtArgs> | null
    /**
     * Filter, which CraftIdea to fetch.
     */
    where?: CraftIdeaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CraftIdeas to fetch.
     */
    orderBy?: CraftIdeaOrderByWithRelationInput | CraftIdeaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CraftIdeas.
     */
    cursor?: CraftIdeaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CraftIdeas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CraftIdeas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CraftIdeas.
     */
    distinct?: CraftIdeaScalarFieldEnum | CraftIdeaScalarFieldEnum[]
  }

  /**
   * CraftIdea findMany
   */
  export type CraftIdeaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftIdea
     */
    select?: CraftIdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CraftIdea
     */
    omit?: CraftIdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftIdeaInclude<ExtArgs> | null
    /**
     * Filter, which CraftIdeas to fetch.
     */
    where?: CraftIdeaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CraftIdeas to fetch.
     */
    orderBy?: CraftIdeaOrderByWithRelationInput | CraftIdeaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CraftIdeas.
     */
    cursor?: CraftIdeaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CraftIdeas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CraftIdeas.
     */
    skip?: number
    distinct?: CraftIdeaScalarFieldEnum | CraftIdeaScalarFieldEnum[]
  }

  /**
   * CraftIdea create
   */
  export type CraftIdeaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftIdea
     */
    select?: CraftIdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CraftIdea
     */
    omit?: CraftIdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftIdeaInclude<ExtArgs> | null
    /**
     * The data needed to create a CraftIdea.
     */
    data: XOR<CraftIdeaCreateInput, CraftIdeaUncheckedCreateInput>
  }

  /**
   * CraftIdea createMany
   */
  export type CraftIdeaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CraftIdeas.
     */
    data: CraftIdeaCreateManyInput | CraftIdeaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CraftIdea createManyAndReturn
   */
  export type CraftIdeaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftIdea
     */
    select?: CraftIdeaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CraftIdea
     */
    omit?: CraftIdeaOmit<ExtArgs> | null
    /**
     * The data used to create many CraftIdeas.
     */
    data: CraftIdeaCreateManyInput | CraftIdeaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftIdeaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CraftIdea update
   */
  export type CraftIdeaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftIdea
     */
    select?: CraftIdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CraftIdea
     */
    omit?: CraftIdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftIdeaInclude<ExtArgs> | null
    /**
     * The data needed to update a CraftIdea.
     */
    data: XOR<CraftIdeaUpdateInput, CraftIdeaUncheckedUpdateInput>
    /**
     * Choose, which CraftIdea to update.
     */
    where: CraftIdeaWhereUniqueInput
  }

  /**
   * CraftIdea updateMany
   */
  export type CraftIdeaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CraftIdeas.
     */
    data: XOR<CraftIdeaUpdateManyMutationInput, CraftIdeaUncheckedUpdateManyInput>
    /**
     * Filter which CraftIdeas to update
     */
    where?: CraftIdeaWhereInput
    /**
     * Limit how many CraftIdeas to update.
     */
    limit?: number
  }

  /**
   * CraftIdea updateManyAndReturn
   */
  export type CraftIdeaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftIdea
     */
    select?: CraftIdeaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CraftIdea
     */
    omit?: CraftIdeaOmit<ExtArgs> | null
    /**
     * The data used to update CraftIdeas.
     */
    data: XOR<CraftIdeaUpdateManyMutationInput, CraftIdeaUncheckedUpdateManyInput>
    /**
     * Filter which CraftIdeas to update
     */
    where?: CraftIdeaWhereInput
    /**
     * Limit how many CraftIdeas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftIdeaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CraftIdea upsert
   */
  export type CraftIdeaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftIdea
     */
    select?: CraftIdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CraftIdea
     */
    omit?: CraftIdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftIdeaInclude<ExtArgs> | null
    /**
     * The filter to search for the CraftIdea to update in case it exists.
     */
    where: CraftIdeaWhereUniqueInput
    /**
     * In case the CraftIdea found by the `where` argument doesn't exist, create a new CraftIdea with this data.
     */
    create: XOR<CraftIdeaCreateInput, CraftIdeaUncheckedCreateInput>
    /**
     * In case the CraftIdea was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CraftIdeaUpdateInput, CraftIdeaUncheckedUpdateInput>
  }

  /**
   * CraftIdea delete
   */
  export type CraftIdeaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftIdea
     */
    select?: CraftIdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CraftIdea
     */
    omit?: CraftIdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftIdeaInclude<ExtArgs> | null
    /**
     * Filter which CraftIdea to delete.
     */
    where: CraftIdeaWhereUniqueInput
  }

  /**
   * CraftIdea deleteMany
   */
  export type CraftIdeaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CraftIdeas to delete
     */
    where?: CraftIdeaWhereInput
    /**
     * Limit how many CraftIdeas to delete.
     */
    limit?: number
  }

  /**
   * CraftIdea.generated_by_user
   */
  export type CraftIdea$generated_by_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CraftIdea without action
   */
  export type CraftIdeaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftIdea
     */
    select?: CraftIdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CraftIdea
     */
    omit?: CraftIdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftIdeaInclude<ExtArgs> | null
  }


  /**
   * Model ChatbotConversation
   */

  export type AggregateChatbotConversation = {
    _count: ChatbotConversationCountAggregateOutputType | null
    _avg: ChatbotConversationAvgAggregateOutputType | null
    _sum: ChatbotConversationSumAggregateOutputType | null
    _min: ChatbotConversationMinAggregateOutputType | null
    _max: ChatbotConversationMaxAggregateOutputType | null
  }

  export type ChatbotConversationAvgAggregateOutputType = {
    conversation_id: number | null
    user_id: number | null
  }

  export type ChatbotConversationSumAggregateOutputType = {
    conversation_id: number | null
    user_id: number | null
  }

  export type ChatbotConversationMinAggregateOutputType = {
    conversation_id: number | null
    user_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ChatbotConversationMaxAggregateOutputType = {
    conversation_id: number | null
    user_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ChatbotConversationCountAggregateOutputType = {
    conversation_id: number
    user_id: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type ChatbotConversationAvgAggregateInputType = {
    conversation_id?: true
    user_id?: true
  }

  export type ChatbotConversationSumAggregateInputType = {
    conversation_id?: true
    user_id?: true
  }

  export type ChatbotConversationMinAggregateInputType = {
    conversation_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ChatbotConversationMaxAggregateInputType = {
    conversation_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ChatbotConversationCountAggregateInputType = {
    conversation_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type ChatbotConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatbotConversation to aggregate.
     */
    where?: ChatbotConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotConversations to fetch.
     */
    orderBy?: ChatbotConversationOrderByWithRelationInput | ChatbotConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatbotConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatbotConversations
    **/
    _count?: true | ChatbotConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatbotConversationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatbotConversationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatbotConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatbotConversationMaxAggregateInputType
  }

  export type GetChatbotConversationAggregateType<T extends ChatbotConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateChatbotConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatbotConversation[P]>
      : GetScalarType<T[P], AggregateChatbotConversation[P]>
  }




  export type ChatbotConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatbotConversationWhereInput
    orderBy?: ChatbotConversationOrderByWithAggregationInput | ChatbotConversationOrderByWithAggregationInput[]
    by: ChatbotConversationScalarFieldEnum[] | ChatbotConversationScalarFieldEnum
    having?: ChatbotConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatbotConversationCountAggregateInputType | true
    _avg?: ChatbotConversationAvgAggregateInputType
    _sum?: ChatbotConversationSumAggregateInputType
    _min?: ChatbotConversationMinAggregateInputType
    _max?: ChatbotConversationMaxAggregateInputType
  }

  export type ChatbotConversationGroupByOutputType = {
    conversation_id: number
    user_id: number
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: ChatbotConversationCountAggregateOutputType | null
    _avg: ChatbotConversationAvgAggregateOutputType | null
    _sum: ChatbotConversationSumAggregateOutputType | null
    _min: ChatbotConversationMinAggregateOutputType | null
    _max: ChatbotConversationMaxAggregateOutputType | null
  }

  type GetChatbotConversationGroupByPayload<T extends ChatbotConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatbotConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatbotConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatbotConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ChatbotConversationGroupByOutputType[P]>
        }
      >
    >


  export type ChatbotConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    conversation_id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | ChatbotConversation$messagesArgs<ExtArgs>
    _count?: boolean | ChatbotConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatbotConversation"]>

  export type ChatbotConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    conversation_id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatbotConversation"]>

  export type ChatbotConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    conversation_id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatbotConversation"]>

  export type ChatbotConversationSelectScalar = {
    conversation_id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type ChatbotConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"conversation_id" | "user_id" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["chatbotConversation"]>
  export type ChatbotConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | ChatbotConversation$messagesArgs<ExtArgs>
    _count?: boolean | ChatbotConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatbotConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatbotConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatbotConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatbotConversation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$ChatbotMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      conversation_id: number
      user_id: number
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["chatbotConversation"]>
    composites: {}
  }

  type ChatbotConversationGetPayload<S extends boolean | null | undefined | ChatbotConversationDefaultArgs> = $Result.GetResult<Prisma.$ChatbotConversationPayload, S>

  type ChatbotConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatbotConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatbotConversationCountAggregateInputType | true
    }

  export interface ChatbotConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatbotConversation'], meta: { name: 'ChatbotConversation' } }
    /**
     * Find zero or one ChatbotConversation that matches the filter.
     * @param {ChatbotConversationFindUniqueArgs} args - Arguments to find a ChatbotConversation
     * @example
     * // Get one ChatbotConversation
     * const chatbotConversation = await prisma.chatbotConversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatbotConversationFindUniqueArgs>(args: SelectSubset<T, ChatbotConversationFindUniqueArgs<ExtArgs>>): Prisma__ChatbotConversationClient<$Result.GetResult<Prisma.$ChatbotConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatbotConversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatbotConversationFindUniqueOrThrowArgs} args - Arguments to find a ChatbotConversation
     * @example
     * // Get one ChatbotConversation
     * const chatbotConversation = await prisma.chatbotConversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatbotConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatbotConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatbotConversationClient<$Result.GetResult<Prisma.$ChatbotConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatbotConversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotConversationFindFirstArgs} args - Arguments to find a ChatbotConversation
     * @example
     * // Get one ChatbotConversation
     * const chatbotConversation = await prisma.chatbotConversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatbotConversationFindFirstArgs>(args?: SelectSubset<T, ChatbotConversationFindFirstArgs<ExtArgs>>): Prisma__ChatbotConversationClient<$Result.GetResult<Prisma.$ChatbotConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatbotConversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotConversationFindFirstOrThrowArgs} args - Arguments to find a ChatbotConversation
     * @example
     * // Get one ChatbotConversation
     * const chatbotConversation = await prisma.chatbotConversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatbotConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatbotConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatbotConversationClient<$Result.GetResult<Prisma.$ChatbotConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatbotConversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatbotConversations
     * const chatbotConversations = await prisma.chatbotConversation.findMany()
     * 
     * // Get first 10 ChatbotConversations
     * const chatbotConversations = await prisma.chatbotConversation.findMany({ take: 10 })
     * 
     * // Only select the `conversation_id`
     * const chatbotConversationWithConversation_idOnly = await prisma.chatbotConversation.findMany({ select: { conversation_id: true } })
     * 
     */
    findMany<T extends ChatbotConversationFindManyArgs>(args?: SelectSubset<T, ChatbotConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatbotConversation.
     * @param {ChatbotConversationCreateArgs} args - Arguments to create a ChatbotConversation.
     * @example
     * // Create one ChatbotConversation
     * const ChatbotConversation = await prisma.chatbotConversation.create({
     *   data: {
     *     // ... data to create a ChatbotConversation
     *   }
     * })
     * 
     */
    create<T extends ChatbotConversationCreateArgs>(args: SelectSubset<T, ChatbotConversationCreateArgs<ExtArgs>>): Prisma__ChatbotConversationClient<$Result.GetResult<Prisma.$ChatbotConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatbotConversations.
     * @param {ChatbotConversationCreateManyArgs} args - Arguments to create many ChatbotConversations.
     * @example
     * // Create many ChatbotConversations
     * const chatbotConversation = await prisma.chatbotConversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatbotConversationCreateManyArgs>(args?: SelectSubset<T, ChatbotConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatbotConversations and returns the data saved in the database.
     * @param {ChatbotConversationCreateManyAndReturnArgs} args - Arguments to create many ChatbotConversations.
     * @example
     * // Create many ChatbotConversations
     * const chatbotConversation = await prisma.chatbotConversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatbotConversations and only return the `conversation_id`
     * const chatbotConversationWithConversation_idOnly = await prisma.chatbotConversation.createManyAndReturn({
     *   select: { conversation_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatbotConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatbotConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatbotConversation.
     * @param {ChatbotConversationDeleteArgs} args - Arguments to delete one ChatbotConversation.
     * @example
     * // Delete one ChatbotConversation
     * const ChatbotConversation = await prisma.chatbotConversation.delete({
     *   where: {
     *     // ... filter to delete one ChatbotConversation
     *   }
     * })
     * 
     */
    delete<T extends ChatbotConversationDeleteArgs>(args: SelectSubset<T, ChatbotConversationDeleteArgs<ExtArgs>>): Prisma__ChatbotConversationClient<$Result.GetResult<Prisma.$ChatbotConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatbotConversation.
     * @param {ChatbotConversationUpdateArgs} args - Arguments to update one ChatbotConversation.
     * @example
     * // Update one ChatbotConversation
     * const chatbotConversation = await prisma.chatbotConversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatbotConversationUpdateArgs>(args: SelectSubset<T, ChatbotConversationUpdateArgs<ExtArgs>>): Prisma__ChatbotConversationClient<$Result.GetResult<Prisma.$ChatbotConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatbotConversations.
     * @param {ChatbotConversationDeleteManyArgs} args - Arguments to filter ChatbotConversations to delete.
     * @example
     * // Delete a few ChatbotConversations
     * const { count } = await prisma.chatbotConversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatbotConversationDeleteManyArgs>(args?: SelectSubset<T, ChatbotConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatbotConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatbotConversations
     * const chatbotConversation = await prisma.chatbotConversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatbotConversationUpdateManyArgs>(args: SelectSubset<T, ChatbotConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatbotConversations and returns the data updated in the database.
     * @param {ChatbotConversationUpdateManyAndReturnArgs} args - Arguments to update many ChatbotConversations.
     * @example
     * // Update many ChatbotConversations
     * const chatbotConversation = await prisma.chatbotConversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatbotConversations and only return the `conversation_id`
     * const chatbotConversationWithConversation_idOnly = await prisma.chatbotConversation.updateManyAndReturn({
     *   select: { conversation_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatbotConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatbotConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatbotConversation.
     * @param {ChatbotConversationUpsertArgs} args - Arguments to update or create a ChatbotConversation.
     * @example
     * // Update or create a ChatbotConversation
     * const chatbotConversation = await prisma.chatbotConversation.upsert({
     *   create: {
     *     // ... data to create a ChatbotConversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatbotConversation we want to update
     *   }
     * })
     */
    upsert<T extends ChatbotConversationUpsertArgs>(args: SelectSubset<T, ChatbotConversationUpsertArgs<ExtArgs>>): Prisma__ChatbotConversationClient<$Result.GetResult<Prisma.$ChatbotConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatbotConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotConversationCountArgs} args - Arguments to filter ChatbotConversations to count.
     * @example
     * // Count the number of ChatbotConversations
     * const count = await prisma.chatbotConversation.count({
     *   where: {
     *     // ... the filter for the ChatbotConversations we want to count
     *   }
     * })
    **/
    count<T extends ChatbotConversationCountArgs>(
      args?: Subset<T, ChatbotConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatbotConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatbotConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatbotConversationAggregateArgs>(args: Subset<T, ChatbotConversationAggregateArgs>): Prisma.PrismaPromise<GetChatbotConversationAggregateType<T>>

    /**
     * Group by ChatbotConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatbotConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatbotConversationGroupByArgs['orderBy'] }
        : { orderBy?: ChatbotConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatbotConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatbotConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatbotConversation model
   */
  readonly fields: ChatbotConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatbotConversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatbotConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends ChatbotConversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, ChatbotConversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatbotConversation model
   */
  interface ChatbotConversationFieldRefs {
    readonly conversation_id: FieldRef<"ChatbotConversation", 'Int'>
    readonly user_id: FieldRef<"ChatbotConversation", 'Int'>
    readonly created_at: FieldRef<"ChatbotConversation", 'DateTime'>
    readonly updated_at: FieldRef<"ChatbotConversation", 'DateTime'>
    readonly deleted_at: FieldRef<"ChatbotConversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatbotConversation findUnique
   */
  export type ChatbotConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotConversation
     */
    select?: ChatbotConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotConversation
     */
    omit?: ChatbotConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotConversationInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotConversation to fetch.
     */
    where: ChatbotConversationWhereUniqueInput
  }

  /**
   * ChatbotConversation findUniqueOrThrow
   */
  export type ChatbotConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotConversation
     */
    select?: ChatbotConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotConversation
     */
    omit?: ChatbotConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotConversationInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotConversation to fetch.
     */
    where: ChatbotConversationWhereUniqueInput
  }

  /**
   * ChatbotConversation findFirst
   */
  export type ChatbotConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotConversation
     */
    select?: ChatbotConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotConversation
     */
    omit?: ChatbotConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotConversationInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotConversation to fetch.
     */
    where?: ChatbotConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotConversations to fetch.
     */
    orderBy?: ChatbotConversationOrderByWithRelationInput | ChatbotConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatbotConversations.
     */
    cursor?: ChatbotConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatbotConversations.
     */
    distinct?: ChatbotConversationScalarFieldEnum | ChatbotConversationScalarFieldEnum[]
  }

  /**
   * ChatbotConversation findFirstOrThrow
   */
  export type ChatbotConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotConversation
     */
    select?: ChatbotConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotConversation
     */
    omit?: ChatbotConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotConversationInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotConversation to fetch.
     */
    where?: ChatbotConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotConversations to fetch.
     */
    orderBy?: ChatbotConversationOrderByWithRelationInput | ChatbotConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatbotConversations.
     */
    cursor?: ChatbotConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatbotConversations.
     */
    distinct?: ChatbotConversationScalarFieldEnum | ChatbotConversationScalarFieldEnum[]
  }

  /**
   * ChatbotConversation findMany
   */
  export type ChatbotConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotConversation
     */
    select?: ChatbotConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotConversation
     */
    omit?: ChatbotConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotConversationInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotConversations to fetch.
     */
    where?: ChatbotConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotConversations to fetch.
     */
    orderBy?: ChatbotConversationOrderByWithRelationInput | ChatbotConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatbotConversations.
     */
    cursor?: ChatbotConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotConversations.
     */
    skip?: number
    distinct?: ChatbotConversationScalarFieldEnum | ChatbotConversationScalarFieldEnum[]
  }

  /**
   * ChatbotConversation create
   */
  export type ChatbotConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotConversation
     */
    select?: ChatbotConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotConversation
     */
    omit?: ChatbotConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatbotConversation.
     */
    data: XOR<ChatbotConversationCreateInput, ChatbotConversationUncheckedCreateInput>
  }

  /**
   * ChatbotConversation createMany
   */
  export type ChatbotConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatbotConversations.
     */
    data: ChatbotConversationCreateManyInput | ChatbotConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatbotConversation createManyAndReturn
   */
  export type ChatbotConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotConversation
     */
    select?: ChatbotConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotConversation
     */
    omit?: ChatbotConversationOmit<ExtArgs> | null
    /**
     * The data used to create many ChatbotConversations.
     */
    data: ChatbotConversationCreateManyInput | ChatbotConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatbotConversation update
   */
  export type ChatbotConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotConversation
     */
    select?: ChatbotConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotConversation
     */
    omit?: ChatbotConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatbotConversation.
     */
    data: XOR<ChatbotConversationUpdateInput, ChatbotConversationUncheckedUpdateInput>
    /**
     * Choose, which ChatbotConversation to update.
     */
    where: ChatbotConversationWhereUniqueInput
  }

  /**
   * ChatbotConversation updateMany
   */
  export type ChatbotConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatbotConversations.
     */
    data: XOR<ChatbotConversationUpdateManyMutationInput, ChatbotConversationUncheckedUpdateManyInput>
    /**
     * Filter which ChatbotConversations to update
     */
    where?: ChatbotConversationWhereInput
    /**
     * Limit how many ChatbotConversations to update.
     */
    limit?: number
  }

  /**
   * ChatbotConversation updateManyAndReturn
   */
  export type ChatbotConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotConversation
     */
    select?: ChatbotConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotConversation
     */
    omit?: ChatbotConversationOmit<ExtArgs> | null
    /**
     * The data used to update ChatbotConversations.
     */
    data: XOR<ChatbotConversationUpdateManyMutationInput, ChatbotConversationUncheckedUpdateManyInput>
    /**
     * Filter which ChatbotConversations to update
     */
    where?: ChatbotConversationWhereInput
    /**
     * Limit how many ChatbotConversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatbotConversation upsert
   */
  export type ChatbotConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotConversation
     */
    select?: ChatbotConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotConversation
     */
    omit?: ChatbotConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatbotConversation to update in case it exists.
     */
    where: ChatbotConversationWhereUniqueInput
    /**
     * In case the ChatbotConversation found by the `where` argument doesn't exist, create a new ChatbotConversation with this data.
     */
    create: XOR<ChatbotConversationCreateInput, ChatbotConversationUncheckedCreateInput>
    /**
     * In case the ChatbotConversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatbotConversationUpdateInput, ChatbotConversationUncheckedUpdateInput>
  }

  /**
   * ChatbotConversation delete
   */
  export type ChatbotConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotConversation
     */
    select?: ChatbotConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotConversation
     */
    omit?: ChatbotConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotConversationInclude<ExtArgs> | null
    /**
     * Filter which ChatbotConversation to delete.
     */
    where: ChatbotConversationWhereUniqueInput
  }

  /**
   * ChatbotConversation deleteMany
   */
  export type ChatbotConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatbotConversations to delete
     */
    where?: ChatbotConversationWhereInput
    /**
     * Limit how many ChatbotConversations to delete.
     */
    limit?: number
  }

  /**
   * ChatbotConversation.messages
   */
  export type ChatbotConversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    where?: ChatbotMessageWhereInput
    orderBy?: ChatbotMessageOrderByWithRelationInput | ChatbotMessageOrderByWithRelationInput[]
    cursor?: ChatbotMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatbotMessageScalarFieldEnum | ChatbotMessageScalarFieldEnum[]
  }

  /**
   * ChatbotConversation without action
   */
  export type ChatbotConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotConversation
     */
    select?: ChatbotConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotConversation
     */
    omit?: ChatbotConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotConversationInclude<ExtArgs> | null
  }


  /**
   * Model ChatbotMessage
   */

  export type AggregateChatbotMessage = {
    _count: ChatbotMessageCountAggregateOutputType | null
    _avg: ChatbotMessageAvgAggregateOutputType | null
    _sum: ChatbotMessageSumAggregateOutputType | null
    _min: ChatbotMessageMinAggregateOutputType | null
    _max: ChatbotMessageMaxAggregateOutputType | null
  }

  export type ChatbotMessageAvgAggregateOutputType = {
    message_id: number | null
    conversation_id: number | null
  }

  export type ChatbotMessageSumAggregateOutputType = {
    message_id: number | null
    conversation_id: number | null
  }

  export type ChatbotMessageMinAggregateOutputType = {
    message_id: number | null
    conversation_id: number | null
    sender: $Enums.MessageSender | null
    content: string | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type ChatbotMessageMaxAggregateOutputType = {
    message_id: number | null
    conversation_id: number | null
    sender: $Enums.MessageSender | null
    content: string | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type ChatbotMessageCountAggregateOutputType = {
    message_id: number
    conversation_id: number
    sender: number
    content: number
    created_at: number
    deleted_at: number
    _all: number
  }


  export type ChatbotMessageAvgAggregateInputType = {
    message_id?: true
    conversation_id?: true
  }

  export type ChatbotMessageSumAggregateInputType = {
    message_id?: true
    conversation_id?: true
  }

  export type ChatbotMessageMinAggregateInputType = {
    message_id?: true
    conversation_id?: true
    sender?: true
    content?: true
    created_at?: true
    deleted_at?: true
  }

  export type ChatbotMessageMaxAggregateInputType = {
    message_id?: true
    conversation_id?: true
    sender?: true
    content?: true
    created_at?: true
    deleted_at?: true
  }

  export type ChatbotMessageCountAggregateInputType = {
    message_id?: true
    conversation_id?: true
    sender?: true
    content?: true
    created_at?: true
    deleted_at?: true
    _all?: true
  }

  export type ChatbotMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatbotMessage to aggregate.
     */
    where?: ChatbotMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotMessages to fetch.
     */
    orderBy?: ChatbotMessageOrderByWithRelationInput | ChatbotMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatbotMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatbotMessages
    **/
    _count?: true | ChatbotMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatbotMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatbotMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatbotMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatbotMessageMaxAggregateInputType
  }

  export type GetChatbotMessageAggregateType<T extends ChatbotMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatbotMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatbotMessage[P]>
      : GetScalarType<T[P], AggregateChatbotMessage[P]>
  }




  export type ChatbotMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatbotMessageWhereInput
    orderBy?: ChatbotMessageOrderByWithAggregationInput | ChatbotMessageOrderByWithAggregationInput[]
    by: ChatbotMessageScalarFieldEnum[] | ChatbotMessageScalarFieldEnum
    having?: ChatbotMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatbotMessageCountAggregateInputType | true
    _avg?: ChatbotMessageAvgAggregateInputType
    _sum?: ChatbotMessageSumAggregateInputType
    _min?: ChatbotMessageMinAggregateInputType
    _max?: ChatbotMessageMaxAggregateInputType
  }

  export type ChatbotMessageGroupByOutputType = {
    message_id: number
    conversation_id: number
    sender: $Enums.MessageSender
    content: string
    created_at: Date
    deleted_at: Date | null
    _count: ChatbotMessageCountAggregateOutputType | null
    _avg: ChatbotMessageAvgAggregateOutputType | null
    _sum: ChatbotMessageSumAggregateOutputType | null
    _min: ChatbotMessageMinAggregateOutputType | null
    _max: ChatbotMessageMaxAggregateOutputType | null
  }

  type GetChatbotMessageGroupByPayload<T extends ChatbotMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatbotMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatbotMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatbotMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatbotMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatbotMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    message_id?: boolean
    conversation_id?: boolean
    sender?: boolean
    content?: boolean
    created_at?: boolean
    deleted_at?: boolean
    conversation?: boolean | ChatbotConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatbotMessage"]>

  export type ChatbotMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    message_id?: boolean
    conversation_id?: boolean
    sender?: boolean
    content?: boolean
    created_at?: boolean
    deleted_at?: boolean
    conversation?: boolean | ChatbotConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatbotMessage"]>

  export type ChatbotMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    message_id?: boolean
    conversation_id?: boolean
    sender?: boolean
    content?: boolean
    created_at?: boolean
    deleted_at?: boolean
    conversation?: boolean | ChatbotConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatbotMessage"]>

  export type ChatbotMessageSelectScalar = {
    message_id?: boolean
    conversation_id?: boolean
    sender?: boolean
    content?: boolean
    created_at?: boolean
    deleted_at?: boolean
  }

  export type ChatbotMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"message_id" | "conversation_id" | "sender" | "content" | "created_at" | "deleted_at", ExtArgs["result"]["chatbotMessage"]>
  export type ChatbotMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ChatbotConversationDefaultArgs<ExtArgs>
  }
  export type ChatbotMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ChatbotConversationDefaultArgs<ExtArgs>
  }
  export type ChatbotMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ChatbotConversationDefaultArgs<ExtArgs>
  }

  export type $ChatbotMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatbotMessage"
    objects: {
      conversation: Prisma.$ChatbotConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      message_id: number
      conversation_id: number
      sender: $Enums.MessageSender
      content: string
      created_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["chatbotMessage"]>
    composites: {}
  }

  type ChatbotMessageGetPayload<S extends boolean | null | undefined | ChatbotMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatbotMessagePayload, S>

  type ChatbotMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatbotMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatbotMessageCountAggregateInputType | true
    }

  export interface ChatbotMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatbotMessage'], meta: { name: 'ChatbotMessage' } }
    /**
     * Find zero or one ChatbotMessage that matches the filter.
     * @param {ChatbotMessageFindUniqueArgs} args - Arguments to find a ChatbotMessage
     * @example
     * // Get one ChatbotMessage
     * const chatbotMessage = await prisma.chatbotMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatbotMessageFindUniqueArgs>(args: SelectSubset<T, ChatbotMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatbotMessageClient<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatbotMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatbotMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatbotMessage
     * @example
     * // Get one ChatbotMessage
     * const chatbotMessage = await prisma.chatbotMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatbotMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatbotMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatbotMessageClient<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatbotMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotMessageFindFirstArgs} args - Arguments to find a ChatbotMessage
     * @example
     * // Get one ChatbotMessage
     * const chatbotMessage = await prisma.chatbotMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatbotMessageFindFirstArgs>(args?: SelectSubset<T, ChatbotMessageFindFirstArgs<ExtArgs>>): Prisma__ChatbotMessageClient<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatbotMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotMessageFindFirstOrThrowArgs} args - Arguments to find a ChatbotMessage
     * @example
     * // Get one ChatbotMessage
     * const chatbotMessage = await prisma.chatbotMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatbotMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatbotMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatbotMessageClient<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatbotMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatbotMessages
     * const chatbotMessages = await prisma.chatbotMessage.findMany()
     * 
     * // Get first 10 ChatbotMessages
     * const chatbotMessages = await prisma.chatbotMessage.findMany({ take: 10 })
     * 
     * // Only select the `message_id`
     * const chatbotMessageWithMessage_idOnly = await prisma.chatbotMessage.findMany({ select: { message_id: true } })
     * 
     */
    findMany<T extends ChatbotMessageFindManyArgs>(args?: SelectSubset<T, ChatbotMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatbotMessage.
     * @param {ChatbotMessageCreateArgs} args - Arguments to create a ChatbotMessage.
     * @example
     * // Create one ChatbotMessage
     * const ChatbotMessage = await prisma.chatbotMessage.create({
     *   data: {
     *     // ... data to create a ChatbotMessage
     *   }
     * })
     * 
     */
    create<T extends ChatbotMessageCreateArgs>(args: SelectSubset<T, ChatbotMessageCreateArgs<ExtArgs>>): Prisma__ChatbotMessageClient<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatbotMessages.
     * @param {ChatbotMessageCreateManyArgs} args - Arguments to create many ChatbotMessages.
     * @example
     * // Create many ChatbotMessages
     * const chatbotMessage = await prisma.chatbotMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatbotMessageCreateManyArgs>(args?: SelectSubset<T, ChatbotMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatbotMessages and returns the data saved in the database.
     * @param {ChatbotMessageCreateManyAndReturnArgs} args - Arguments to create many ChatbotMessages.
     * @example
     * // Create many ChatbotMessages
     * const chatbotMessage = await prisma.chatbotMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatbotMessages and only return the `message_id`
     * const chatbotMessageWithMessage_idOnly = await prisma.chatbotMessage.createManyAndReturn({
     *   select: { message_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatbotMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatbotMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatbotMessage.
     * @param {ChatbotMessageDeleteArgs} args - Arguments to delete one ChatbotMessage.
     * @example
     * // Delete one ChatbotMessage
     * const ChatbotMessage = await prisma.chatbotMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatbotMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatbotMessageDeleteArgs>(args: SelectSubset<T, ChatbotMessageDeleteArgs<ExtArgs>>): Prisma__ChatbotMessageClient<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatbotMessage.
     * @param {ChatbotMessageUpdateArgs} args - Arguments to update one ChatbotMessage.
     * @example
     * // Update one ChatbotMessage
     * const chatbotMessage = await prisma.chatbotMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatbotMessageUpdateArgs>(args: SelectSubset<T, ChatbotMessageUpdateArgs<ExtArgs>>): Prisma__ChatbotMessageClient<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatbotMessages.
     * @param {ChatbotMessageDeleteManyArgs} args - Arguments to filter ChatbotMessages to delete.
     * @example
     * // Delete a few ChatbotMessages
     * const { count } = await prisma.chatbotMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatbotMessageDeleteManyArgs>(args?: SelectSubset<T, ChatbotMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatbotMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatbotMessages
     * const chatbotMessage = await prisma.chatbotMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatbotMessageUpdateManyArgs>(args: SelectSubset<T, ChatbotMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatbotMessages and returns the data updated in the database.
     * @param {ChatbotMessageUpdateManyAndReturnArgs} args - Arguments to update many ChatbotMessages.
     * @example
     * // Update many ChatbotMessages
     * const chatbotMessage = await prisma.chatbotMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatbotMessages and only return the `message_id`
     * const chatbotMessageWithMessage_idOnly = await prisma.chatbotMessage.updateManyAndReturn({
     *   select: { message_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatbotMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatbotMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatbotMessage.
     * @param {ChatbotMessageUpsertArgs} args - Arguments to update or create a ChatbotMessage.
     * @example
     * // Update or create a ChatbotMessage
     * const chatbotMessage = await prisma.chatbotMessage.upsert({
     *   create: {
     *     // ... data to create a ChatbotMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatbotMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatbotMessageUpsertArgs>(args: SelectSubset<T, ChatbotMessageUpsertArgs<ExtArgs>>): Prisma__ChatbotMessageClient<$Result.GetResult<Prisma.$ChatbotMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatbotMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotMessageCountArgs} args - Arguments to filter ChatbotMessages to count.
     * @example
     * // Count the number of ChatbotMessages
     * const count = await prisma.chatbotMessage.count({
     *   where: {
     *     // ... the filter for the ChatbotMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatbotMessageCountArgs>(
      args?: Subset<T, ChatbotMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatbotMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatbotMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatbotMessageAggregateArgs>(args: Subset<T, ChatbotMessageAggregateArgs>): Prisma.PrismaPromise<GetChatbotMessageAggregateType<T>>

    /**
     * Group by ChatbotMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatbotMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatbotMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatbotMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatbotMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatbotMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatbotMessage model
   */
  readonly fields: ChatbotMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatbotMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatbotMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ChatbotConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatbotConversationDefaultArgs<ExtArgs>>): Prisma__ChatbotConversationClient<$Result.GetResult<Prisma.$ChatbotConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatbotMessage model
   */
  interface ChatbotMessageFieldRefs {
    readonly message_id: FieldRef<"ChatbotMessage", 'Int'>
    readonly conversation_id: FieldRef<"ChatbotMessage", 'Int'>
    readonly sender: FieldRef<"ChatbotMessage", 'MessageSender'>
    readonly content: FieldRef<"ChatbotMessage", 'String'>
    readonly created_at: FieldRef<"ChatbotMessage", 'DateTime'>
    readonly deleted_at: FieldRef<"ChatbotMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatbotMessage findUnique
   */
  export type ChatbotMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotMessage to fetch.
     */
    where: ChatbotMessageWhereUniqueInput
  }

  /**
   * ChatbotMessage findUniqueOrThrow
   */
  export type ChatbotMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotMessage to fetch.
     */
    where: ChatbotMessageWhereUniqueInput
  }

  /**
   * ChatbotMessage findFirst
   */
  export type ChatbotMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotMessage to fetch.
     */
    where?: ChatbotMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotMessages to fetch.
     */
    orderBy?: ChatbotMessageOrderByWithRelationInput | ChatbotMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatbotMessages.
     */
    cursor?: ChatbotMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatbotMessages.
     */
    distinct?: ChatbotMessageScalarFieldEnum | ChatbotMessageScalarFieldEnum[]
  }

  /**
   * ChatbotMessage findFirstOrThrow
   */
  export type ChatbotMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotMessage to fetch.
     */
    where?: ChatbotMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotMessages to fetch.
     */
    orderBy?: ChatbotMessageOrderByWithRelationInput | ChatbotMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatbotMessages.
     */
    cursor?: ChatbotMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatbotMessages.
     */
    distinct?: ChatbotMessageScalarFieldEnum | ChatbotMessageScalarFieldEnum[]
  }

  /**
   * ChatbotMessage findMany
   */
  export type ChatbotMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatbotMessages to fetch.
     */
    where?: ChatbotMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatbotMessages to fetch.
     */
    orderBy?: ChatbotMessageOrderByWithRelationInput | ChatbotMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatbotMessages.
     */
    cursor?: ChatbotMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatbotMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatbotMessages.
     */
    skip?: number
    distinct?: ChatbotMessageScalarFieldEnum | ChatbotMessageScalarFieldEnum[]
  }

  /**
   * ChatbotMessage create
   */
  export type ChatbotMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatbotMessage.
     */
    data: XOR<ChatbotMessageCreateInput, ChatbotMessageUncheckedCreateInput>
  }

  /**
   * ChatbotMessage createMany
   */
  export type ChatbotMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatbotMessages.
     */
    data: ChatbotMessageCreateManyInput | ChatbotMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatbotMessage createManyAndReturn
   */
  export type ChatbotMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ChatbotMessages.
     */
    data: ChatbotMessageCreateManyInput | ChatbotMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatbotMessage update
   */
  export type ChatbotMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatbotMessage.
     */
    data: XOR<ChatbotMessageUpdateInput, ChatbotMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatbotMessage to update.
     */
    where: ChatbotMessageWhereUniqueInput
  }

  /**
   * ChatbotMessage updateMany
   */
  export type ChatbotMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatbotMessages.
     */
    data: XOR<ChatbotMessageUpdateManyMutationInput, ChatbotMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatbotMessages to update
     */
    where?: ChatbotMessageWhereInput
    /**
     * Limit how many ChatbotMessages to update.
     */
    limit?: number
  }

  /**
   * ChatbotMessage updateManyAndReturn
   */
  export type ChatbotMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * The data used to update ChatbotMessages.
     */
    data: XOR<ChatbotMessageUpdateManyMutationInput, ChatbotMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatbotMessages to update
     */
    where?: ChatbotMessageWhereInput
    /**
     * Limit how many ChatbotMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatbotMessage upsert
   */
  export type ChatbotMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatbotMessage to update in case it exists.
     */
    where: ChatbotMessageWhereUniqueInput
    /**
     * In case the ChatbotMessage found by the `where` argument doesn't exist, create a new ChatbotMessage with this data.
     */
    create: XOR<ChatbotMessageCreateInput, ChatbotMessageUncheckedCreateInput>
    /**
     * In case the ChatbotMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatbotMessageUpdateInput, ChatbotMessageUncheckedUpdateInput>
  }

  /**
   * ChatbotMessage delete
   */
  export type ChatbotMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatbotMessage to delete.
     */
    where: ChatbotMessageWhereUniqueInput
  }

  /**
   * ChatbotMessage deleteMany
   */
  export type ChatbotMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatbotMessages to delete
     */
    where?: ChatbotMessageWhereInput
    /**
     * Limit how many ChatbotMessages to delete.
     */
    limit?: number
  }

  /**
   * ChatbotMessage without action
   */
  export type ChatbotMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatbotMessage
     */
    select?: ChatbotMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatbotMessage
     */
    omit?: ChatbotMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotMessageInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    post_id: number | null
    user_id: number | null
  }

  export type PostSumAggregateOutputType = {
    post_id: number | null
    user_id: number | null
  }

  export type PostMinAggregateOutputType = {
    post_id: number | null
    user_id: number | null
    title: string | null
    content: string | null
    image_url: string | null
    category: $Enums.Category | null
    featured: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type PostMaxAggregateOutputType = {
    post_id: number | null
    user_id: number | null
    title: string | null
    content: string | null
    image_url: string | null
    category: $Enums.Category | null
    featured: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type PostCountAggregateOutputType = {
    post_id: number
    user_id: number
    title: number
    content: number
    image_url: number
    tags: number
    category: number
    featured: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    post_id?: true
    user_id?: true
  }

  export type PostSumAggregateInputType = {
    post_id?: true
    user_id?: true
  }

  export type PostMinAggregateInputType = {
    post_id?: true
    user_id?: true
    title?: true
    content?: true
    image_url?: true
    category?: true
    featured?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type PostMaxAggregateInputType = {
    post_id?: true
    user_id?: true
    title?: true
    content?: true
    image_url?: true
    category?: true
    featured?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type PostCountAggregateInputType = {
    post_id?: true
    user_id?: true
    title?: true
    content?: true
    image_url?: true
    tags?: true
    category?: true
    featured?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    post_id: number
    user_id: number
    title: string
    content: string
    image_url: string | null
    tags: string[]
    category: $Enums.Category
    featured: boolean
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    post_id?: boolean
    user_id?: boolean
    title?: boolean
    content?: boolean
    image_url?: boolean
    tags?: boolean
    category?: boolean
    featured?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    comments?: boolean | Post$commentsArgs<ExtArgs>
    likes?: boolean | Post$likesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    reports?: boolean | Post$reportsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    post_id?: boolean
    user_id?: boolean
    title?: boolean
    content?: boolean
    image_url?: boolean
    tags?: boolean
    category?: boolean
    featured?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    post_id?: boolean
    user_id?: boolean
    title?: boolean
    content?: boolean
    image_url?: boolean
    tags?: boolean
    category?: boolean
    featured?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    post_id?: boolean
    user_id?: boolean
    title?: boolean
    content?: boolean
    image_url?: boolean
    tags?: boolean
    category?: boolean
    featured?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"post_id" | "user_id" | "title" | "content" | "image_url" | "tags" | "category" | "featured" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | Post$commentsArgs<ExtArgs>
    likes?: boolean | Post$likesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    reports?: boolean | Post$reportsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      comments: Prisma.$CommentPayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      reports: Prisma.$ReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      post_id: number
      user_id: number
      title: string
      content: string
      image_url: string | null
      tags: string[]
      category: $Enums.Category
      featured: boolean
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `post_id`
     * const postWithPost_idOnly = await prisma.post.findMany({ select: { post_id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `post_id`
     * const postWithPost_idOnly = await prisma.post.createManyAndReturn({
     *   select: { post_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `post_id`
     * const postWithPost_idOnly = await prisma.post.updateManyAndReturn({
     *   select: { post_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends Post$likesArgs<ExtArgs> = {}>(args?: Subset<T, Post$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reports<T extends Post$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Post$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly post_id: FieldRef<"Post", 'Int'>
    readonly user_id: FieldRef<"Post", 'Int'>
    readonly title: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly image_url: FieldRef<"Post", 'String'>
    readonly tags: FieldRef<"Post", 'String[]'>
    readonly category: FieldRef<"Post", 'Category'>
    readonly featured: FieldRef<"Post", 'Boolean'>
    readonly created_at: FieldRef<"Post", 'DateTime'>
    readonly updated_at: FieldRef<"Post", 'DateTime'>
    readonly deleted_at: FieldRef<"Post", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post updateManyAndReturn
   */
  export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Post.likes
   */
  export type Post$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Post.reports
   */
  export type Post$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    comment_id: number | null
    post_id: number | null
    user_id: number | null
  }

  export type CommentSumAggregateOutputType = {
    comment_id: number | null
    post_id: number | null
    user_id: number | null
  }

  export type CommentMinAggregateOutputType = {
    comment_id: number | null
    post_id: number | null
    user_id: number | null
    content: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    comment_id: number | null
    post_id: number | null
    user_id: number | null
    content: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type CommentCountAggregateOutputType = {
    comment_id: number
    post_id: number
    user_id: number
    content: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    comment_id?: true
    post_id?: true
    user_id?: true
  }

  export type CommentSumAggregateInputType = {
    comment_id?: true
    post_id?: true
    user_id?: true
  }

  export type CommentMinAggregateInputType = {
    comment_id?: true
    post_id?: true
    user_id?: true
    content?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type CommentMaxAggregateInputType = {
    comment_id?: true
    post_id?: true
    user_id?: true
    content?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type CommentCountAggregateInputType = {
    comment_id?: true
    post_id?: true
    user_id?: true
    content?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    comment_id: number
    post_id: number
    user_id: number
    content: string
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    comment_id?: boolean
    post_id?: boolean
    user_id?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    reports?: boolean | Comment$reportsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    comment_id?: boolean
    post_id?: boolean
    user_id?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    comment_id?: boolean
    post_id?: boolean
    user_id?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    comment_id?: boolean
    post_id?: boolean
    user_id?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"comment_id" | "post_id" | "user_id" | "content" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    reports?: boolean | Comment$reportsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      reports: Prisma.$ReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      comment_id: number
      post_id: number
      user_id: number
      content: string
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `comment_id`
     * const commentWithComment_idOnly = await prisma.comment.findMany({ select: { comment_id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `comment_id`
     * const commentWithComment_idOnly = await prisma.comment.createManyAndReturn({
     *   select: { comment_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `comment_id`
     * const commentWithComment_idOnly = await prisma.comment.updateManyAndReturn({
     *   select: { comment_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reports<T extends Comment$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly comment_id: FieldRef<"Comment", 'Int'>
    readonly post_id: FieldRef<"Comment", 'Int'>
    readonly user_id: FieldRef<"Comment", 'Int'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly created_at: FieldRef<"Comment", 'DateTime'>
    readonly updated_at: FieldRef<"Comment", 'DateTime'>
    readonly deleted_at: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.reports
   */
  export type Comment$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Like
   */

  export type AggregateLike = {
    _count: LikeCountAggregateOutputType | null
    _avg: LikeAvgAggregateOutputType | null
    _sum: LikeSumAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  export type LikeAvgAggregateOutputType = {
    like_id: number | null
    post_id: number | null
    user_id: number | null
  }

  export type LikeSumAggregateOutputType = {
    like_id: number | null
    post_id: number | null
    user_id: number | null
  }

  export type LikeMinAggregateOutputType = {
    like_id: number | null
    post_id: number | null
    user_id: number | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type LikeMaxAggregateOutputType = {
    like_id: number | null
    post_id: number | null
    user_id: number | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type LikeCountAggregateOutputType = {
    like_id: number
    post_id: number
    user_id: number
    created_at: number
    deleted_at: number
    _all: number
  }


  export type LikeAvgAggregateInputType = {
    like_id?: true
    post_id?: true
    user_id?: true
  }

  export type LikeSumAggregateInputType = {
    like_id?: true
    post_id?: true
    user_id?: true
  }

  export type LikeMinAggregateInputType = {
    like_id?: true
    post_id?: true
    user_id?: true
    created_at?: true
    deleted_at?: true
  }

  export type LikeMaxAggregateInputType = {
    like_id?: true
    post_id?: true
    user_id?: true
    created_at?: true
    deleted_at?: true
  }

  export type LikeCountAggregateInputType = {
    like_id?: true
    post_id?: true
    user_id?: true
    created_at?: true
    deleted_at?: true
    _all?: true
  }

  export type LikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Like to aggregate.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Likes
    **/
    _count?: true | LikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikeMaxAggregateInputType
  }

  export type GetLikeAggregateType<T extends LikeAggregateArgs> = {
        [P in keyof T & keyof AggregateLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLike[P]>
      : GetScalarType<T[P], AggregateLike[P]>
  }




  export type LikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithAggregationInput | LikeOrderByWithAggregationInput[]
    by: LikeScalarFieldEnum[] | LikeScalarFieldEnum
    having?: LikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikeCountAggregateInputType | true
    _avg?: LikeAvgAggregateInputType
    _sum?: LikeSumAggregateInputType
    _min?: LikeMinAggregateInputType
    _max?: LikeMaxAggregateInputType
  }

  export type LikeGroupByOutputType = {
    like_id: number
    post_id: number
    user_id: number
    created_at: Date
    deleted_at: Date | null
    _count: LikeCountAggregateOutputType | null
    _avg: LikeAvgAggregateOutputType | null
    _sum: LikeSumAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  type GetLikeGroupByPayload<T extends LikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikeGroupByOutputType[P]>
            : GetScalarType<T[P], LikeGroupByOutputType[P]>
        }
      >
    >


  export type LikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    like_id?: boolean
    post_id?: boolean
    user_id?: boolean
    created_at?: boolean
    deleted_at?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    like_id?: boolean
    post_id?: boolean
    user_id?: boolean
    created_at?: boolean
    deleted_at?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    like_id?: boolean
    post_id?: boolean
    user_id?: boolean
    created_at?: boolean
    deleted_at?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectScalar = {
    like_id?: boolean
    post_id?: boolean
    user_id?: boolean
    created_at?: boolean
    deleted_at?: boolean
  }

  export type LikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"like_id" | "post_id" | "user_id" | "created_at" | "deleted_at", ExtArgs["result"]["like"]>
  export type LikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LikeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Like"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      like_id: number
      post_id: number
      user_id: number
      created_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["like"]>
    composites: {}
  }

  type LikeGetPayload<S extends boolean | null | undefined | LikeDefaultArgs> = $Result.GetResult<Prisma.$LikePayload, S>

  type LikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LikeCountAggregateInputType | true
    }

  export interface LikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Like'], meta: { name: 'Like' } }
    /**
     * Find zero or one Like that matches the filter.
     * @param {LikeFindUniqueArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikeFindUniqueArgs>(args: SelectSubset<T, LikeFindUniqueArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Like that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LikeFindUniqueOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikeFindUniqueOrThrowArgs>(args: SelectSubset<T, LikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Like that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikeFindFirstArgs>(args?: SelectSubset<T, LikeFindFirstArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Like that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikeFindFirstOrThrowArgs>(args?: SelectSubset<T, LikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Likes
     * const likes = await prisma.like.findMany()
     * 
     * // Get first 10 Likes
     * const likes = await prisma.like.findMany({ take: 10 })
     * 
     * // Only select the `like_id`
     * const likeWithLike_idOnly = await prisma.like.findMany({ select: { like_id: true } })
     * 
     */
    findMany<T extends LikeFindManyArgs>(args?: SelectSubset<T, LikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Like.
     * @param {LikeCreateArgs} args - Arguments to create a Like.
     * @example
     * // Create one Like
     * const Like = await prisma.like.create({
     *   data: {
     *     // ... data to create a Like
     *   }
     * })
     * 
     */
    create<T extends LikeCreateArgs>(args: SelectSubset<T, LikeCreateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Likes.
     * @param {LikeCreateManyArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikeCreateManyArgs>(args?: SelectSubset<T, LikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Likes and returns the data saved in the database.
     * @param {LikeCreateManyAndReturnArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Likes and only return the `like_id`
     * const likeWithLike_idOnly = await prisma.like.createManyAndReturn({
     *   select: { like_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LikeCreateManyAndReturnArgs>(args?: SelectSubset<T, LikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Like.
     * @param {LikeDeleteArgs} args - Arguments to delete one Like.
     * @example
     * // Delete one Like
     * const Like = await prisma.like.delete({
     *   where: {
     *     // ... filter to delete one Like
     *   }
     * })
     * 
     */
    delete<T extends LikeDeleteArgs>(args: SelectSubset<T, LikeDeleteArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Like.
     * @param {LikeUpdateArgs} args - Arguments to update one Like.
     * @example
     * // Update one Like
     * const like = await prisma.like.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikeUpdateArgs>(args: SelectSubset<T, LikeUpdateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Likes.
     * @param {LikeDeleteManyArgs} args - Arguments to filter Likes to delete.
     * @example
     * // Delete a few Likes
     * const { count } = await prisma.like.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikeDeleteManyArgs>(args?: SelectSubset<T, LikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikeUpdateManyArgs>(args: SelectSubset<T, LikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes and returns the data updated in the database.
     * @param {LikeUpdateManyAndReturnArgs} args - Arguments to update many Likes.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Likes and only return the `like_id`
     * const likeWithLike_idOnly = await prisma.like.updateManyAndReturn({
     *   select: { like_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LikeUpdateManyAndReturnArgs>(args: SelectSubset<T, LikeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Like.
     * @param {LikeUpsertArgs} args - Arguments to update or create a Like.
     * @example
     * // Update or create a Like
     * const like = await prisma.like.upsert({
     *   create: {
     *     // ... data to create a Like
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Like we want to update
     *   }
     * })
     */
    upsert<T extends LikeUpsertArgs>(args: SelectSubset<T, LikeUpsertArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCountArgs} args - Arguments to filter Likes to count.
     * @example
     * // Count the number of Likes
     * const count = await prisma.like.count({
     *   where: {
     *     // ... the filter for the Likes we want to count
     *   }
     * })
    **/
    count<T extends LikeCountArgs>(
      args?: Subset<T, LikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikeAggregateArgs>(args: Subset<T, LikeAggregateArgs>): Prisma.PrismaPromise<GetLikeAggregateType<T>>

    /**
     * Group by Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikeGroupByArgs['orderBy'] }
        : { orderBy?: LikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Like model
   */
  readonly fields: LikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Like.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Like model
   */
  interface LikeFieldRefs {
    readonly like_id: FieldRef<"Like", 'Int'>
    readonly post_id: FieldRef<"Like", 'Int'>
    readonly user_id: FieldRef<"Like", 'Int'>
    readonly created_at: FieldRef<"Like", 'DateTime'>
    readonly deleted_at: FieldRef<"Like", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Like findUnique
   */
  export type LikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findUniqueOrThrow
   */
  export type LikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findFirst
   */
  export type LikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findFirstOrThrow
   */
  export type LikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findMany
   */
  export type LikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like create
   */
  export type LikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to create a Like.
     */
    data: XOR<LikeCreateInput, LikeUncheckedCreateInput>
  }

  /**
   * Like createMany
   */
  export type LikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Like createManyAndReturn
   */
  export type LikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Like update
   */
  export type LikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to update a Like.
     */
    data: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
    /**
     * Choose, which Like to update.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like updateMany
   */
  export type LikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
    /**
     * Limit how many Likes to update.
     */
    limit?: number
  }

  /**
   * Like updateManyAndReturn
   */
  export type LikeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
    /**
     * Limit how many Likes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Like upsert
   */
  export type LikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The filter to search for the Like to update in case it exists.
     */
    where: LikeWhereUniqueInput
    /**
     * In case the Like found by the `where` argument doesn't exist, create a new Like with this data.
     */
    create: XOR<LikeCreateInput, LikeUncheckedCreateInput>
    /**
     * In case the Like was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
  }

  /**
   * Like delete
   */
  export type LikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter which Like to delete.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like deleteMany
   */
  export type LikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Likes to delete
     */
    where?: LikeWhereInput
    /**
     * Limit how many Likes to delete.
     */
    limit?: number
  }

  /**
   * Like without action
   */
  export type LikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
  }


  /**
   * Model EcoChallenge
   */

  export type AggregateEcoChallenge = {
    _count: EcoChallengeCountAggregateOutputType | null
    _avg: EcoChallengeAvgAggregateOutputType | null
    _sum: EcoChallengeSumAggregateOutputType | null
    _min: EcoChallengeMinAggregateOutputType | null
    _max: EcoChallengeMaxAggregateOutputType | null
  }

  export type EcoChallengeAvgAggregateOutputType = {
    challenge_id: number | null
    points_reward: number | null
    waste_kg: number | null
    created_by_admin_id: number | null
  }

  export type EcoChallengeSumAggregateOutputType = {
    challenge_id: number | null
    points_reward: number | null
    waste_kg: number | null
    created_by_admin_id: number | null
  }

  export type EcoChallengeMinAggregateOutputType = {
    challenge_id: number | null
    title: string | null
    description: string | null
    points_reward: number | null
    waste_kg: number | null
    is_active: boolean | null
    source: $Enums.ChallengeSource | null
    material_type: $Enums.MaterialType | null
    category: $Enums.ChallengeCategory | null
    created_by_admin_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    start_at: Date | null
    expires_at: Date | null
  }

  export type EcoChallengeMaxAggregateOutputType = {
    challenge_id: number | null
    title: string | null
    description: string | null
    points_reward: number | null
    waste_kg: number | null
    is_active: boolean | null
    source: $Enums.ChallengeSource | null
    material_type: $Enums.MaterialType | null
    category: $Enums.ChallengeCategory | null
    created_by_admin_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    start_at: Date | null
    expires_at: Date | null
  }

  export type EcoChallengeCountAggregateOutputType = {
    challenge_id: number
    title: number
    description: number
    points_reward: number
    waste_kg: number
    is_active: number
    source: number
    material_type: number
    category: number
    created_by_admin_id: number
    created_at: number
    updated_at: number
    deleted_at: number
    start_at: number
    expires_at: number
    _all: number
  }


  export type EcoChallengeAvgAggregateInputType = {
    challenge_id?: true
    points_reward?: true
    waste_kg?: true
    created_by_admin_id?: true
  }

  export type EcoChallengeSumAggregateInputType = {
    challenge_id?: true
    points_reward?: true
    waste_kg?: true
    created_by_admin_id?: true
  }

  export type EcoChallengeMinAggregateInputType = {
    challenge_id?: true
    title?: true
    description?: true
    points_reward?: true
    waste_kg?: true
    is_active?: true
    source?: true
    material_type?: true
    category?: true
    created_by_admin_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    start_at?: true
    expires_at?: true
  }

  export type EcoChallengeMaxAggregateInputType = {
    challenge_id?: true
    title?: true
    description?: true
    points_reward?: true
    waste_kg?: true
    is_active?: true
    source?: true
    material_type?: true
    category?: true
    created_by_admin_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    start_at?: true
    expires_at?: true
  }

  export type EcoChallengeCountAggregateInputType = {
    challenge_id?: true
    title?: true
    description?: true
    points_reward?: true
    waste_kg?: true
    is_active?: true
    source?: true
    material_type?: true
    category?: true
    created_by_admin_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    start_at?: true
    expires_at?: true
    _all?: true
  }

  export type EcoChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EcoChallenge to aggregate.
     */
    where?: EcoChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EcoChallenges to fetch.
     */
    orderBy?: EcoChallengeOrderByWithRelationInput | EcoChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EcoChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EcoChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EcoChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EcoChallenges
    **/
    _count?: true | EcoChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EcoChallengeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EcoChallengeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EcoChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EcoChallengeMaxAggregateInputType
  }

  export type GetEcoChallengeAggregateType<T extends EcoChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateEcoChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEcoChallenge[P]>
      : GetScalarType<T[P], AggregateEcoChallenge[P]>
  }




  export type EcoChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EcoChallengeWhereInput
    orderBy?: EcoChallengeOrderByWithAggregationInput | EcoChallengeOrderByWithAggregationInput[]
    by: EcoChallengeScalarFieldEnum[] | EcoChallengeScalarFieldEnum
    having?: EcoChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EcoChallengeCountAggregateInputType | true
    _avg?: EcoChallengeAvgAggregateInputType
    _sum?: EcoChallengeSumAggregateInputType
    _min?: EcoChallengeMinAggregateInputType
    _max?: EcoChallengeMaxAggregateInputType
  }

  export type EcoChallengeGroupByOutputType = {
    challenge_id: number
    title: string
    description: string
    points_reward: number
    waste_kg: number
    is_active: boolean
    source: $Enums.ChallengeSource
    material_type: $Enums.MaterialType
    category: $Enums.ChallengeCategory
    created_by_admin_id: number | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    start_at: Date
    expires_at: Date | null
    _count: EcoChallengeCountAggregateOutputType | null
    _avg: EcoChallengeAvgAggregateOutputType | null
    _sum: EcoChallengeSumAggregateOutputType | null
    _min: EcoChallengeMinAggregateOutputType | null
    _max: EcoChallengeMaxAggregateOutputType | null
  }

  type GetEcoChallengeGroupByPayload<T extends EcoChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EcoChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EcoChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EcoChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], EcoChallengeGroupByOutputType[P]>
        }
      >
    >


  export type EcoChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    challenge_id?: boolean
    title?: boolean
    description?: boolean
    points_reward?: boolean
    waste_kg?: boolean
    is_active?: boolean
    source?: boolean
    material_type?: boolean
    category?: boolean
    created_by_admin_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    start_at?: boolean
    expires_at?: boolean
    created_by_admin?: boolean | EcoChallenge$created_by_adminArgs<ExtArgs>
    participants?: boolean | EcoChallenge$participantsArgs<ExtArgs>
    _count?: boolean | EcoChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ecoChallenge"]>

  export type EcoChallengeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    challenge_id?: boolean
    title?: boolean
    description?: boolean
    points_reward?: boolean
    waste_kg?: boolean
    is_active?: boolean
    source?: boolean
    material_type?: boolean
    category?: boolean
    created_by_admin_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    start_at?: boolean
    expires_at?: boolean
    created_by_admin?: boolean | EcoChallenge$created_by_adminArgs<ExtArgs>
  }, ExtArgs["result"]["ecoChallenge"]>

  export type EcoChallengeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    challenge_id?: boolean
    title?: boolean
    description?: boolean
    points_reward?: boolean
    waste_kg?: boolean
    is_active?: boolean
    source?: boolean
    material_type?: boolean
    category?: boolean
    created_by_admin_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    start_at?: boolean
    expires_at?: boolean
    created_by_admin?: boolean | EcoChallenge$created_by_adminArgs<ExtArgs>
  }, ExtArgs["result"]["ecoChallenge"]>

  export type EcoChallengeSelectScalar = {
    challenge_id?: boolean
    title?: boolean
    description?: boolean
    points_reward?: boolean
    waste_kg?: boolean
    is_active?: boolean
    source?: boolean
    material_type?: boolean
    category?: boolean
    created_by_admin_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    start_at?: boolean
    expires_at?: boolean
  }

  export type EcoChallengeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"challenge_id" | "title" | "description" | "points_reward" | "waste_kg" | "is_active" | "source" | "material_type" | "category" | "created_by_admin_id" | "created_at" | "updated_at" | "deleted_at" | "start_at" | "expires_at", ExtArgs["result"]["ecoChallenge"]>
  export type EcoChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    created_by_admin?: boolean | EcoChallenge$created_by_adminArgs<ExtArgs>
    participants?: boolean | EcoChallenge$participantsArgs<ExtArgs>
    _count?: boolean | EcoChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EcoChallengeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    created_by_admin?: boolean | EcoChallenge$created_by_adminArgs<ExtArgs>
  }
  export type EcoChallengeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    created_by_admin?: boolean | EcoChallenge$created_by_adminArgs<ExtArgs>
  }

  export type $EcoChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EcoChallenge"
    objects: {
      created_by_admin: Prisma.$UserPayload<ExtArgs> | null
      participants: Prisma.$UserChallengePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      challenge_id: number
      title: string
      description: string
      points_reward: number
      waste_kg: number
      is_active: boolean
      source: $Enums.ChallengeSource
      material_type: $Enums.MaterialType
      category: $Enums.ChallengeCategory
      created_by_admin_id: number | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
      start_at: Date
      expires_at: Date | null
    }, ExtArgs["result"]["ecoChallenge"]>
    composites: {}
  }

  type EcoChallengeGetPayload<S extends boolean | null | undefined | EcoChallengeDefaultArgs> = $Result.GetResult<Prisma.$EcoChallengePayload, S>

  type EcoChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EcoChallengeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EcoChallengeCountAggregateInputType | true
    }

  export interface EcoChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EcoChallenge'], meta: { name: 'EcoChallenge' } }
    /**
     * Find zero or one EcoChallenge that matches the filter.
     * @param {EcoChallengeFindUniqueArgs} args - Arguments to find a EcoChallenge
     * @example
     * // Get one EcoChallenge
     * const ecoChallenge = await prisma.ecoChallenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EcoChallengeFindUniqueArgs>(args: SelectSubset<T, EcoChallengeFindUniqueArgs<ExtArgs>>): Prisma__EcoChallengeClient<$Result.GetResult<Prisma.$EcoChallengePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EcoChallenge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EcoChallengeFindUniqueOrThrowArgs} args - Arguments to find a EcoChallenge
     * @example
     * // Get one EcoChallenge
     * const ecoChallenge = await prisma.ecoChallenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EcoChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, EcoChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EcoChallengeClient<$Result.GetResult<Prisma.$EcoChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EcoChallenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcoChallengeFindFirstArgs} args - Arguments to find a EcoChallenge
     * @example
     * // Get one EcoChallenge
     * const ecoChallenge = await prisma.ecoChallenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EcoChallengeFindFirstArgs>(args?: SelectSubset<T, EcoChallengeFindFirstArgs<ExtArgs>>): Prisma__EcoChallengeClient<$Result.GetResult<Prisma.$EcoChallengePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EcoChallenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcoChallengeFindFirstOrThrowArgs} args - Arguments to find a EcoChallenge
     * @example
     * // Get one EcoChallenge
     * const ecoChallenge = await prisma.ecoChallenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EcoChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, EcoChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EcoChallengeClient<$Result.GetResult<Prisma.$EcoChallengePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EcoChallenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcoChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EcoChallenges
     * const ecoChallenges = await prisma.ecoChallenge.findMany()
     * 
     * // Get first 10 EcoChallenges
     * const ecoChallenges = await prisma.ecoChallenge.findMany({ take: 10 })
     * 
     * // Only select the `challenge_id`
     * const ecoChallengeWithChallenge_idOnly = await prisma.ecoChallenge.findMany({ select: { challenge_id: true } })
     * 
     */
    findMany<T extends EcoChallengeFindManyArgs>(args?: SelectSubset<T, EcoChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcoChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EcoChallenge.
     * @param {EcoChallengeCreateArgs} args - Arguments to create a EcoChallenge.
     * @example
     * // Create one EcoChallenge
     * const EcoChallenge = await prisma.ecoChallenge.create({
     *   data: {
     *     // ... data to create a EcoChallenge
     *   }
     * })
     * 
     */
    create<T extends EcoChallengeCreateArgs>(args: SelectSubset<T, EcoChallengeCreateArgs<ExtArgs>>): Prisma__EcoChallengeClient<$Result.GetResult<Prisma.$EcoChallengePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EcoChallenges.
     * @param {EcoChallengeCreateManyArgs} args - Arguments to create many EcoChallenges.
     * @example
     * // Create many EcoChallenges
     * const ecoChallenge = await prisma.ecoChallenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EcoChallengeCreateManyArgs>(args?: SelectSubset<T, EcoChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EcoChallenges and returns the data saved in the database.
     * @param {EcoChallengeCreateManyAndReturnArgs} args - Arguments to create many EcoChallenges.
     * @example
     * // Create many EcoChallenges
     * const ecoChallenge = await prisma.ecoChallenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EcoChallenges and only return the `challenge_id`
     * const ecoChallengeWithChallenge_idOnly = await prisma.ecoChallenge.createManyAndReturn({
     *   select: { challenge_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EcoChallengeCreateManyAndReturnArgs>(args?: SelectSubset<T, EcoChallengeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcoChallengePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EcoChallenge.
     * @param {EcoChallengeDeleteArgs} args - Arguments to delete one EcoChallenge.
     * @example
     * // Delete one EcoChallenge
     * const EcoChallenge = await prisma.ecoChallenge.delete({
     *   where: {
     *     // ... filter to delete one EcoChallenge
     *   }
     * })
     * 
     */
    delete<T extends EcoChallengeDeleteArgs>(args: SelectSubset<T, EcoChallengeDeleteArgs<ExtArgs>>): Prisma__EcoChallengeClient<$Result.GetResult<Prisma.$EcoChallengePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EcoChallenge.
     * @param {EcoChallengeUpdateArgs} args - Arguments to update one EcoChallenge.
     * @example
     * // Update one EcoChallenge
     * const ecoChallenge = await prisma.ecoChallenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EcoChallengeUpdateArgs>(args: SelectSubset<T, EcoChallengeUpdateArgs<ExtArgs>>): Prisma__EcoChallengeClient<$Result.GetResult<Prisma.$EcoChallengePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EcoChallenges.
     * @param {EcoChallengeDeleteManyArgs} args - Arguments to filter EcoChallenges to delete.
     * @example
     * // Delete a few EcoChallenges
     * const { count } = await prisma.ecoChallenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EcoChallengeDeleteManyArgs>(args?: SelectSubset<T, EcoChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EcoChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcoChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EcoChallenges
     * const ecoChallenge = await prisma.ecoChallenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EcoChallengeUpdateManyArgs>(args: SelectSubset<T, EcoChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EcoChallenges and returns the data updated in the database.
     * @param {EcoChallengeUpdateManyAndReturnArgs} args - Arguments to update many EcoChallenges.
     * @example
     * // Update many EcoChallenges
     * const ecoChallenge = await prisma.ecoChallenge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EcoChallenges and only return the `challenge_id`
     * const ecoChallengeWithChallenge_idOnly = await prisma.ecoChallenge.updateManyAndReturn({
     *   select: { challenge_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EcoChallengeUpdateManyAndReturnArgs>(args: SelectSubset<T, EcoChallengeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcoChallengePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EcoChallenge.
     * @param {EcoChallengeUpsertArgs} args - Arguments to update or create a EcoChallenge.
     * @example
     * // Update or create a EcoChallenge
     * const ecoChallenge = await prisma.ecoChallenge.upsert({
     *   create: {
     *     // ... data to create a EcoChallenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EcoChallenge we want to update
     *   }
     * })
     */
    upsert<T extends EcoChallengeUpsertArgs>(args: SelectSubset<T, EcoChallengeUpsertArgs<ExtArgs>>): Prisma__EcoChallengeClient<$Result.GetResult<Prisma.$EcoChallengePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EcoChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcoChallengeCountArgs} args - Arguments to filter EcoChallenges to count.
     * @example
     * // Count the number of EcoChallenges
     * const count = await prisma.ecoChallenge.count({
     *   where: {
     *     // ... the filter for the EcoChallenges we want to count
     *   }
     * })
    **/
    count<T extends EcoChallengeCountArgs>(
      args?: Subset<T, EcoChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EcoChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EcoChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcoChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EcoChallengeAggregateArgs>(args: Subset<T, EcoChallengeAggregateArgs>): Prisma.PrismaPromise<GetEcoChallengeAggregateType<T>>

    /**
     * Group by EcoChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcoChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EcoChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EcoChallengeGroupByArgs['orderBy'] }
        : { orderBy?: EcoChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EcoChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEcoChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EcoChallenge model
   */
  readonly fields: EcoChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EcoChallenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EcoChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    created_by_admin<T extends EcoChallenge$created_by_adminArgs<ExtArgs> = {}>(args?: Subset<T, EcoChallenge$created_by_adminArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    participants<T extends EcoChallenge$participantsArgs<ExtArgs> = {}>(args?: Subset<T, EcoChallenge$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EcoChallenge model
   */
  interface EcoChallengeFieldRefs {
    readonly challenge_id: FieldRef<"EcoChallenge", 'Int'>
    readonly title: FieldRef<"EcoChallenge", 'String'>
    readonly description: FieldRef<"EcoChallenge", 'String'>
    readonly points_reward: FieldRef<"EcoChallenge", 'Int'>
    readonly waste_kg: FieldRef<"EcoChallenge", 'Float'>
    readonly is_active: FieldRef<"EcoChallenge", 'Boolean'>
    readonly source: FieldRef<"EcoChallenge", 'ChallengeSource'>
    readonly material_type: FieldRef<"EcoChallenge", 'MaterialType'>
    readonly category: FieldRef<"EcoChallenge", 'ChallengeCategory'>
    readonly created_by_admin_id: FieldRef<"EcoChallenge", 'Int'>
    readonly created_at: FieldRef<"EcoChallenge", 'DateTime'>
    readonly updated_at: FieldRef<"EcoChallenge", 'DateTime'>
    readonly deleted_at: FieldRef<"EcoChallenge", 'DateTime'>
    readonly start_at: FieldRef<"EcoChallenge", 'DateTime'>
    readonly expires_at: FieldRef<"EcoChallenge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EcoChallenge findUnique
   */
  export type EcoChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoChallenge
     */
    select?: EcoChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcoChallenge
     */
    omit?: EcoChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoChallengeInclude<ExtArgs> | null
    /**
     * Filter, which EcoChallenge to fetch.
     */
    where: EcoChallengeWhereUniqueInput
  }

  /**
   * EcoChallenge findUniqueOrThrow
   */
  export type EcoChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoChallenge
     */
    select?: EcoChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcoChallenge
     */
    omit?: EcoChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoChallengeInclude<ExtArgs> | null
    /**
     * Filter, which EcoChallenge to fetch.
     */
    where: EcoChallengeWhereUniqueInput
  }

  /**
   * EcoChallenge findFirst
   */
  export type EcoChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoChallenge
     */
    select?: EcoChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcoChallenge
     */
    omit?: EcoChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoChallengeInclude<ExtArgs> | null
    /**
     * Filter, which EcoChallenge to fetch.
     */
    where?: EcoChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EcoChallenges to fetch.
     */
    orderBy?: EcoChallengeOrderByWithRelationInput | EcoChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EcoChallenges.
     */
    cursor?: EcoChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EcoChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EcoChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EcoChallenges.
     */
    distinct?: EcoChallengeScalarFieldEnum | EcoChallengeScalarFieldEnum[]
  }

  /**
   * EcoChallenge findFirstOrThrow
   */
  export type EcoChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoChallenge
     */
    select?: EcoChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcoChallenge
     */
    omit?: EcoChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoChallengeInclude<ExtArgs> | null
    /**
     * Filter, which EcoChallenge to fetch.
     */
    where?: EcoChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EcoChallenges to fetch.
     */
    orderBy?: EcoChallengeOrderByWithRelationInput | EcoChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EcoChallenges.
     */
    cursor?: EcoChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EcoChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EcoChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EcoChallenges.
     */
    distinct?: EcoChallengeScalarFieldEnum | EcoChallengeScalarFieldEnum[]
  }

  /**
   * EcoChallenge findMany
   */
  export type EcoChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoChallenge
     */
    select?: EcoChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcoChallenge
     */
    omit?: EcoChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoChallengeInclude<ExtArgs> | null
    /**
     * Filter, which EcoChallenges to fetch.
     */
    where?: EcoChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EcoChallenges to fetch.
     */
    orderBy?: EcoChallengeOrderByWithRelationInput | EcoChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EcoChallenges.
     */
    cursor?: EcoChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EcoChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EcoChallenges.
     */
    skip?: number
    distinct?: EcoChallengeScalarFieldEnum | EcoChallengeScalarFieldEnum[]
  }

  /**
   * EcoChallenge create
   */
  export type EcoChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoChallenge
     */
    select?: EcoChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcoChallenge
     */
    omit?: EcoChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a EcoChallenge.
     */
    data: XOR<EcoChallengeCreateInput, EcoChallengeUncheckedCreateInput>
  }

  /**
   * EcoChallenge createMany
   */
  export type EcoChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EcoChallenges.
     */
    data: EcoChallengeCreateManyInput | EcoChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EcoChallenge createManyAndReturn
   */
  export type EcoChallengeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoChallenge
     */
    select?: EcoChallengeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EcoChallenge
     */
    omit?: EcoChallengeOmit<ExtArgs> | null
    /**
     * The data used to create many EcoChallenges.
     */
    data: EcoChallengeCreateManyInput | EcoChallengeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoChallengeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EcoChallenge update
   */
  export type EcoChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoChallenge
     */
    select?: EcoChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcoChallenge
     */
    omit?: EcoChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a EcoChallenge.
     */
    data: XOR<EcoChallengeUpdateInput, EcoChallengeUncheckedUpdateInput>
    /**
     * Choose, which EcoChallenge to update.
     */
    where: EcoChallengeWhereUniqueInput
  }

  /**
   * EcoChallenge updateMany
   */
  export type EcoChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EcoChallenges.
     */
    data: XOR<EcoChallengeUpdateManyMutationInput, EcoChallengeUncheckedUpdateManyInput>
    /**
     * Filter which EcoChallenges to update
     */
    where?: EcoChallengeWhereInput
    /**
     * Limit how many EcoChallenges to update.
     */
    limit?: number
  }

  /**
   * EcoChallenge updateManyAndReturn
   */
  export type EcoChallengeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoChallenge
     */
    select?: EcoChallengeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EcoChallenge
     */
    omit?: EcoChallengeOmit<ExtArgs> | null
    /**
     * The data used to update EcoChallenges.
     */
    data: XOR<EcoChallengeUpdateManyMutationInput, EcoChallengeUncheckedUpdateManyInput>
    /**
     * Filter which EcoChallenges to update
     */
    where?: EcoChallengeWhereInput
    /**
     * Limit how many EcoChallenges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoChallengeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EcoChallenge upsert
   */
  export type EcoChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoChallenge
     */
    select?: EcoChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcoChallenge
     */
    omit?: EcoChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the EcoChallenge to update in case it exists.
     */
    where: EcoChallengeWhereUniqueInput
    /**
     * In case the EcoChallenge found by the `where` argument doesn't exist, create a new EcoChallenge with this data.
     */
    create: XOR<EcoChallengeCreateInput, EcoChallengeUncheckedCreateInput>
    /**
     * In case the EcoChallenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EcoChallengeUpdateInput, EcoChallengeUncheckedUpdateInput>
  }

  /**
   * EcoChallenge delete
   */
  export type EcoChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoChallenge
     */
    select?: EcoChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcoChallenge
     */
    omit?: EcoChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoChallengeInclude<ExtArgs> | null
    /**
     * Filter which EcoChallenge to delete.
     */
    where: EcoChallengeWhereUniqueInput
  }

  /**
   * EcoChallenge deleteMany
   */
  export type EcoChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EcoChallenges to delete
     */
    where?: EcoChallengeWhereInput
    /**
     * Limit how many EcoChallenges to delete.
     */
    limit?: number
  }

  /**
   * EcoChallenge.created_by_admin
   */
  export type EcoChallenge$created_by_adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * EcoChallenge.participants
   */
  export type EcoChallenge$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    where?: UserChallengeWhereInput
    orderBy?: UserChallengeOrderByWithRelationInput | UserChallengeOrderByWithRelationInput[]
    cursor?: UserChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserChallengeScalarFieldEnum | UserChallengeScalarFieldEnum[]
  }

  /**
   * EcoChallenge without action
   */
  export type EcoChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoChallenge
     */
    select?: EcoChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcoChallenge
     */
    omit?: EcoChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoChallengeInclude<ExtArgs> | null
  }


  /**
   * Model UserChallenge
   */

  export type AggregateUserChallenge = {
    _count: UserChallengeCountAggregateOutputType | null
    _avg: UserChallengeAvgAggregateOutputType | null
    _sum: UserChallengeSumAggregateOutputType | null
    _min: UserChallengeMinAggregateOutputType | null
    _max: UserChallengeMaxAggregateOutputType | null
  }

  export type UserChallengeAvgAggregateOutputType = {
    user_challenge_id: number | null
    user_id: number | null
    challenge_id: number | null
    verified_by_admin_id: number | null
    ai_confidence_score: number | null
    points_awarded: number | null
    waste_kg_saved: number | null
  }

  export type UserChallengeSumAggregateOutputType = {
    user_challenge_id: number | null
    user_id: number | null
    challenge_id: number | null
    verified_by_admin_id: number | null
    ai_confidence_score: number | null
    points_awarded: number | null
    waste_kg_saved: number | null
  }

  export type UserChallengeMinAggregateOutputType = {
    user_challenge_id: number | null
    user_id: number | null
    challenge_id: number | null
    status: $Enums.ChallengeStatus | null
    proof_url: string | null
    completed_at: Date | null
    verified_at: Date | null
    verified_by_admin_id: number | null
    verification_type: $Enums.VerificationType | null
    ai_confidence_score: number | null
    points_awarded: number | null
    waste_kg_saved: number | null
    admin_notes: string | null
    created_at: Date | null
    deleted_at: Date | null
    skipped_at: Date | null
  }

  export type UserChallengeMaxAggregateOutputType = {
    user_challenge_id: number | null
    user_id: number | null
    challenge_id: number | null
    status: $Enums.ChallengeStatus | null
    proof_url: string | null
    completed_at: Date | null
    verified_at: Date | null
    verified_by_admin_id: number | null
    verification_type: $Enums.VerificationType | null
    ai_confidence_score: number | null
    points_awarded: number | null
    waste_kg_saved: number | null
    admin_notes: string | null
    created_at: Date | null
    deleted_at: Date | null
    skipped_at: Date | null
  }

  export type UserChallengeCountAggregateOutputType = {
    user_challenge_id: number
    user_id: number
    challenge_id: number
    status: number
    proof_url: number
    completed_at: number
    verified_at: number
    verified_by_admin_id: number
    verification_type: number
    ai_confidence_score: number
    points_awarded: number
    waste_kg_saved: number
    admin_notes: number
    created_at: number
    deleted_at: number
    skipped_at: number
    _all: number
  }


  export type UserChallengeAvgAggregateInputType = {
    user_challenge_id?: true
    user_id?: true
    challenge_id?: true
    verified_by_admin_id?: true
    ai_confidence_score?: true
    points_awarded?: true
    waste_kg_saved?: true
  }

  export type UserChallengeSumAggregateInputType = {
    user_challenge_id?: true
    user_id?: true
    challenge_id?: true
    verified_by_admin_id?: true
    ai_confidence_score?: true
    points_awarded?: true
    waste_kg_saved?: true
  }

  export type UserChallengeMinAggregateInputType = {
    user_challenge_id?: true
    user_id?: true
    challenge_id?: true
    status?: true
    proof_url?: true
    completed_at?: true
    verified_at?: true
    verified_by_admin_id?: true
    verification_type?: true
    ai_confidence_score?: true
    points_awarded?: true
    waste_kg_saved?: true
    admin_notes?: true
    created_at?: true
    deleted_at?: true
    skipped_at?: true
  }

  export type UserChallengeMaxAggregateInputType = {
    user_challenge_id?: true
    user_id?: true
    challenge_id?: true
    status?: true
    proof_url?: true
    completed_at?: true
    verified_at?: true
    verified_by_admin_id?: true
    verification_type?: true
    ai_confidence_score?: true
    points_awarded?: true
    waste_kg_saved?: true
    admin_notes?: true
    created_at?: true
    deleted_at?: true
    skipped_at?: true
  }

  export type UserChallengeCountAggregateInputType = {
    user_challenge_id?: true
    user_id?: true
    challenge_id?: true
    status?: true
    proof_url?: true
    completed_at?: true
    verified_at?: true
    verified_by_admin_id?: true
    verification_type?: true
    ai_confidence_score?: true
    points_awarded?: true
    waste_kg_saved?: true
    admin_notes?: true
    created_at?: true
    deleted_at?: true
    skipped_at?: true
    _all?: true
  }

  export type UserChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserChallenge to aggregate.
     */
    where?: UserChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserChallenges to fetch.
     */
    orderBy?: UserChallengeOrderByWithRelationInput | UserChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserChallenges
    **/
    _count?: true | UserChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserChallengeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserChallengeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserChallengeMaxAggregateInputType
  }

  export type GetUserChallengeAggregateType<T extends UserChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserChallenge[P]>
      : GetScalarType<T[P], AggregateUserChallenge[P]>
  }




  export type UserChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserChallengeWhereInput
    orderBy?: UserChallengeOrderByWithAggregationInput | UserChallengeOrderByWithAggregationInput[]
    by: UserChallengeScalarFieldEnum[] | UserChallengeScalarFieldEnum
    having?: UserChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserChallengeCountAggregateInputType | true
    _avg?: UserChallengeAvgAggregateInputType
    _sum?: UserChallengeSumAggregateInputType
    _min?: UserChallengeMinAggregateInputType
    _max?: UserChallengeMaxAggregateInputType
  }

  export type UserChallengeGroupByOutputType = {
    user_challenge_id: number
    user_id: number
    challenge_id: number
    status: $Enums.ChallengeStatus
    proof_url: string | null
    completed_at: Date | null
    verified_at: Date | null
    verified_by_admin_id: number | null
    verification_type: $Enums.VerificationType | null
    ai_confidence_score: number | null
    points_awarded: number
    waste_kg_saved: number
    admin_notes: string | null
    created_at: Date
    deleted_at: Date | null
    skipped_at: Date | null
    _count: UserChallengeCountAggregateOutputType | null
    _avg: UserChallengeAvgAggregateOutputType | null
    _sum: UserChallengeSumAggregateOutputType | null
    _min: UserChallengeMinAggregateOutputType | null
    _max: UserChallengeMaxAggregateOutputType | null
  }

  type GetUserChallengeGroupByPayload<T extends UserChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], UserChallengeGroupByOutputType[P]>
        }
      >
    >


  export type UserChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_challenge_id?: boolean
    user_id?: boolean
    challenge_id?: boolean
    status?: boolean
    proof_url?: boolean
    completed_at?: boolean
    verified_at?: boolean
    verified_by_admin_id?: boolean
    verification_type?: boolean
    ai_confidence_score?: boolean
    points_awarded?: boolean
    waste_kg_saved?: boolean
    admin_notes?: boolean
    created_at?: boolean
    deleted_at?: boolean
    skipped_at?: boolean
    challenge?: boolean | EcoChallengeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    verified_by?: boolean | UserChallenge$verified_byArgs<ExtArgs>
  }, ExtArgs["result"]["userChallenge"]>

  export type UserChallengeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_challenge_id?: boolean
    user_id?: boolean
    challenge_id?: boolean
    status?: boolean
    proof_url?: boolean
    completed_at?: boolean
    verified_at?: boolean
    verified_by_admin_id?: boolean
    verification_type?: boolean
    ai_confidence_score?: boolean
    points_awarded?: boolean
    waste_kg_saved?: boolean
    admin_notes?: boolean
    created_at?: boolean
    deleted_at?: boolean
    skipped_at?: boolean
    challenge?: boolean | EcoChallengeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    verified_by?: boolean | UserChallenge$verified_byArgs<ExtArgs>
  }, ExtArgs["result"]["userChallenge"]>

  export type UserChallengeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_challenge_id?: boolean
    user_id?: boolean
    challenge_id?: boolean
    status?: boolean
    proof_url?: boolean
    completed_at?: boolean
    verified_at?: boolean
    verified_by_admin_id?: boolean
    verification_type?: boolean
    ai_confidence_score?: boolean
    points_awarded?: boolean
    waste_kg_saved?: boolean
    admin_notes?: boolean
    created_at?: boolean
    deleted_at?: boolean
    skipped_at?: boolean
    challenge?: boolean | EcoChallengeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    verified_by?: boolean | UserChallenge$verified_byArgs<ExtArgs>
  }, ExtArgs["result"]["userChallenge"]>

  export type UserChallengeSelectScalar = {
    user_challenge_id?: boolean
    user_id?: boolean
    challenge_id?: boolean
    status?: boolean
    proof_url?: boolean
    completed_at?: boolean
    verified_at?: boolean
    verified_by_admin_id?: boolean
    verification_type?: boolean
    ai_confidence_score?: boolean
    points_awarded?: boolean
    waste_kg_saved?: boolean
    admin_notes?: boolean
    created_at?: boolean
    deleted_at?: boolean
    skipped_at?: boolean
  }

  export type UserChallengeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_challenge_id" | "user_id" | "challenge_id" | "status" | "proof_url" | "completed_at" | "verified_at" | "verified_by_admin_id" | "verification_type" | "ai_confidence_score" | "points_awarded" | "waste_kg_saved" | "admin_notes" | "created_at" | "deleted_at" | "skipped_at", ExtArgs["result"]["userChallenge"]>
  export type UserChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | EcoChallengeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    verified_by?: boolean | UserChallenge$verified_byArgs<ExtArgs>
  }
  export type UserChallengeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | EcoChallengeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    verified_by?: boolean | UserChallenge$verified_byArgs<ExtArgs>
  }
  export type UserChallengeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | EcoChallengeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    verified_by?: boolean | UserChallenge$verified_byArgs<ExtArgs>
  }

  export type $UserChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserChallenge"
    objects: {
      challenge: Prisma.$EcoChallengePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      verified_by: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      user_challenge_id: number
      user_id: number
      challenge_id: number
      status: $Enums.ChallengeStatus
      proof_url: string | null
      completed_at: Date | null
      verified_at: Date | null
      verified_by_admin_id: number | null
      verification_type: $Enums.VerificationType | null
      ai_confidence_score: number | null
      points_awarded: number
      waste_kg_saved: number
      admin_notes: string | null
      created_at: Date
      deleted_at: Date | null
      skipped_at: Date | null
    }, ExtArgs["result"]["userChallenge"]>
    composites: {}
  }

  type UserChallengeGetPayload<S extends boolean | null | undefined | UserChallengeDefaultArgs> = $Result.GetResult<Prisma.$UserChallengePayload, S>

  type UserChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserChallengeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserChallengeCountAggregateInputType | true
    }

  export interface UserChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserChallenge'], meta: { name: 'UserChallenge' } }
    /**
     * Find zero or one UserChallenge that matches the filter.
     * @param {UserChallengeFindUniqueArgs} args - Arguments to find a UserChallenge
     * @example
     * // Get one UserChallenge
     * const userChallenge = await prisma.userChallenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserChallengeFindUniqueArgs>(args: SelectSubset<T, UserChallengeFindUniqueArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserChallenge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserChallengeFindUniqueOrThrowArgs} args - Arguments to find a UserChallenge
     * @example
     * // Get one UserChallenge
     * const userChallenge = await prisma.userChallenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserChallenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeFindFirstArgs} args - Arguments to find a UserChallenge
     * @example
     * // Get one UserChallenge
     * const userChallenge = await prisma.userChallenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserChallengeFindFirstArgs>(args?: SelectSubset<T, UserChallengeFindFirstArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserChallenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeFindFirstOrThrowArgs} args - Arguments to find a UserChallenge
     * @example
     * // Get one UserChallenge
     * const userChallenge = await prisma.userChallenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserChallenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserChallenges
     * const userChallenges = await prisma.userChallenge.findMany()
     * 
     * // Get first 10 UserChallenges
     * const userChallenges = await prisma.userChallenge.findMany({ take: 10 })
     * 
     * // Only select the `user_challenge_id`
     * const userChallengeWithUser_challenge_idOnly = await prisma.userChallenge.findMany({ select: { user_challenge_id: true } })
     * 
     */
    findMany<T extends UserChallengeFindManyArgs>(args?: SelectSubset<T, UserChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserChallenge.
     * @param {UserChallengeCreateArgs} args - Arguments to create a UserChallenge.
     * @example
     * // Create one UserChallenge
     * const UserChallenge = await prisma.userChallenge.create({
     *   data: {
     *     // ... data to create a UserChallenge
     *   }
     * })
     * 
     */
    create<T extends UserChallengeCreateArgs>(args: SelectSubset<T, UserChallengeCreateArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserChallenges.
     * @param {UserChallengeCreateManyArgs} args - Arguments to create many UserChallenges.
     * @example
     * // Create many UserChallenges
     * const userChallenge = await prisma.userChallenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserChallengeCreateManyArgs>(args?: SelectSubset<T, UserChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserChallenges and returns the data saved in the database.
     * @param {UserChallengeCreateManyAndReturnArgs} args - Arguments to create many UserChallenges.
     * @example
     * // Create many UserChallenges
     * const userChallenge = await prisma.userChallenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserChallenges and only return the `user_challenge_id`
     * const userChallengeWithUser_challenge_idOnly = await prisma.userChallenge.createManyAndReturn({
     *   select: { user_challenge_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserChallengeCreateManyAndReturnArgs>(args?: SelectSubset<T, UserChallengeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserChallenge.
     * @param {UserChallengeDeleteArgs} args - Arguments to delete one UserChallenge.
     * @example
     * // Delete one UserChallenge
     * const UserChallenge = await prisma.userChallenge.delete({
     *   where: {
     *     // ... filter to delete one UserChallenge
     *   }
     * })
     * 
     */
    delete<T extends UserChallengeDeleteArgs>(args: SelectSubset<T, UserChallengeDeleteArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserChallenge.
     * @param {UserChallengeUpdateArgs} args - Arguments to update one UserChallenge.
     * @example
     * // Update one UserChallenge
     * const userChallenge = await prisma.userChallenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserChallengeUpdateArgs>(args: SelectSubset<T, UserChallengeUpdateArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserChallenges.
     * @param {UserChallengeDeleteManyArgs} args - Arguments to filter UserChallenges to delete.
     * @example
     * // Delete a few UserChallenges
     * const { count } = await prisma.userChallenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserChallengeDeleteManyArgs>(args?: SelectSubset<T, UserChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserChallenges
     * const userChallenge = await prisma.userChallenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserChallengeUpdateManyArgs>(args: SelectSubset<T, UserChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserChallenges and returns the data updated in the database.
     * @param {UserChallengeUpdateManyAndReturnArgs} args - Arguments to update many UserChallenges.
     * @example
     * // Update many UserChallenges
     * const userChallenge = await prisma.userChallenge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserChallenges and only return the `user_challenge_id`
     * const userChallengeWithUser_challenge_idOnly = await prisma.userChallenge.updateManyAndReturn({
     *   select: { user_challenge_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserChallengeUpdateManyAndReturnArgs>(args: SelectSubset<T, UserChallengeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserChallenge.
     * @param {UserChallengeUpsertArgs} args - Arguments to update or create a UserChallenge.
     * @example
     * // Update or create a UserChallenge
     * const userChallenge = await prisma.userChallenge.upsert({
     *   create: {
     *     // ... data to create a UserChallenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserChallenge we want to update
     *   }
     * })
     */
    upsert<T extends UserChallengeUpsertArgs>(args: SelectSubset<T, UserChallengeUpsertArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeCountArgs} args - Arguments to filter UserChallenges to count.
     * @example
     * // Count the number of UserChallenges
     * const count = await prisma.userChallenge.count({
     *   where: {
     *     // ... the filter for the UserChallenges we want to count
     *   }
     * })
    **/
    count<T extends UserChallengeCountArgs>(
      args?: Subset<T, UserChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserChallengeAggregateArgs>(args: Subset<T, UserChallengeAggregateArgs>): Prisma.PrismaPromise<GetUserChallengeAggregateType<T>>

    /**
     * Group by UserChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserChallengeGroupByArgs['orderBy'] }
        : { orderBy?: UserChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserChallenge model
   */
  readonly fields: UserChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserChallenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends EcoChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EcoChallengeDefaultArgs<ExtArgs>>): Prisma__EcoChallengeClient<$Result.GetResult<Prisma.$EcoChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    verified_by<T extends UserChallenge$verified_byArgs<ExtArgs> = {}>(args?: Subset<T, UserChallenge$verified_byArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserChallenge model
   */
  interface UserChallengeFieldRefs {
    readonly user_challenge_id: FieldRef<"UserChallenge", 'Int'>
    readonly user_id: FieldRef<"UserChallenge", 'Int'>
    readonly challenge_id: FieldRef<"UserChallenge", 'Int'>
    readonly status: FieldRef<"UserChallenge", 'ChallengeStatus'>
    readonly proof_url: FieldRef<"UserChallenge", 'String'>
    readonly completed_at: FieldRef<"UserChallenge", 'DateTime'>
    readonly verified_at: FieldRef<"UserChallenge", 'DateTime'>
    readonly verified_by_admin_id: FieldRef<"UserChallenge", 'Int'>
    readonly verification_type: FieldRef<"UserChallenge", 'VerificationType'>
    readonly ai_confidence_score: FieldRef<"UserChallenge", 'Float'>
    readonly points_awarded: FieldRef<"UserChallenge", 'Int'>
    readonly waste_kg_saved: FieldRef<"UserChallenge", 'Float'>
    readonly admin_notes: FieldRef<"UserChallenge", 'String'>
    readonly created_at: FieldRef<"UserChallenge", 'DateTime'>
    readonly deleted_at: FieldRef<"UserChallenge", 'DateTime'>
    readonly skipped_at: FieldRef<"UserChallenge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserChallenge findUnique
   */
  export type UserChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * Filter, which UserChallenge to fetch.
     */
    where: UserChallengeWhereUniqueInput
  }

  /**
   * UserChallenge findUniqueOrThrow
   */
  export type UserChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * Filter, which UserChallenge to fetch.
     */
    where: UserChallengeWhereUniqueInput
  }

  /**
   * UserChallenge findFirst
   */
  export type UserChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * Filter, which UserChallenge to fetch.
     */
    where?: UserChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserChallenges to fetch.
     */
    orderBy?: UserChallengeOrderByWithRelationInput | UserChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserChallenges.
     */
    cursor?: UserChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserChallenges.
     */
    distinct?: UserChallengeScalarFieldEnum | UserChallengeScalarFieldEnum[]
  }

  /**
   * UserChallenge findFirstOrThrow
   */
  export type UserChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * Filter, which UserChallenge to fetch.
     */
    where?: UserChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserChallenges to fetch.
     */
    orderBy?: UserChallengeOrderByWithRelationInput | UserChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserChallenges.
     */
    cursor?: UserChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserChallenges.
     */
    distinct?: UserChallengeScalarFieldEnum | UserChallengeScalarFieldEnum[]
  }

  /**
   * UserChallenge findMany
   */
  export type UserChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * Filter, which UserChallenges to fetch.
     */
    where?: UserChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserChallenges to fetch.
     */
    orderBy?: UserChallengeOrderByWithRelationInput | UserChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserChallenges.
     */
    cursor?: UserChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserChallenges.
     */
    skip?: number
    distinct?: UserChallengeScalarFieldEnum | UserChallengeScalarFieldEnum[]
  }

  /**
   * UserChallenge create
   */
  export type UserChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserChallenge.
     */
    data: XOR<UserChallengeCreateInput, UserChallengeUncheckedCreateInput>
  }

  /**
   * UserChallenge createMany
   */
  export type UserChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserChallenges.
     */
    data: UserChallengeCreateManyInput | UserChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserChallenge createManyAndReturn
   */
  export type UserChallengeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * The data used to create many UserChallenges.
     */
    data: UserChallengeCreateManyInput | UserChallengeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserChallenge update
   */
  export type UserChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserChallenge.
     */
    data: XOR<UserChallengeUpdateInput, UserChallengeUncheckedUpdateInput>
    /**
     * Choose, which UserChallenge to update.
     */
    where: UserChallengeWhereUniqueInput
  }

  /**
   * UserChallenge updateMany
   */
  export type UserChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserChallenges.
     */
    data: XOR<UserChallengeUpdateManyMutationInput, UserChallengeUncheckedUpdateManyInput>
    /**
     * Filter which UserChallenges to update
     */
    where?: UserChallengeWhereInput
    /**
     * Limit how many UserChallenges to update.
     */
    limit?: number
  }

  /**
   * UserChallenge updateManyAndReturn
   */
  export type UserChallengeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * The data used to update UserChallenges.
     */
    data: XOR<UserChallengeUpdateManyMutationInput, UserChallengeUncheckedUpdateManyInput>
    /**
     * Filter which UserChallenges to update
     */
    where?: UserChallengeWhereInput
    /**
     * Limit how many UserChallenges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserChallenge upsert
   */
  export type UserChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserChallenge to update in case it exists.
     */
    where: UserChallengeWhereUniqueInput
    /**
     * In case the UserChallenge found by the `where` argument doesn't exist, create a new UserChallenge with this data.
     */
    create: XOR<UserChallengeCreateInput, UserChallengeUncheckedCreateInput>
    /**
     * In case the UserChallenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserChallengeUpdateInput, UserChallengeUncheckedUpdateInput>
  }

  /**
   * UserChallenge delete
   */
  export type UserChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * Filter which UserChallenge to delete.
     */
    where: UserChallengeWhereUniqueInput
  }

  /**
   * UserChallenge deleteMany
   */
  export type UserChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserChallenges to delete
     */
    where?: UserChallengeWhereInput
    /**
     * Limit how many UserChallenges to delete.
     */
    limit?: number
  }

  /**
   * UserChallenge.verified_by
   */
  export type UserChallenge$verified_byArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UserChallenge without action
   */
  export type UserChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChallenge
     */
    omit?: UserChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    report_id: number | null
    reporter_id: number | null
    reported_post_id: number | null
    reported_comment_id: number | null
    resolved_by_admin_id: number | null
  }

  export type ReportSumAggregateOutputType = {
    report_id: number | null
    reporter_id: number | null
    reported_post_id: number | null
    reported_comment_id: number | null
    resolved_by_admin_id: number | null
  }

  export type ReportMinAggregateOutputType = {
    report_id: number | null
    reporter_id: number | null
    reported_post_id: number | null
    reported_comment_id: number | null
    reason: string | null
    status: $Enums.ReportStatus | null
    moderator_notes: string | null
    resolved_by_admin_id: number | null
    created_at: Date | null
    resolved_at: Date | null
    deleted_at: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    report_id: number | null
    reporter_id: number | null
    reported_post_id: number | null
    reported_comment_id: number | null
    reason: string | null
    status: $Enums.ReportStatus | null
    moderator_notes: string | null
    resolved_by_admin_id: number | null
    created_at: Date | null
    resolved_at: Date | null
    deleted_at: Date | null
  }

  export type ReportCountAggregateOutputType = {
    report_id: number
    reporter_id: number
    reported_post_id: number
    reported_comment_id: number
    reason: number
    status: number
    moderator_notes: number
    resolved_by_admin_id: number
    created_at: number
    resolved_at: number
    deleted_at: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    report_id?: true
    reporter_id?: true
    reported_post_id?: true
    reported_comment_id?: true
    resolved_by_admin_id?: true
  }

  export type ReportSumAggregateInputType = {
    report_id?: true
    reporter_id?: true
    reported_post_id?: true
    reported_comment_id?: true
    resolved_by_admin_id?: true
  }

  export type ReportMinAggregateInputType = {
    report_id?: true
    reporter_id?: true
    reported_post_id?: true
    reported_comment_id?: true
    reason?: true
    status?: true
    moderator_notes?: true
    resolved_by_admin_id?: true
    created_at?: true
    resolved_at?: true
    deleted_at?: true
  }

  export type ReportMaxAggregateInputType = {
    report_id?: true
    reporter_id?: true
    reported_post_id?: true
    reported_comment_id?: true
    reason?: true
    status?: true
    moderator_notes?: true
    resolved_by_admin_id?: true
    created_at?: true
    resolved_at?: true
    deleted_at?: true
  }

  export type ReportCountAggregateInputType = {
    report_id?: true
    reporter_id?: true
    reported_post_id?: true
    reported_comment_id?: true
    reason?: true
    status?: true
    moderator_notes?: true
    resolved_by_admin_id?: true
    created_at?: true
    resolved_at?: true
    deleted_at?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _avg?: ReportAvgAggregateInputType
    _sum?: ReportSumAggregateInputType
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    report_id: number
    reporter_id: number
    reported_post_id: number | null
    reported_comment_id: number | null
    reason: string
    status: $Enums.ReportStatus
    moderator_notes: string | null
    resolved_by_admin_id: number | null
    created_at: Date
    resolved_at: Date | null
    deleted_at: Date | null
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    report_id?: boolean
    reporter_id?: boolean
    reported_post_id?: boolean
    reported_comment_id?: boolean
    reason?: boolean
    status?: boolean
    moderator_notes?: boolean
    resolved_by_admin_id?: boolean
    created_at?: boolean
    resolved_at?: boolean
    deleted_at?: boolean
    reported_comment?: boolean | Report$reported_commentArgs<ExtArgs>
    reported_post?: boolean | Report$reported_postArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    resolver?: boolean | Report$resolverArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    report_id?: boolean
    reporter_id?: boolean
    reported_post_id?: boolean
    reported_comment_id?: boolean
    reason?: boolean
    status?: boolean
    moderator_notes?: boolean
    resolved_by_admin_id?: boolean
    created_at?: boolean
    resolved_at?: boolean
    deleted_at?: boolean
    reported_comment?: boolean | Report$reported_commentArgs<ExtArgs>
    reported_post?: boolean | Report$reported_postArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    resolver?: boolean | Report$resolverArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    report_id?: boolean
    reporter_id?: boolean
    reported_post_id?: boolean
    reported_comment_id?: boolean
    reason?: boolean
    status?: boolean
    moderator_notes?: boolean
    resolved_by_admin_id?: boolean
    created_at?: boolean
    resolved_at?: boolean
    deleted_at?: boolean
    reported_comment?: boolean | Report$reported_commentArgs<ExtArgs>
    reported_post?: boolean | Report$reported_postArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    resolver?: boolean | Report$resolverArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    report_id?: boolean
    reporter_id?: boolean
    reported_post_id?: boolean
    reported_comment_id?: boolean
    reason?: boolean
    status?: boolean
    moderator_notes?: boolean
    resolved_by_admin_id?: boolean
    created_at?: boolean
    resolved_at?: boolean
    deleted_at?: boolean
  }

  export type ReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"report_id" | "reporter_id" | "reported_post_id" | "reported_comment_id" | "reason" | "status" | "moderator_notes" | "resolved_by_admin_id" | "created_at" | "resolved_at" | "deleted_at", ExtArgs["result"]["report"]>
  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reported_comment?: boolean | Report$reported_commentArgs<ExtArgs>
    reported_post?: boolean | Report$reported_postArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    resolver?: boolean | Report$resolverArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reported_comment?: boolean | Report$reported_commentArgs<ExtArgs>
    reported_post?: boolean | Report$reported_postArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    resolver?: boolean | Report$resolverArgs<ExtArgs>
  }
  export type ReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reported_comment?: boolean | Report$reported_commentArgs<ExtArgs>
    reported_post?: boolean | Report$reported_postArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    resolver?: boolean | Report$resolverArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      reported_comment: Prisma.$CommentPayload<ExtArgs> | null
      reported_post: Prisma.$PostPayload<ExtArgs> | null
      reporter: Prisma.$UserPayload<ExtArgs>
      resolver: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      report_id: number
      reporter_id: number
      reported_post_id: number | null
      reported_comment_id: number | null
      reason: string
      status: $Enums.ReportStatus
      moderator_notes: string | null
      resolved_by_admin_id: number | null
      created_at: Date
      resolved_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `report_id`
     * const reportWithReport_idOnly = await prisma.report.findMany({ select: { report_id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `report_id`
     * const reportWithReport_idOnly = await prisma.report.createManyAndReturn({
     *   select: { report_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports and returns the data updated in the database.
     * @param {ReportUpdateManyAndReturnArgs} args - Arguments to update many Reports.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reports and only return the `report_id`
     * const reportWithReport_idOnly = await prisma.report.updateManyAndReturn({
     *   select: { report_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reported_comment<T extends Report$reported_commentArgs<ExtArgs> = {}>(args?: Subset<T, Report$reported_commentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reported_post<T extends Report$reported_postArgs<ExtArgs> = {}>(args?: Subset<T, Report$reported_postArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reporter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resolver<T extends Report$resolverArgs<ExtArgs> = {}>(args?: Subset<T, Report$resolverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */
  interface ReportFieldRefs {
    readonly report_id: FieldRef<"Report", 'Int'>
    readonly reporter_id: FieldRef<"Report", 'Int'>
    readonly reported_post_id: FieldRef<"Report", 'Int'>
    readonly reported_comment_id: FieldRef<"Report", 'Int'>
    readonly reason: FieldRef<"Report", 'String'>
    readonly status: FieldRef<"Report", 'ReportStatus'>
    readonly moderator_notes: FieldRef<"Report", 'String'>
    readonly resolved_by_admin_id: FieldRef<"Report", 'Int'>
    readonly created_at: FieldRef<"Report", 'DateTime'>
    readonly resolved_at: FieldRef<"Report", 'DateTime'>
    readonly deleted_at: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
  }

  /**
   * Report updateManyAndReturn
   */
  export type ReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to delete.
     */
    limit?: number
  }

  /**
   * Report.reported_comment
   */
  export type Report$reported_commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Report.reported_post
   */
  export type Report$reported_postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
  }

  /**
   * Report.resolver
   */
  export type Report$resolverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model Announcement
   */

  export type AggregateAnnouncement = {
    _count: AnnouncementCountAggregateOutputType | null
    _avg: AnnouncementAvgAggregateOutputType | null
    _sum: AnnouncementSumAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  export type AnnouncementAvgAggregateOutputType = {
    announcement_id: number | null
    admin_id: number | null
  }

  export type AnnouncementSumAggregateOutputType = {
    announcement_id: number | null
    admin_id: number | null
  }

  export type AnnouncementMinAggregateOutputType = {
    announcement_id: number | null
    admin_id: number | null
    title: string | null
    content: string | null
    is_active: boolean | null
    created_at: Date | null
    expires_at: Date | null
    deleted_at: Date | null
  }

  export type AnnouncementMaxAggregateOutputType = {
    announcement_id: number | null
    admin_id: number | null
    title: string | null
    content: string | null
    is_active: boolean | null
    created_at: Date | null
    expires_at: Date | null
    deleted_at: Date | null
  }

  export type AnnouncementCountAggregateOutputType = {
    announcement_id: number
    admin_id: number
    title: number
    content: number
    is_active: number
    created_at: number
    expires_at: number
    deleted_at: number
    _all: number
  }


  export type AnnouncementAvgAggregateInputType = {
    announcement_id?: true
    admin_id?: true
  }

  export type AnnouncementSumAggregateInputType = {
    announcement_id?: true
    admin_id?: true
  }

  export type AnnouncementMinAggregateInputType = {
    announcement_id?: true
    admin_id?: true
    title?: true
    content?: true
    is_active?: true
    created_at?: true
    expires_at?: true
    deleted_at?: true
  }

  export type AnnouncementMaxAggregateInputType = {
    announcement_id?: true
    admin_id?: true
    title?: true
    content?: true
    is_active?: true
    created_at?: true
    expires_at?: true
    deleted_at?: true
  }

  export type AnnouncementCountAggregateInputType = {
    announcement_id?: true
    admin_id?: true
    title?: true
    content?: true
    is_active?: true
    created_at?: true
    expires_at?: true
    deleted_at?: true
    _all?: true
  }

  export type AnnouncementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcement to aggregate.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Announcements
    **/
    _count?: true | AnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnnouncementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnnouncementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementMaxAggregateInputType
  }

  export type GetAnnouncementAggregateType<T extends AnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncement[P]>
      : GetScalarType<T[P], AggregateAnnouncement[P]>
  }




  export type AnnouncementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithAggregationInput | AnnouncementOrderByWithAggregationInput[]
    by: AnnouncementScalarFieldEnum[] | AnnouncementScalarFieldEnum
    having?: AnnouncementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementCountAggregateInputType | true
    _avg?: AnnouncementAvgAggregateInputType
    _sum?: AnnouncementSumAggregateInputType
    _min?: AnnouncementMinAggregateInputType
    _max?: AnnouncementMaxAggregateInputType
  }

  export type AnnouncementGroupByOutputType = {
    announcement_id: number
    admin_id: number | null
    title: string
    content: string
    is_active: boolean
    created_at: Date
    expires_at: Date | null
    deleted_at: Date | null
    _count: AnnouncementCountAggregateOutputType | null
    _avg: AnnouncementAvgAggregateOutputType | null
    _sum: AnnouncementSumAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  type GetAnnouncementGroupByPayload<T extends AnnouncementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type AnnouncementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    announcement_id?: boolean
    admin_id?: boolean
    title?: boolean
    content?: boolean
    is_active?: boolean
    created_at?: boolean
    expires_at?: boolean
    deleted_at?: boolean
    admin?: boolean | Announcement$adminArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    announcement_id?: boolean
    admin_id?: boolean
    title?: boolean
    content?: boolean
    is_active?: boolean
    created_at?: boolean
    expires_at?: boolean
    deleted_at?: boolean
    admin?: boolean | Announcement$adminArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    announcement_id?: boolean
    admin_id?: boolean
    title?: boolean
    content?: boolean
    is_active?: boolean
    created_at?: boolean
    expires_at?: boolean
    deleted_at?: boolean
    admin?: boolean | Announcement$adminArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectScalar = {
    announcement_id?: boolean
    admin_id?: boolean
    title?: boolean
    content?: boolean
    is_active?: boolean
    created_at?: boolean
    expires_at?: boolean
    deleted_at?: boolean
  }

  export type AnnouncementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"announcement_id" | "admin_id" | "title" | "content" | "is_active" | "created_at" | "expires_at" | "deleted_at", ExtArgs["result"]["announcement"]>
  export type AnnouncementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | Announcement$adminArgs<ExtArgs>
  }
  export type AnnouncementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | Announcement$adminArgs<ExtArgs>
  }
  export type AnnouncementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | Announcement$adminArgs<ExtArgs>
  }

  export type $AnnouncementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Announcement"
    objects: {
      admin: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      announcement_id: number
      admin_id: number | null
      title: string
      content: string
      is_active: boolean
      created_at: Date
      expires_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["announcement"]>
    composites: {}
  }

  type AnnouncementGetPayload<S extends boolean | null | undefined | AnnouncementDefaultArgs> = $Result.GetResult<Prisma.$AnnouncementPayload, S>

  type AnnouncementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnnouncementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementCountAggregateInputType | true
    }

  export interface AnnouncementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Announcement'], meta: { name: 'Announcement' } }
    /**
     * Find zero or one Announcement that matches the filter.
     * @param {AnnouncementFindUniqueArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementFindUniqueArgs>(args: SelectSubset<T, AnnouncementFindUniqueArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Announcement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementFindUniqueOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnouncementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementFindFirstArgs>(args?: SelectSubset<T, AnnouncementFindFirstArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnouncementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcement.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcement.findMany({ take: 10 })
     * 
     * // Only select the `announcement_id`
     * const announcementWithAnnouncement_idOnly = await prisma.announcement.findMany({ select: { announcement_id: true } })
     * 
     */
    findMany<T extends AnnouncementFindManyArgs>(args?: SelectSubset<T, AnnouncementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Announcement.
     * @param {AnnouncementCreateArgs} args - Arguments to create a Announcement.
     * @example
     * // Create one Announcement
     * const Announcement = await prisma.announcement.create({
     *   data: {
     *     // ... data to create a Announcement
     *   }
     * })
     * 
     */
    create<T extends AnnouncementCreateArgs>(args: SelectSubset<T, AnnouncementCreateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Announcements.
     * @param {AnnouncementCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnouncementCreateManyArgs>(args?: SelectSubset<T, AnnouncementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Announcements and returns the data saved in the database.
     * @param {AnnouncementCreateManyAndReturnArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Announcements and only return the `announcement_id`
     * const announcementWithAnnouncement_idOnly = await prisma.announcement.createManyAndReturn({
     *   select: { announcement_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnnouncementCreateManyAndReturnArgs>(args?: SelectSubset<T, AnnouncementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Announcement.
     * @param {AnnouncementDeleteArgs} args - Arguments to delete one Announcement.
     * @example
     * // Delete one Announcement
     * const Announcement = await prisma.announcement.delete({
     *   where: {
     *     // ... filter to delete one Announcement
     *   }
     * })
     * 
     */
    delete<T extends AnnouncementDeleteArgs>(args: SelectSubset<T, AnnouncementDeleteArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Announcement.
     * @param {AnnouncementUpdateArgs} args - Arguments to update one Announcement.
     * @example
     * // Update one Announcement
     * const announcement = await prisma.announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnouncementUpdateArgs>(args: SelectSubset<T, AnnouncementUpdateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Announcements.
     * @param {AnnouncementDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnouncementDeleteManyArgs>(args?: SelectSubset<T, AnnouncementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnouncementUpdateManyArgs>(args: SelectSubset<T, AnnouncementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements and returns the data updated in the database.
     * @param {AnnouncementUpdateManyAndReturnArgs} args - Arguments to update many Announcements.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Announcements and only return the `announcement_id`
     * const announcementWithAnnouncement_idOnly = await prisma.announcement.updateManyAndReturn({
     *   select: { announcement_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnnouncementUpdateManyAndReturnArgs>(args: SelectSubset<T, AnnouncementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Announcement.
     * @param {AnnouncementUpsertArgs} args - Arguments to update or create a Announcement.
     * @example
     * // Update or create a Announcement
     * const announcement = await prisma.announcement.upsert({
     *   create: {
     *     // ... data to create a Announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcement we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementUpsertArgs>(args: SelectSubset<T, AnnouncementUpsertArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcement.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends AnnouncementCountArgs>(
      args?: Subset<T, AnnouncementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementAggregateArgs>(args: Subset<T, AnnouncementAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementAggregateType<T>>

    /**
     * Group by Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnouncementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Announcement model
   */
  readonly fields: AnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends Announcement$adminArgs<ExtArgs> = {}>(args?: Subset<T, Announcement$adminArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Announcement model
   */
  interface AnnouncementFieldRefs {
    readonly announcement_id: FieldRef<"Announcement", 'Int'>
    readonly admin_id: FieldRef<"Announcement", 'Int'>
    readonly title: FieldRef<"Announcement", 'String'>
    readonly content: FieldRef<"Announcement", 'String'>
    readonly is_active: FieldRef<"Announcement", 'Boolean'>
    readonly created_at: FieldRef<"Announcement", 'DateTime'>
    readonly expires_at: FieldRef<"Announcement", 'DateTime'>
    readonly deleted_at: FieldRef<"Announcement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Announcement findUnique
   */
  export type AnnouncementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findUniqueOrThrow
   */
  export type AnnouncementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findFirst
   */
  export type AnnouncementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findFirstOrThrow
   */
  export type AnnouncementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findMany
   */
  export type AnnouncementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement create
   */
  export type AnnouncementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to create a Announcement.
     */
    data: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
  }

  /**
   * Announcement createMany
   */
  export type AnnouncementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Announcement createManyAndReturn
   */
  export type AnnouncementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Announcement update
   */
  export type AnnouncementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to update a Announcement.
     */
    data: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
    /**
     * Choose, which Announcement to update.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement updateMany
   */
  export type AnnouncementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
  }

  /**
   * Announcement updateManyAndReturn
   */
  export type AnnouncementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Announcement upsert
   */
  export type AnnouncementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The filter to search for the Announcement to update in case it exists.
     */
    where: AnnouncementWhereUniqueInput
    /**
     * In case the Announcement found by the `where` argument doesn't exist, create a new Announcement with this data.
     */
    create: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
    /**
     * In case the Announcement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
  }

  /**
   * Announcement delete
   */
  export type AnnouncementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter which Announcement to delete.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement deleteMany
   */
  export type AnnouncementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcements to delete
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to delete.
     */
    limit?: number
  }

  /**
   * Announcement.admin
   */
  export type Announcement$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Announcement without action
   */
  export type AnnouncementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
  }


  /**
   * Model ModerationLog
   */

  export type AggregateModerationLog = {
    _count: ModerationLogCountAggregateOutputType | null
    _avg: ModerationLogAvgAggregateOutputType | null
    _sum: ModerationLogSumAggregateOutputType | null
    _min: ModerationLogMinAggregateOutputType | null
    _max: ModerationLogMaxAggregateOutputType | null
  }

  export type ModerationLogAvgAggregateOutputType = {
    log_id: number | null
    admin_id: number | null
    target_user_id: number | null
  }

  export type ModerationLogSumAggregateOutputType = {
    log_id: number | null
    admin_id: number | null
    target_user_id: number | null
  }

  export type ModerationLogMinAggregateOutputType = {
    log_id: number | null
    admin_id: number | null
    action: $Enums.ModerationAction | null
    target_id: string | null
    target_user_id: number | null
    reason: string | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type ModerationLogMaxAggregateOutputType = {
    log_id: number | null
    admin_id: number | null
    action: $Enums.ModerationAction | null
    target_id: string | null
    target_user_id: number | null
    reason: string | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type ModerationLogCountAggregateOutputType = {
    log_id: number
    admin_id: number
    action: number
    target_id: number
    target_user_id: number
    reason: number
    created_at: number
    deleted_at: number
    _all: number
  }


  export type ModerationLogAvgAggregateInputType = {
    log_id?: true
    admin_id?: true
    target_user_id?: true
  }

  export type ModerationLogSumAggregateInputType = {
    log_id?: true
    admin_id?: true
    target_user_id?: true
  }

  export type ModerationLogMinAggregateInputType = {
    log_id?: true
    admin_id?: true
    action?: true
    target_id?: true
    target_user_id?: true
    reason?: true
    created_at?: true
    deleted_at?: true
  }

  export type ModerationLogMaxAggregateInputType = {
    log_id?: true
    admin_id?: true
    action?: true
    target_id?: true
    target_user_id?: true
    reason?: true
    created_at?: true
    deleted_at?: true
  }

  export type ModerationLogCountAggregateInputType = {
    log_id?: true
    admin_id?: true
    action?: true
    target_id?: true
    target_user_id?: true
    reason?: true
    created_at?: true
    deleted_at?: true
    _all?: true
  }

  export type ModerationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModerationLog to aggregate.
     */
    where?: ModerationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationLogs to fetch.
     */
    orderBy?: ModerationLogOrderByWithRelationInput | ModerationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModerationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModerationLogs
    **/
    _count?: true | ModerationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModerationLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModerationLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModerationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModerationLogMaxAggregateInputType
  }

  export type GetModerationLogAggregateType<T extends ModerationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateModerationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModerationLog[P]>
      : GetScalarType<T[P], AggregateModerationLog[P]>
  }




  export type ModerationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModerationLogWhereInput
    orderBy?: ModerationLogOrderByWithAggregationInput | ModerationLogOrderByWithAggregationInput[]
    by: ModerationLogScalarFieldEnum[] | ModerationLogScalarFieldEnum
    having?: ModerationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModerationLogCountAggregateInputType | true
    _avg?: ModerationLogAvgAggregateInputType
    _sum?: ModerationLogSumAggregateInputType
    _min?: ModerationLogMinAggregateInputType
    _max?: ModerationLogMaxAggregateInputType
  }

  export type ModerationLogGroupByOutputType = {
    log_id: number
    admin_id: number | null
    action: $Enums.ModerationAction
    target_id: string
    target_user_id: number | null
    reason: string | null
    created_at: Date
    deleted_at: Date | null
    _count: ModerationLogCountAggregateOutputType | null
    _avg: ModerationLogAvgAggregateOutputType | null
    _sum: ModerationLogSumAggregateOutputType | null
    _min: ModerationLogMinAggregateOutputType | null
    _max: ModerationLogMaxAggregateOutputType | null
  }

  type GetModerationLogGroupByPayload<T extends ModerationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModerationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModerationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModerationLogGroupByOutputType[P]>
            : GetScalarType<T[P], ModerationLogGroupByOutputType[P]>
        }
      >
    >


  export type ModerationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    log_id?: boolean
    admin_id?: boolean
    action?: boolean
    target_id?: boolean
    target_user_id?: boolean
    reason?: boolean
    created_at?: boolean
    deleted_at?: boolean
    admin?: boolean | ModerationLog$adminArgs<ExtArgs>
    target_user?: boolean | ModerationLog$target_userArgs<ExtArgs>
  }, ExtArgs["result"]["moderationLog"]>

  export type ModerationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    log_id?: boolean
    admin_id?: boolean
    action?: boolean
    target_id?: boolean
    target_user_id?: boolean
    reason?: boolean
    created_at?: boolean
    deleted_at?: boolean
    admin?: boolean | ModerationLog$adminArgs<ExtArgs>
    target_user?: boolean | ModerationLog$target_userArgs<ExtArgs>
  }, ExtArgs["result"]["moderationLog"]>

  export type ModerationLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    log_id?: boolean
    admin_id?: boolean
    action?: boolean
    target_id?: boolean
    target_user_id?: boolean
    reason?: boolean
    created_at?: boolean
    deleted_at?: boolean
    admin?: boolean | ModerationLog$adminArgs<ExtArgs>
    target_user?: boolean | ModerationLog$target_userArgs<ExtArgs>
  }, ExtArgs["result"]["moderationLog"]>

  export type ModerationLogSelectScalar = {
    log_id?: boolean
    admin_id?: boolean
    action?: boolean
    target_id?: boolean
    target_user_id?: boolean
    reason?: boolean
    created_at?: boolean
    deleted_at?: boolean
  }

  export type ModerationLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"log_id" | "admin_id" | "action" | "target_id" | "target_user_id" | "reason" | "created_at" | "deleted_at", ExtArgs["result"]["moderationLog"]>
  export type ModerationLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | ModerationLog$adminArgs<ExtArgs>
    target_user?: boolean | ModerationLog$target_userArgs<ExtArgs>
  }
  export type ModerationLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | ModerationLog$adminArgs<ExtArgs>
    target_user?: boolean | ModerationLog$target_userArgs<ExtArgs>
  }
  export type ModerationLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | ModerationLog$adminArgs<ExtArgs>
    target_user?: boolean | ModerationLog$target_userArgs<ExtArgs>
  }

  export type $ModerationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModerationLog"
    objects: {
      admin: Prisma.$UserPayload<ExtArgs> | null
      target_user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      log_id: number
      admin_id: number | null
      action: $Enums.ModerationAction
      target_id: string
      target_user_id: number | null
      reason: string | null
      created_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["moderationLog"]>
    composites: {}
  }

  type ModerationLogGetPayload<S extends boolean | null | undefined | ModerationLogDefaultArgs> = $Result.GetResult<Prisma.$ModerationLogPayload, S>

  type ModerationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModerationLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModerationLogCountAggregateInputType | true
    }

  export interface ModerationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModerationLog'], meta: { name: 'ModerationLog' } }
    /**
     * Find zero or one ModerationLog that matches the filter.
     * @param {ModerationLogFindUniqueArgs} args - Arguments to find a ModerationLog
     * @example
     * // Get one ModerationLog
     * const moderationLog = await prisma.moderationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModerationLogFindUniqueArgs>(args: SelectSubset<T, ModerationLogFindUniqueArgs<ExtArgs>>): Prisma__ModerationLogClient<$Result.GetResult<Prisma.$ModerationLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModerationLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModerationLogFindUniqueOrThrowArgs} args - Arguments to find a ModerationLog
     * @example
     * // Get one ModerationLog
     * const moderationLog = await prisma.moderationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModerationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ModerationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModerationLogClient<$Result.GetResult<Prisma.$ModerationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModerationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationLogFindFirstArgs} args - Arguments to find a ModerationLog
     * @example
     * // Get one ModerationLog
     * const moderationLog = await prisma.moderationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModerationLogFindFirstArgs>(args?: SelectSubset<T, ModerationLogFindFirstArgs<ExtArgs>>): Prisma__ModerationLogClient<$Result.GetResult<Prisma.$ModerationLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModerationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationLogFindFirstOrThrowArgs} args - Arguments to find a ModerationLog
     * @example
     * // Get one ModerationLog
     * const moderationLog = await prisma.moderationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModerationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ModerationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModerationLogClient<$Result.GetResult<Prisma.$ModerationLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModerationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModerationLogs
     * const moderationLogs = await prisma.moderationLog.findMany()
     * 
     * // Get first 10 ModerationLogs
     * const moderationLogs = await prisma.moderationLog.findMany({ take: 10 })
     * 
     * // Only select the `log_id`
     * const moderationLogWithLog_idOnly = await prisma.moderationLog.findMany({ select: { log_id: true } })
     * 
     */
    findMany<T extends ModerationLogFindManyArgs>(args?: SelectSubset<T, ModerationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModerationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModerationLog.
     * @param {ModerationLogCreateArgs} args - Arguments to create a ModerationLog.
     * @example
     * // Create one ModerationLog
     * const ModerationLog = await prisma.moderationLog.create({
     *   data: {
     *     // ... data to create a ModerationLog
     *   }
     * })
     * 
     */
    create<T extends ModerationLogCreateArgs>(args: SelectSubset<T, ModerationLogCreateArgs<ExtArgs>>): Prisma__ModerationLogClient<$Result.GetResult<Prisma.$ModerationLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModerationLogs.
     * @param {ModerationLogCreateManyArgs} args - Arguments to create many ModerationLogs.
     * @example
     * // Create many ModerationLogs
     * const moderationLog = await prisma.moderationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModerationLogCreateManyArgs>(args?: SelectSubset<T, ModerationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModerationLogs and returns the data saved in the database.
     * @param {ModerationLogCreateManyAndReturnArgs} args - Arguments to create many ModerationLogs.
     * @example
     * // Create many ModerationLogs
     * const moderationLog = await prisma.moderationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModerationLogs and only return the `log_id`
     * const moderationLogWithLog_idOnly = await prisma.moderationLog.createManyAndReturn({
     *   select: { log_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModerationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ModerationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModerationLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModerationLog.
     * @param {ModerationLogDeleteArgs} args - Arguments to delete one ModerationLog.
     * @example
     * // Delete one ModerationLog
     * const ModerationLog = await prisma.moderationLog.delete({
     *   where: {
     *     // ... filter to delete one ModerationLog
     *   }
     * })
     * 
     */
    delete<T extends ModerationLogDeleteArgs>(args: SelectSubset<T, ModerationLogDeleteArgs<ExtArgs>>): Prisma__ModerationLogClient<$Result.GetResult<Prisma.$ModerationLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModerationLog.
     * @param {ModerationLogUpdateArgs} args - Arguments to update one ModerationLog.
     * @example
     * // Update one ModerationLog
     * const moderationLog = await prisma.moderationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModerationLogUpdateArgs>(args: SelectSubset<T, ModerationLogUpdateArgs<ExtArgs>>): Prisma__ModerationLogClient<$Result.GetResult<Prisma.$ModerationLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModerationLogs.
     * @param {ModerationLogDeleteManyArgs} args - Arguments to filter ModerationLogs to delete.
     * @example
     * // Delete a few ModerationLogs
     * const { count } = await prisma.moderationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModerationLogDeleteManyArgs>(args?: SelectSubset<T, ModerationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModerationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModerationLogs
     * const moderationLog = await prisma.moderationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModerationLogUpdateManyArgs>(args: SelectSubset<T, ModerationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModerationLogs and returns the data updated in the database.
     * @param {ModerationLogUpdateManyAndReturnArgs} args - Arguments to update many ModerationLogs.
     * @example
     * // Update many ModerationLogs
     * const moderationLog = await prisma.moderationLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModerationLogs and only return the `log_id`
     * const moderationLogWithLog_idOnly = await prisma.moderationLog.updateManyAndReturn({
     *   select: { log_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModerationLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ModerationLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModerationLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModerationLog.
     * @param {ModerationLogUpsertArgs} args - Arguments to update or create a ModerationLog.
     * @example
     * // Update or create a ModerationLog
     * const moderationLog = await prisma.moderationLog.upsert({
     *   create: {
     *     // ... data to create a ModerationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModerationLog we want to update
     *   }
     * })
     */
    upsert<T extends ModerationLogUpsertArgs>(args: SelectSubset<T, ModerationLogUpsertArgs<ExtArgs>>): Prisma__ModerationLogClient<$Result.GetResult<Prisma.$ModerationLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModerationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationLogCountArgs} args - Arguments to filter ModerationLogs to count.
     * @example
     * // Count the number of ModerationLogs
     * const count = await prisma.moderationLog.count({
     *   where: {
     *     // ... the filter for the ModerationLogs we want to count
     *   }
     * })
    **/
    count<T extends ModerationLogCountArgs>(
      args?: Subset<T, ModerationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModerationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModerationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModerationLogAggregateArgs>(args: Subset<T, ModerationLogAggregateArgs>): Prisma.PrismaPromise<GetModerationLogAggregateType<T>>

    /**
     * Group by ModerationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModerationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModerationLogGroupByArgs['orderBy'] }
        : { orderBy?: ModerationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModerationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModerationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModerationLog model
   */
  readonly fields: ModerationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModerationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModerationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends ModerationLog$adminArgs<ExtArgs> = {}>(args?: Subset<T, ModerationLog$adminArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    target_user<T extends ModerationLog$target_userArgs<ExtArgs> = {}>(args?: Subset<T, ModerationLog$target_userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModerationLog model
   */
  interface ModerationLogFieldRefs {
    readonly log_id: FieldRef<"ModerationLog", 'Int'>
    readonly admin_id: FieldRef<"ModerationLog", 'Int'>
    readonly action: FieldRef<"ModerationLog", 'ModerationAction'>
    readonly target_id: FieldRef<"ModerationLog", 'String'>
    readonly target_user_id: FieldRef<"ModerationLog", 'Int'>
    readonly reason: FieldRef<"ModerationLog", 'String'>
    readonly created_at: FieldRef<"ModerationLog", 'DateTime'>
    readonly deleted_at: FieldRef<"ModerationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModerationLog findUnique
   */
  export type ModerationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationLog
     */
    select?: ModerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModerationLog
     */
    omit?: ModerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationLogInclude<ExtArgs> | null
    /**
     * Filter, which ModerationLog to fetch.
     */
    where: ModerationLogWhereUniqueInput
  }

  /**
   * ModerationLog findUniqueOrThrow
   */
  export type ModerationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationLog
     */
    select?: ModerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModerationLog
     */
    omit?: ModerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationLogInclude<ExtArgs> | null
    /**
     * Filter, which ModerationLog to fetch.
     */
    where: ModerationLogWhereUniqueInput
  }

  /**
   * ModerationLog findFirst
   */
  export type ModerationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationLog
     */
    select?: ModerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModerationLog
     */
    omit?: ModerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationLogInclude<ExtArgs> | null
    /**
     * Filter, which ModerationLog to fetch.
     */
    where?: ModerationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationLogs to fetch.
     */
    orderBy?: ModerationLogOrderByWithRelationInput | ModerationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModerationLogs.
     */
    cursor?: ModerationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModerationLogs.
     */
    distinct?: ModerationLogScalarFieldEnum | ModerationLogScalarFieldEnum[]
  }

  /**
   * ModerationLog findFirstOrThrow
   */
  export type ModerationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationLog
     */
    select?: ModerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModerationLog
     */
    omit?: ModerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationLogInclude<ExtArgs> | null
    /**
     * Filter, which ModerationLog to fetch.
     */
    where?: ModerationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationLogs to fetch.
     */
    orderBy?: ModerationLogOrderByWithRelationInput | ModerationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModerationLogs.
     */
    cursor?: ModerationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModerationLogs.
     */
    distinct?: ModerationLogScalarFieldEnum | ModerationLogScalarFieldEnum[]
  }

  /**
   * ModerationLog findMany
   */
  export type ModerationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationLog
     */
    select?: ModerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModerationLog
     */
    omit?: ModerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationLogInclude<ExtArgs> | null
    /**
     * Filter, which ModerationLogs to fetch.
     */
    where?: ModerationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationLogs to fetch.
     */
    orderBy?: ModerationLogOrderByWithRelationInput | ModerationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModerationLogs.
     */
    cursor?: ModerationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationLogs.
     */
    skip?: number
    distinct?: ModerationLogScalarFieldEnum | ModerationLogScalarFieldEnum[]
  }

  /**
   * ModerationLog create
   */
  export type ModerationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationLog
     */
    select?: ModerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModerationLog
     */
    omit?: ModerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ModerationLog.
     */
    data: XOR<ModerationLogCreateInput, ModerationLogUncheckedCreateInput>
  }

  /**
   * ModerationLog createMany
   */
  export type ModerationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModerationLogs.
     */
    data: ModerationLogCreateManyInput | ModerationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModerationLog createManyAndReturn
   */
  export type ModerationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationLog
     */
    select?: ModerationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModerationLog
     */
    omit?: ModerationLogOmit<ExtArgs> | null
    /**
     * The data used to create many ModerationLogs.
     */
    data: ModerationLogCreateManyInput | ModerationLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModerationLog update
   */
  export type ModerationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationLog
     */
    select?: ModerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModerationLog
     */
    omit?: ModerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ModerationLog.
     */
    data: XOR<ModerationLogUpdateInput, ModerationLogUncheckedUpdateInput>
    /**
     * Choose, which ModerationLog to update.
     */
    where: ModerationLogWhereUniqueInput
  }

  /**
   * ModerationLog updateMany
   */
  export type ModerationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModerationLogs.
     */
    data: XOR<ModerationLogUpdateManyMutationInput, ModerationLogUncheckedUpdateManyInput>
    /**
     * Filter which ModerationLogs to update
     */
    where?: ModerationLogWhereInput
    /**
     * Limit how many ModerationLogs to update.
     */
    limit?: number
  }

  /**
   * ModerationLog updateManyAndReturn
   */
  export type ModerationLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationLog
     */
    select?: ModerationLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModerationLog
     */
    omit?: ModerationLogOmit<ExtArgs> | null
    /**
     * The data used to update ModerationLogs.
     */
    data: XOR<ModerationLogUpdateManyMutationInput, ModerationLogUncheckedUpdateManyInput>
    /**
     * Filter which ModerationLogs to update
     */
    where?: ModerationLogWhereInput
    /**
     * Limit how many ModerationLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModerationLog upsert
   */
  export type ModerationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationLog
     */
    select?: ModerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModerationLog
     */
    omit?: ModerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ModerationLog to update in case it exists.
     */
    where: ModerationLogWhereUniqueInput
    /**
     * In case the ModerationLog found by the `where` argument doesn't exist, create a new ModerationLog with this data.
     */
    create: XOR<ModerationLogCreateInput, ModerationLogUncheckedCreateInput>
    /**
     * In case the ModerationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModerationLogUpdateInput, ModerationLogUncheckedUpdateInput>
  }

  /**
   * ModerationLog delete
   */
  export type ModerationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationLog
     */
    select?: ModerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModerationLog
     */
    omit?: ModerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationLogInclude<ExtArgs> | null
    /**
     * Filter which ModerationLog to delete.
     */
    where: ModerationLogWhereUniqueInput
  }

  /**
   * ModerationLog deleteMany
   */
  export type ModerationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModerationLogs to delete
     */
    where?: ModerationLogWhereInput
    /**
     * Limit how many ModerationLogs to delete.
     */
    limit?: number
  }

  /**
   * ModerationLog.admin
   */
  export type ModerationLog$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ModerationLog.target_user
   */
  export type ModerationLog$target_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ModerationLog without action
   */
  export type ModerationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationLog
     */
    select?: ModerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModerationLog
     */
    omit?: ModerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationLogInclude<ExtArgs> | null
  }


  /**
   * Model Sponsor
   */

  export type AggregateSponsor = {
    _count: SponsorCountAggregateOutputType | null
    _avg: SponsorAvgAggregateOutputType | null
    _sum: SponsorSumAggregateOutputType | null
    _min: SponsorMinAggregateOutputType | null
    _max: SponsorMaxAggregateOutputType | null
  }

  export type SponsorAvgAggregateOutputType = {
    sponsor_id: number | null
    created_by_admin_id: number | null
  }

  export type SponsorSumAggregateOutputType = {
    sponsor_id: number | null
    created_by_admin_id: number | null
  }

  export type SponsorMinAggregateOutputType = {
    sponsor_id: number | null
    name: string | null
    logo_url: string | null
    description: string | null
    contact_email: string | null
    is_active: boolean | null
    created_by_admin_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type SponsorMaxAggregateOutputType = {
    sponsor_id: number | null
    name: string | null
    logo_url: string | null
    description: string | null
    contact_email: string | null
    is_active: boolean | null
    created_by_admin_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type SponsorCountAggregateOutputType = {
    sponsor_id: number
    name: number
    logo_url: number
    description: number
    contact_email: number
    is_active: number
    created_by_admin_id: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type SponsorAvgAggregateInputType = {
    sponsor_id?: true
    created_by_admin_id?: true
  }

  export type SponsorSumAggregateInputType = {
    sponsor_id?: true
    created_by_admin_id?: true
  }

  export type SponsorMinAggregateInputType = {
    sponsor_id?: true
    name?: true
    logo_url?: true
    description?: true
    contact_email?: true
    is_active?: true
    created_by_admin_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type SponsorMaxAggregateInputType = {
    sponsor_id?: true
    name?: true
    logo_url?: true
    description?: true
    contact_email?: true
    is_active?: true
    created_by_admin_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type SponsorCountAggregateInputType = {
    sponsor_id?: true
    name?: true
    logo_url?: true
    description?: true
    contact_email?: true
    is_active?: true
    created_by_admin_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type SponsorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sponsor to aggregate.
     */
    where?: SponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sponsors
    **/
    _count?: true | SponsorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SponsorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SponsorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SponsorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SponsorMaxAggregateInputType
  }

  export type GetSponsorAggregateType<T extends SponsorAggregateArgs> = {
        [P in keyof T & keyof AggregateSponsor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSponsor[P]>
      : GetScalarType<T[P], AggregateSponsor[P]>
  }




  export type SponsorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SponsorWhereInput
    orderBy?: SponsorOrderByWithAggregationInput | SponsorOrderByWithAggregationInput[]
    by: SponsorScalarFieldEnum[] | SponsorScalarFieldEnum
    having?: SponsorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SponsorCountAggregateInputType | true
    _avg?: SponsorAvgAggregateInputType
    _sum?: SponsorSumAggregateInputType
    _min?: SponsorMinAggregateInputType
    _max?: SponsorMaxAggregateInputType
  }

  export type SponsorGroupByOutputType = {
    sponsor_id: number
    name: string
    logo_url: string | null
    description: string | null
    contact_email: string | null
    is_active: boolean
    created_by_admin_id: number | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: SponsorCountAggregateOutputType | null
    _avg: SponsorAvgAggregateOutputType | null
    _sum: SponsorSumAggregateOutputType | null
    _min: SponsorMinAggregateOutputType | null
    _max: SponsorMaxAggregateOutputType | null
  }

  type GetSponsorGroupByPayload<T extends SponsorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SponsorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SponsorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SponsorGroupByOutputType[P]>
            : GetScalarType<T[P], SponsorGroupByOutputType[P]>
        }
      >
    >


  export type SponsorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sponsor_id?: boolean
    name?: boolean
    logo_url?: boolean
    description?: boolean
    contact_email?: boolean
    is_active?: boolean
    created_by_admin_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    created_by_admin?: boolean | Sponsor$created_by_adminArgs<ExtArgs>
    rewards?: boolean | Sponsor$rewardsArgs<ExtArgs>
    _count?: boolean | SponsorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sponsor"]>

  export type SponsorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sponsor_id?: boolean
    name?: boolean
    logo_url?: boolean
    description?: boolean
    contact_email?: boolean
    is_active?: boolean
    created_by_admin_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    created_by_admin?: boolean | Sponsor$created_by_adminArgs<ExtArgs>
  }, ExtArgs["result"]["sponsor"]>

  export type SponsorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sponsor_id?: boolean
    name?: boolean
    logo_url?: boolean
    description?: boolean
    contact_email?: boolean
    is_active?: boolean
    created_by_admin_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    created_by_admin?: boolean | Sponsor$created_by_adminArgs<ExtArgs>
  }, ExtArgs["result"]["sponsor"]>

  export type SponsorSelectScalar = {
    sponsor_id?: boolean
    name?: boolean
    logo_url?: boolean
    description?: boolean
    contact_email?: boolean
    is_active?: boolean
    created_by_admin_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type SponsorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sponsor_id" | "name" | "logo_url" | "description" | "contact_email" | "is_active" | "created_by_admin_id" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["sponsor"]>
  export type SponsorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    created_by_admin?: boolean | Sponsor$created_by_adminArgs<ExtArgs>
    rewards?: boolean | Sponsor$rewardsArgs<ExtArgs>
    _count?: boolean | SponsorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SponsorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    created_by_admin?: boolean | Sponsor$created_by_adminArgs<ExtArgs>
  }
  export type SponsorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    created_by_admin?: boolean | Sponsor$created_by_adminArgs<ExtArgs>
  }

  export type $SponsorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sponsor"
    objects: {
      created_by_admin: Prisma.$UserPayload<ExtArgs> | null
      rewards: Prisma.$SponsorRewardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      sponsor_id: number
      name: string
      logo_url: string | null
      description: string | null
      contact_email: string | null
      is_active: boolean
      created_by_admin_id: number | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["sponsor"]>
    composites: {}
  }

  type SponsorGetPayload<S extends boolean | null | undefined | SponsorDefaultArgs> = $Result.GetResult<Prisma.$SponsorPayload, S>

  type SponsorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SponsorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SponsorCountAggregateInputType | true
    }

  export interface SponsorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sponsor'], meta: { name: 'Sponsor' } }
    /**
     * Find zero or one Sponsor that matches the filter.
     * @param {SponsorFindUniqueArgs} args - Arguments to find a Sponsor
     * @example
     * // Get one Sponsor
     * const sponsor = await prisma.sponsor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SponsorFindUniqueArgs>(args: SelectSubset<T, SponsorFindUniqueArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sponsor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SponsorFindUniqueOrThrowArgs} args - Arguments to find a Sponsor
     * @example
     * // Get one Sponsor
     * const sponsor = await prisma.sponsor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SponsorFindUniqueOrThrowArgs>(args: SelectSubset<T, SponsorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sponsor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorFindFirstArgs} args - Arguments to find a Sponsor
     * @example
     * // Get one Sponsor
     * const sponsor = await prisma.sponsor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SponsorFindFirstArgs>(args?: SelectSubset<T, SponsorFindFirstArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sponsor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorFindFirstOrThrowArgs} args - Arguments to find a Sponsor
     * @example
     * // Get one Sponsor
     * const sponsor = await prisma.sponsor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SponsorFindFirstOrThrowArgs>(args?: SelectSubset<T, SponsorFindFirstOrThrowArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sponsors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sponsors
     * const sponsors = await prisma.sponsor.findMany()
     * 
     * // Get first 10 Sponsors
     * const sponsors = await prisma.sponsor.findMany({ take: 10 })
     * 
     * // Only select the `sponsor_id`
     * const sponsorWithSponsor_idOnly = await prisma.sponsor.findMany({ select: { sponsor_id: true } })
     * 
     */
    findMany<T extends SponsorFindManyArgs>(args?: SelectSubset<T, SponsorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sponsor.
     * @param {SponsorCreateArgs} args - Arguments to create a Sponsor.
     * @example
     * // Create one Sponsor
     * const Sponsor = await prisma.sponsor.create({
     *   data: {
     *     // ... data to create a Sponsor
     *   }
     * })
     * 
     */
    create<T extends SponsorCreateArgs>(args: SelectSubset<T, SponsorCreateArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sponsors.
     * @param {SponsorCreateManyArgs} args - Arguments to create many Sponsors.
     * @example
     * // Create many Sponsors
     * const sponsor = await prisma.sponsor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SponsorCreateManyArgs>(args?: SelectSubset<T, SponsorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sponsors and returns the data saved in the database.
     * @param {SponsorCreateManyAndReturnArgs} args - Arguments to create many Sponsors.
     * @example
     * // Create many Sponsors
     * const sponsor = await prisma.sponsor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sponsors and only return the `sponsor_id`
     * const sponsorWithSponsor_idOnly = await prisma.sponsor.createManyAndReturn({
     *   select: { sponsor_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SponsorCreateManyAndReturnArgs>(args?: SelectSubset<T, SponsorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sponsor.
     * @param {SponsorDeleteArgs} args - Arguments to delete one Sponsor.
     * @example
     * // Delete one Sponsor
     * const Sponsor = await prisma.sponsor.delete({
     *   where: {
     *     // ... filter to delete one Sponsor
     *   }
     * })
     * 
     */
    delete<T extends SponsorDeleteArgs>(args: SelectSubset<T, SponsorDeleteArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sponsor.
     * @param {SponsorUpdateArgs} args - Arguments to update one Sponsor.
     * @example
     * // Update one Sponsor
     * const sponsor = await prisma.sponsor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SponsorUpdateArgs>(args: SelectSubset<T, SponsorUpdateArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sponsors.
     * @param {SponsorDeleteManyArgs} args - Arguments to filter Sponsors to delete.
     * @example
     * // Delete a few Sponsors
     * const { count } = await prisma.sponsor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SponsorDeleteManyArgs>(args?: SelectSubset<T, SponsorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sponsors
     * const sponsor = await prisma.sponsor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SponsorUpdateManyArgs>(args: SelectSubset<T, SponsorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sponsors and returns the data updated in the database.
     * @param {SponsorUpdateManyAndReturnArgs} args - Arguments to update many Sponsors.
     * @example
     * // Update many Sponsors
     * const sponsor = await prisma.sponsor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sponsors and only return the `sponsor_id`
     * const sponsorWithSponsor_idOnly = await prisma.sponsor.updateManyAndReturn({
     *   select: { sponsor_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SponsorUpdateManyAndReturnArgs>(args: SelectSubset<T, SponsorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sponsor.
     * @param {SponsorUpsertArgs} args - Arguments to update or create a Sponsor.
     * @example
     * // Update or create a Sponsor
     * const sponsor = await prisma.sponsor.upsert({
     *   create: {
     *     // ... data to create a Sponsor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sponsor we want to update
     *   }
     * })
     */
    upsert<T extends SponsorUpsertArgs>(args: SelectSubset<T, SponsorUpsertArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorCountArgs} args - Arguments to filter Sponsors to count.
     * @example
     * // Count the number of Sponsors
     * const count = await prisma.sponsor.count({
     *   where: {
     *     // ... the filter for the Sponsors we want to count
     *   }
     * })
    **/
    count<T extends SponsorCountArgs>(
      args?: Subset<T, SponsorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SponsorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sponsor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SponsorAggregateArgs>(args: Subset<T, SponsorAggregateArgs>): Prisma.PrismaPromise<GetSponsorAggregateType<T>>

    /**
     * Group by Sponsor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SponsorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SponsorGroupByArgs['orderBy'] }
        : { orderBy?: SponsorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SponsorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSponsorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sponsor model
   */
  readonly fields: SponsorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sponsor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SponsorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    created_by_admin<T extends Sponsor$created_by_adminArgs<ExtArgs> = {}>(args?: Subset<T, Sponsor$created_by_adminArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rewards<T extends Sponsor$rewardsArgs<ExtArgs> = {}>(args?: Subset<T, Sponsor$rewardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorRewardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sponsor model
   */
  interface SponsorFieldRefs {
    readonly sponsor_id: FieldRef<"Sponsor", 'Int'>
    readonly name: FieldRef<"Sponsor", 'String'>
    readonly logo_url: FieldRef<"Sponsor", 'String'>
    readonly description: FieldRef<"Sponsor", 'String'>
    readonly contact_email: FieldRef<"Sponsor", 'String'>
    readonly is_active: FieldRef<"Sponsor", 'Boolean'>
    readonly created_by_admin_id: FieldRef<"Sponsor", 'Int'>
    readonly created_at: FieldRef<"Sponsor", 'DateTime'>
    readonly updated_at: FieldRef<"Sponsor", 'DateTime'>
    readonly deleted_at: FieldRef<"Sponsor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sponsor findUnique
   */
  export type SponsorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter, which Sponsor to fetch.
     */
    where: SponsorWhereUniqueInput
  }

  /**
   * Sponsor findUniqueOrThrow
   */
  export type SponsorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter, which Sponsor to fetch.
     */
    where: SponsorWhereUniqueInput
  }

  /**
   * Sponsor findFirst
   */
  export type SponsorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter, which Sponsor to fetch.
     */
    where?: SponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sponsors.
     */
    cursor?: SponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sponsors.
     */
    distinct?: SponsorScalarFieldEnum | SponsorScalarFieldEnum[]
  }

  /**
   * Sponsor findFirstOrThrow
   */
  export type SponsorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter, which Sponsor to fetch.
     */
    where?: SponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sponsors.
     */
    cursor?: SponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sponsors.
     */
    distinct?: SponsorScalarFieldEnum | SponsorScalarFieldEnum[]
  }

  /**
   * Sponsor findMany
   */
  export type SponsorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter, which Sponsors to fetch.
     */
    where?: SponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sponsors.
     */
    cursor?: SponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    distinct?: SponsorScalarFieldEnum | SponsorScalarFieldEnum[]
  }

  /**
   * Sponsor create
   */
  export type SponsorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * The data needed to create a Sponsor.
     */
    data: XOR<SponsorCreateInput, SponsorUncheckedCreateInput>
  }

  /**
   * Sponsor createMany
   */
  export type SponsorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sponsors.
     */
    data: SponsorCreateManyInput | SponsorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sponsor createManyAndReturn
   */
  export type SponsorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * The data used to create many Sponsors.
     */
    data: SponsorCreateManyInput | SponsorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sponsor update
   */
  export type SponsorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * The data needed to update a Sponsor.
     */
    data: XOR<SponsorUpdateInput, SponsorUncheckedUpdateInput>
    /**
     * Choose, which Sponsor to update.
     */
    where: SponsorWhereUniqueInput
  }

  /**
   * Sponsor updateMany
   */
  export type SponsorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sponsors.
     */
    data: XOR<SponsorUpdateManyMutationInput, SponsorUncheckedUpdateManyInput>
    /**
     * Filter which Sponsors to update
     */
    where?: SponsorWhereInput
    /**
     * Limit how many Sponsors to update.
     */
    limit?: number
  }

  /**
   * Sponsor updateManyAndReturn
   */
  export type SponsorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * The data used to update Sponsors.
     */
    data: XOR<SponsorUpdateManyMutationInput, SponsorUncheckedUpdateManyInput>
    /**
     * Filter which Sponsors to update
     */
    where?: SponsorWhereInput
    /**
     * Limit how many Sponsors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sponsor upsert
   */
  export type SponsorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * The filter to search for the Sponsor to update in case it exists.
     */
    where: SponsorWhereUniqueInput
    /**
     * In case the Sponsor found by the `where` argument doesn't exist, create a new Sponsor with this data.
     */
    create: XOR<SponsorCreateInput, SponsorUncheckedCreateInput>
    /**
     * In case the Sponsor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SponsorUpdateInput, SponsorUncheckedUpdateInput>
  }

  /**
   * Sponsor delete
   */
  export type SponsorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter which Sponsor to delete.
     */
    where: SponsorWhereUniqueInput
  }

  /**
   * Sponsor deleteMany
   */
  export type SponsorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sponsors to delete
     */
    where?: SponsorWhereInput
    /**
     * Limit how many Sponsors to delete.
     */
    limit?: number
  }

  /**
   * Sponsor.created_by_admin
   */
  export type Sponsor$created_by_adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Sponsor.rewards
   */
  export type Sponsor$rewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsorReward
     */
    select?: SponsorRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsorReward
     */
    omit?: SponsorRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorRewardInclude<ExtArgs> | null
    where?: SponsorRewardWhereInput
    orderBy?: SponsorRewardOrderByWithRelationInput | SponsorRewardOrderByWithRelationInput[]
    cursor?: SponsorRewardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SponsorRewardScalarFieldEnum | SponsorRewardScalarFieldEnum[]
  }

  /**
   * Sponsor without action
   */
  export type SponsorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
  }


  /**
   * Model SponsorReward
   */

  export type AggregateSponsorReward = {
    _count: SponsorRewardCountAggregateOutputType | null
    _avg: SponsorRewardAvgAggregateOutputType | null
    _sum: SponsorRewardSumAggregateOutputType | null
    _min: SponsorRewardMinAggregateOutputType | null
    _max: SponsorRewardMaxAggregateOutputType | null
  }

  export type SponsorRewardAvgAggregateOutputType = {
    reward_id: number | null
    sponsor_id: number | null
    points_cost: number | null
    quantity: number | null
    redeemed_count: number | null
  }

  export type SponsorRewardSumAggregateOutputType = {
    reward_id: number | null
    sponsor_id: number | null
    points_cost: number | null
    quantity: number | null
    redeemed_count: number | null
  }

  export type SponsorRewardMinAggregateOutputType = {
    reward_id: number | null
    sponsor_id: number | null
    title: string | null
    description: string | null
    points_cost: number | null
    quantity: number | null
    redeemed_count: number | null
    is_active: boolean | null
    display_on_leaderboard: boolean | null
    created_at: Date | null
    updated_at: Date | null
    expires_at: Date | null
    deleted_at: Date | null
  }

  export type SponsorRewardMaxAggregateOutputType = {
    reward_id: number | null
    sponsor_id: number | null
    title: string | null
    description: string | null
    points_cost: number | null
    quantity: number | null
    redeemed_count: number | null
    is_active: boolean | null
    display_on_leaderboard: boolean | null
    created_at: Date | null
    updated_at: Date | null
    expires_at: Date | null
    deleted_at: Date | null
  }

  export type SponsorRewardCountAggregateOutputType = {
    reward_id: number
    sponsor_id: number
    title: number
    description: number
    points_cost: number
    quantity: number
    redeemed_count: number
    is_active: number
    display_on_leaderboard: number
    created_at: number
    updated_at: number
    expires_at: number
    deleted_at: number
    _all: number
  }


  export type SponsorRewardAvgAggregateInputType = {
    reward_id?: true
    sponsor_id?: true
    points_cost?: true
    quantity?: true
    redeemed_count?: true
  }

  export type SponsorRewardSumAggregateInputType = {
    reward_id?: true
    sponsor_id?: true
    points_cost?: true
    quantity?: true
    redeemed_count?: true
  }

  export type SponsorRewardMinAggregateInputType = {
    reward_id?: true
    sponsor_id?: true
    title?: true
    description?: true
    points_cost?: true
    quantity?: true
    redeemed_count?: true
    is_active?: true
    display_on_leaderboard?: true
    created_at?: true
    updated_at?: true
    expires_at?: true
    deleted_at?: true
  }

  export type SponsorRewardMaxAggregateInputType = {
    reward_id?: true
    sponsor_id?: true
    title?: true
    description?: true
    points_cost?: true
    quantity?: true
    redeemed_count?: true
    is_active?: true
    display_on_leaderboard?: true
    created_at?: true
    updated_at?: true
    expires_at?: true
    deleted_at?: true
  }

  export type SponsorRewardCountAggregateInputType = {
    reward_id?: true
    sponsor_id?: true
    title?: true
    description?: true
    points_cost?: true
    quantity?: true
    redeemed_count?: true
    is_active?: true
    display_on_leaderboard?: true
    created_at?: true
    updated_at?: true
    expires_at?: true
    deleted_at?: true
    _all?: true
  }

  export type SponsorRewardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SponsorReward to aggregate.
     */
    where?: SponsorRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SponsorRewards to fetch.
     */
    orderBy?: SponsorRewardOrderByWithRelationInput | SponsorRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SponsorRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SponsorRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SponsorRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SponsorRewards
    **/
    _count?: true | SponsorRewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SponsorRewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SponsorRewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SponsorRewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SponsorRewardMaxAggregateInputType
  }

  export type GetSponsorRewardAggregateType<T extends SponsorRewardAggregateArgs> = {
        [P in keyof T & keyof AggregateSponsorReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSponsorReward[P]>
      : GetScalarType<T[P], AggregateSponsorReward[P]>
  }




  export type SponsorRewardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SponsorRewardWhereInput
    orderBy?: SponsorRewardOrderByWithAggregationInput | SponsorRewardOrderByWithAggregationInput[]
    by: SponsorRewardScalarFieldEnum[] | SponsorRewardScalarFieldEnum
    having?: SponsorRewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SponsorRewardCountAggregateInputType | true
    _avg?: SponsorRewardAvgAggregateInputType
    _sum?: SponsorRewardSumAggregateInputType
    _min?: SponsorRewardMinAggregateInputType
    _max?: SponsorRewardMaxAggregateInputType
  }

  export type SponsorRewardGroupByOutputType = {
    reward_id: number
    sponsor_id: number
    title: string
    description: string | null
    points_cost: number
    quantity: number | null
    redeemed_count: number
    is_active: boolean
    display_on_leaderboard: boolean
    created_at: Date
    updated_at: Date
    expires_at: Date | null
    deleted_at: Date | null
    _count: SponsorRewardCountAggregateOutputType | null
    _avg: SponsorRewardAvgAggregateOutputType | null
    _sum: SponsorRewardSumAggregateOutputType | null
    _min: SponsorRewardMinAggregateOutputType | null
    _max: SponsorRewardMaxAggregateOutputType | null
  }

  type GetSponsorRewardGroupByPayload<T extends SponsorRewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SponsorRewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SponsorRewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SponsorRewardGroupByOutputType[P]>
            : GetScalarType<T[P], SponsorRewardGroupByOutputType[P]>
        }
      >
    >


  export type SponsorRewardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    reward_id?: boolean
    sponsor_id?: boolean
    title?: boolean
    description?: boolean
    points_cost?: boolean
    quantity?: boolean
    redeemed_count?: boolean
    is_active?: boolean
    display_on_leaderboard?: boolean
    created_at?: boolean
    updated_at?: boolean
    expires_at?: boolean
    deleted_at?: boolean
    sponsor?: boolean | SponsorDefaultArgs<ExtArgs>
    claims?: boolean | SponsorReward$claimsArgs<ExtArgs>
    _count?: boolean | SponsorRewardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sponsorReward"]>

  export type SponsorRewardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    reward_id?: boolean
    sponsor_id?: boolean
    title?: boolean
    description?: boolean
    points_cost?: boolean
    quantity?: boolean
    redeemed_count?: boolean
    is_active?: boolean
    display_on_leaderboard?: boolean
    created_at?: boolean
    updated_at?: boolean
    expires_at?: boolean
    deleted_at?: boolean
    sponsor?: boolean | SponsorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sponsorReward"]>

  export type SponsorRewardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    reward_id?: boolean
    sponsor_id?: boolean
    title?: boolean
    description?: boolean
    points_cost?: boolean
    quantity?: boolean
    redeemed_count?: boolean
    is_active?: boolean
    display_on_leaderboard?: boolean
    created_at?: boolean
    updated_at?: boolean
    expires_at?: boolean
    deleted_at?: boolean
    sponsor?: boolean | SponsorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sponsorReward"]>

  export type SponsorRewardSelectScalar = {
    reward_id?: boolean
    sponsor_id?: boolean
    title?: boolean
    description?: boolean
    points_cost?: boolean
    quantity?: boolean
    redeemed_count?: boolean
    is_active?: boolean
    display_on_leaderboard?: boolean
    created_at?: boolean
    updated_at?: boolean
    expires_at?: boolean
    deleted_at?: boolean
  }

  export type SponsorRewardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"reward_id" | "sponsor_id" | "title" | "description" | "points_cost" | "quantity" | "redeemed_count" | "is_active" | "display_on_leaderboard" | "created_at" | "updated_at" | "expires_at" | "deleted_at", ExtArgs["result"]["sponsorReward"]>
  export type SponsorRewardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sponsor?: boolean | SponsorDefaultArgs<ExtArgs>
    claims?: boolean | SponsorReward$claimsArgs<ExtArgs>
    _count?: boolean | SponsorRewardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SponsorRewardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sponsor?: boolean | SponsorDefaultArgs<ExtArgs>
  }
  export type SponsorRewardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sponsor?: boolean | SponsorDefaultArgs<ExtArgs>
  }

  export type $SponsorRewardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SponsorReward"
    objects: {
      sponsor: Prisma.$SponsorPayload<ExtArgs>
      claims: Prisma.$UserRedemptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      reward_id: number
      sponsor_id: number
      title: string
      description: string | null
      points_cost: number
      quantity: number | null
      redeemed_count: number
      is_active: boolean
      display_on_leaderboard: boolean
      created_at: Date
      updated_at: Date
      expires_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["sponsorReward"]>
    composites: {}
  }

  type SponsorRewardGetPayload<S extends boolean | null | undefined | SponsorRewardDefaultArgs> = $Result.GetResult<Prisma.$SponsorRewardPayload, S>

  type SponsorRewardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SponsorRewardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SponsorRewardCountAggregateInputType | true
    }

  export interface SponsorRewardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SponsorReward'], meta: { name: 'SponsorReward' } }
    /**
     * Find zero or one SponsorReward that matches the filter.
     * @param {SponsorRewardFindUniqueArgs} args - Arguments to find a SponsorReward
     * @example
     * // Get one SponsorReward
     * const sponsorReward = await prisma.sponsorReward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SponsorRewardFindUniqueArgs>(args: SelectSubset<T, SponsorRewardFindUniqueArgs<ExtArgs>>): Prisma__SponsorRewardClient<$Result.GetResult<Prisma.$SponsorRewardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SponsorReward that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SponsorRewardFindUniqueOrThrowArgs} args - Arguments to find a SponsorReward
     * @example
     * // Get one SponsorReward
     * const sponsorReward = await prisma.sponsorReward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SponsorRewardFindUniqueOrThrowArgs>(args: SelectSubset<T, SponsorRewardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SponsorRewardClient<$Result.GetResult<Prisma.$SponsorRewardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SponsorReward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorRewardFindFirstArgs} args - Arguments to find a SponsorReward
     * @example
     * // Get one SponsorReward
     * const sponsorReward = await prisma.sponsorReward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SponsorRewardFindFirstArgs>(args?: SelectSubset<T, SponsorRewardFindFirstArgs<ExtArgs>>): Prisma__SponsorRewardClient<$Result.GetResult<Prisma.$SponsorRewardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SponsorReward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorRewardFindFirstOrThrowArgs} args - Arguments to find a SponsorReward
     * @example
     * // Get one SponsorReward
     * const sponsorReward = await prisma.sponsorReward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SponsorRewardFindFirstOrThrowArgs>(args?: SelectSubset<T, SponsorRewardFindFirstOrThrowArgs<ExtArgs>>): Prisma__SponsorRewardClient<$Result.GetResult<Prisma.$SponsorRewardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SponsorRewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorRewardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SponsorRewards
     * const sponsorRewards = await prisma.sponsorReward.findMany()
     * 
     * // Get first 10 SponsorRewards
     * const sponsorRewards = await prisma.sponsorReward.findMany({ take: 10 })
     * 
     * // Only select the `reward_id`
     * const sponsorRewardWithReward_idOnly = await prisma.sponsorReward.findMany({ select: { reward_id: true } })
     * 
     */
    findMany<T extends SponsorRewardFindManyArgs>(args?: SelectSubset<T, SponsorRewardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorRewardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SponsorReward.
     * @param {SponsorRewardCreateArgs} args - Arguments to create a SponsorReward.
     * @example
     * // Create one SponsorReward
     * const SponsorReward = await prisma.sponsorReward.create({
     *   data: {
     *     // ... data to create a SponsorReward
     *   }
     * })
     * 
     */
    create<T extends SponsorRewardCreateArgs>(args: SelectSubset<T, SponsorRewardCreateArgs<ExtArgs>>): Prisma__SponsorRewardClient<$Result.GetResult<Prisma.$SponsorRewardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SponsorRewards.
     * @param {SponsorRewardCreateManyArgs} args - Arguments to create many SponsorRewards.
     * @example
     * // Create many SponsorRewards
     * const sponsorReward = await prisma.sponsorReward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SponsorRewardCreateManyArgs>(args?: SelectSubset<T, SponsorRewardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SponsorRewards and returns the data saved in the database.
     * @param {SponsorRewardCreateManyAndReturnArgs} args - Arguments to create many SponsorRewards.
     * @example
     * // Create many SponsorRewards
     * const sponsorReward = await prisma.sponsorReward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SponsorRewards and only return the `reward_id`
     * const sponsorRewardWithReward_idOnly = await prisma.sponsorReward.createManyAndReturn({
     *   select: { reward_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SponsorRewardCreateManyAndReturnArgs>(args?: SelectSubset<T, SponsorRewardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorRewardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SponsorReward.
     * @param {SponsorRewardDeleteArgs} args - Arguments to delete one SponsorReward.
     * @example
     * // Delete one SponsorReward
     * const SponsorReward = await prisma.sponsorReward.delete({
     *   where: {
     *     // ... filter to delete one SponsorReward
     *   }
     * })
     * 
     */
    delete<T extends SponsorRewardDeleteArgs>(args: SelectSubset<T, SponsorRewardDeleteArgs<ExtArgs>>): Prisma__SponsorRewardClient<$Result.GetResult<Prisma.$SponsorRewardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SponsorReward.
     * @param {SponsorRewardUpdateArgs} args - Arguments to update one SponsorReward.
     * @example
     * // Update one SponsorReward
     * const sponsorReward = await prisma.sponsorReward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SponsorRewardUpdateArgs>(args: SelectSubset<T, SponsorRewardUpdateArgs<ExtArgs>>): Prisma__SponsorRewardClient<$Result.GetResult<Prisma.$SponsorRewardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SponsorRewards.
     * @param {SponsorRewardDeleteManyArgs} args - Arguments to filter SponsorRewards to delete.
     * @example
     * // Delete a few SponsorRewards
     * const { count } = await prisma.sponsorReward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SponsorRewardDeleteManyArgs>(args?: SelectSubset<T, SponsorRewardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SponsorRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorRewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SponsorRewards
     * const sponsorReward = await prisma.sponsorReward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SponsorRewardUpdateManyArgs>(args: SelectSubset<T, SponsorRewardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SponsorRewards and returns the data updated in the database.
     * @param {SponsorRewardUpdateManyAndReturnArgs} args - Arguments to update many SponsorRewards.
     * @example
     * // Update many SponsorRewards
     * const sponsorReward = await prisma.sponsorReward.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SponsorRewards and only return the `reward_id`
     * const sponsorRewardWithReward_idOnly = await prisma.sponsorReward.updateManyAndReturn({
     *   select: { reward_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SponsorRewardUpdateManyAndReturnArgs>(args: SelectSubset<T, SponsorRewardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorRewardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SponsorReward.
     * @param {SponsorRewardUpsertArgs} args - Arguments to update or create a SponsorReward.
     * @example
     * // Update or create a SponsorReward
     * const sponsorReward = await prisma.sponsorReward.upsert({
     *   create: {
     *     // ... data to create a SponsorReward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SponsorReward we want to update
     *   }
     * })
     */
    upsert<T extends SponsorRewardUpsertArgs>(args: SelectSubset<T, SponsorRewardUpsertArgs<ExtArgs>>): Prisma__SponsorRewardClient<$Result.GetResult<Prisma.$SponsorRewardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SponsorRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorRewardCountArgs} args - Arguments to filter SponsorRewards to count.
     * @example
     * // Count the number of SponsorRewards
     * const count = await prisma.sponsorReward.count({
     *   where: {
     *     // ... the filter for the SponsorRewards we want to count
     *   }
     * })
    **/
    count<T extends SponsorRewardCountArgs>(
      args?: Subset<T, SponsorRewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SponsorRewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SponsorReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorRewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SponsorRewardAggregateArgs>(args: Subset<T, SponsorRewardAggregateArgs>): Prisma.PrismaPromise<GetSponsorRewardAggregateType<T>>

    /**
     * Group by SponsorReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorRewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SponsorRewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SponsorRewardGroupByArgs['orderBy'] }
        : { orderBy?: SponsorRewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SponsorRewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSponsorRewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SponsorReward model
   */
  readonly fields: SponsorRewardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SponsorReward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SponsorRewardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sponsor<T extends SponsorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SponsorDefaultArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    claims<T extends SponsorReward$claimsArgs<ExtArgs> = {}>(args?: Subset<T, SponsorReward$claimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRedemptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SponsorReward model
   */
  interface SponsorRewardFieldRefs {
    readonly reward_id: FieldRef<"SponsorReward", 'Int'>
    readonly sponsor_id: FieldRef<"SponsorReward", 'Int'>
    readonly title: FieldRef<"SponsorReward", 'String'>
    readonly description: FieldRef<"SponsorReward", 'String'>
    readonly points_cost: FieldRef<"SponsorReward", 'Int'>
    readonly quantity: FieldRef<"SponsorReward", 'Int'>
    readonly redeemed_count: FieldRef<"SponsorReward", 'Int'>
    readonly is_active: FieldRef<"SponsorReward", 'Boolean'>
    readonly display_on_leaderboard: FieldRef<"SponsorReward", 'Boolean'>
    readonly created_at: FieldRef<"SponsorReward", 'DateTime'>
    readonly updated_at: FieldRef<"SponsorReward", 'DateTime'>
    readonly expires_at: FieldRef<"SponsorReward", 'DateTime'>
    readonly deleted_at: FieldRef<"SponsorReward", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SponsorReward findUnique
   */
  export type SponsorRewardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsorReward
     */
    select?: SponsorRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsorReward
     */
    omit?: SponsorRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorRewardInclude<ExtArgs> | null
    /**
     * Filter, which SponsorReward to fetch.
     */
    where: SponsorRewardWhereUniqueInput
  }

  /**
   * SponsorReward findUniqueOrThrow
   */
  export type SponsorRewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsorReward
     */
    select?: SponsorRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsorReward
     */
    omit?: SponsorRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorRewardInclude<ExtArgs> | null
    /**
     * Filter, which SponsorReward to fetch.
     */
    where: SponsorRewardWhereUniqueInput
  }

  /**
   * SponsorReward findFirst
   */
  export type SponsorRewardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsorReward
     */
    select?: SponsorRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsorReward
     */
    omit?: SponsorRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorRewardInclude<ExtArgs> | null
    /**
     * Filter, which SponsorReward to fetch.
     */
    where?: SponsorRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SponsorRewards to fetch.
     */
    orderBy?: SponsorRewardOrderByWithRelationInput | SponsorRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SponsorRewards.
     */
    cursor?: SponsorRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SponsorRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SponsorRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SponsorRewards.
     */
    distinct?: SponsorRewardScalarFieldEnum | SponsorRewardScalarFieldEnum[]
  }

  /**
   * SponsorReward findFirstOrThrow
   */
  export type SponsorRewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsorReward
     */
    select?: SponsorRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsorReward
     */
    omit?: SponsorRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorRewardInclude<ExtArgs> | null
    /**
     * Filter, which SponsorReward to fetch.
     */
    where?: SponsorRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SponsorRewards to fetch.
     */
    orderBy?: SponsorRewardOrderByWithRelationInput | SponsorRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SponsorRewards.
     */
    cursor?: SponsorRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SponsorRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SponsorRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SponsorRewards.
     */
    distinct?: SponsorRewardScalarFieldEnum | SponsorRewardScalarFieldEnum[]
  }

  /**
   * SponsorReward findMany
   */
  export type SponsorRewardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsorReward
     */
    select?: SponsorRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsorReward
     */
    omit?: SponsorRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorRewardInclude<ExtArgs> | null
    /**
     * Filter, which SponsorRewards to fetch.
     */
    where?: SponsorRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SponsorRewards to fetch.
     */
    orderBy?: SponsorRewardOrderByWithRelationInput | SponsorRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SponsorRewards.
     */
    cursor?: SponsorRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SponsorRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SponsorRewards.
     */
    skip?: number
    distinct?: SponsorRewardScalarFieldEnum | SponsorRewardScalarFieldEnum[]
  }

  /**
   * SponsorReward create
   */
  export type SponsorRewardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsorReward
     */
    select?: SponsorRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsorReward
     */
    omit?: SponsorRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorRewardInclude<ExtArgs> | null
    /**
     * The data needed to create a SponsorReward.
     */
    data: XOR<SponsorRewardCreateInput, SponsorRewardUncheckedCreateInput>
  }

  /**
   * SponsorReward createMany
   */
  export type SponsorRewardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SponsorRewards.
     */
    data: SponsorRewardCreateManyInput | SponsorRewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SponsorReward createManyAndReturn
   */
  export type SponsorRewardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsorReward
     */
    select?: SponsorRewardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SponsorReward
     */
    omit?: SponsorRewardOmit<ExtArgs> | null
    /**
     * The data used to create many SponsorRewards.
     */
    data: SponsorRewardCreateManyInput | SponsorRewardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorRewardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SponsorReward update
   */
  export type SponsorRewardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsorReward
     */
    select?: SponsorRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsorReward
     */
    omit?: SponsorRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorRewardInclude<ExtArgs> | null
    /**
     * The data needed to update a SponsorReward.
     */
    data: XOR<SponsorRewardUpdateInput, SponsorRewardUncheckedUpdateInput>
    /**
     * Choose, which SponsorReward to update.
     */
    where: SponsorRewardWhereUniqueInput
  }

  /**
   * SponsorReward updateMany
   */
  export type SponsorRewardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SponsorRewards.
     */
    data: XOR<SponsorRewardUpdateManyMutationInput, SponsorRewardUncheckedUpdateManyInput>
    /**
     * Filter which SponsorRewards to update
     */
    where?: SponsorRewardWhereInput
    /**
     * Limit how many SponsorRewards to update.
     */
    limit?: number
  }

  /**
   * SponsorReward updateManyAndReturn
   */
  export type SponsorRewardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsorReward
     */
    select?: SponsorRewardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SponsorReward
     */
    omit?: SponsorRewardOmit<ExtArgs> | null
    /**
     * The data used to update SponsorRewards.
     */
    data: XOR<SponsorRewardUpdateManyMutationInput, SponsorRewardUncheckedUpdateManyInput>
    /**
     * Filter which SponsorRewards to update
     */
    where?: SponsorRewardWhereInput
    /**
     * Limit how many SponsorRewards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorRewardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SponsorReward upsert
   */
  export type SponsorRewardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsorReward
     */
    select?: SponsorRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsorReward
     */
    omit?: SponsorRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorRewardInclude<ExtArgs> | null
    /**
     * The filter to search for the SponsorReward to update in case it exists.
     */
    where: SponsorRewardWhereUniqueInput
    /**
     * In case the SponsorReward found by the `where` argument doesn't exist, create a new SponsorReward with this data.
     */
    create: XOR<SponsorRewardCreateInput, SponsorRewardUncheckedCreateInput>
    /**
     * In case the SponsorReward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SponsorRewardUpdateInput, SponsorRewardUncheckedUpdateInput>
  }

  /**
   * SponsorReward delete
   */
  export type SponsorRewardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsorReward
     */
    select?: SponsorRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsorReward
     */
    omit?: SponsorRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorRewardInclude<ExtArgs> | null
    /**
     * Filter which SponsorReward to delete.
     */
    where: SponsorRewardWhereUniqueInput
  }

  /**
   * SponsorReward deleteMany
   */
  export type SponsorRewardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SponsorRewards to delete
     */
    where?: SponsorRewardWhereInput
    /**
     * Limit how many SponsorRewards to delete.
     */
    limit?: number
  }

  /**
   * SponsorReward.claims
   */
  export type SponsorReward$claimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRedemption
     */
    select?: UserRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRedemption
     */
    omit?: UserRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRedemptionInclude<ExtArgs> | null
    where?: UserRedemptionWhereInput
    orderBy?: UserRedemptionOrderByWithRelationInput | UserRedemptionOrderByWithRelationInput[]
    cursor?: UserRedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRedemptionScalarFieldEnum | UserRedemptionScalarFieldEnum[]
  }

  /**
   * SponsorReward without action
   */
  export type SponsorRewardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsorReward
     */
    select?: SponsorRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsorReward
     */
    omit?: SponsorRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorRewardInclude<ExtArgs> | null
  }


  /**
   * Model UserRedemption
   */

  export type AggregateUserRedemption = {
    _count: UserRedemptionCountAggregateOutputType | null
    _avg: UserRedemptionAvgAggregateOutputType | null
    _sum: UserRedemptionSumAggregateOutputType | null
    _min: UserRedemptionMinAggregateOutputType | null
    _max: UserRedemptionMaxAggregateOutputType | null
  }

  export type UserRedemptionAvgAggregateOutputType = {
    redemption_id: number | null
    user_id: number | null
    reward_id: number | null
  }

  export type UserRedemptionSumAggregateOutputType = {
    redemption_id: number | null
    user_id: number | null
    reward_id: number | null
  }

  export type UserRedemptionMinAggregateOutputType = {
    redemption_id: number | null
    user_id: number | null
    reward_id: number | null
    status: $Enums.RedemptionStatus | null
    claimed_at: Date | null
    fulfilled_at: Date | null
    deleted_at: Date | null
  }

  export type UserRedemptionMaxAggregateOutputType = {
    redemption_id: number | null
    user_id: number | null
    reward_id: number | null
    status: $Enums.RedemptionStatus | null
    claimed_at: Date | null
    fulfilled_at: Date | null
    deleted_at: Date | null
  }

  export type UserRedemptionCountAggregateOutputType = {
    redemption_id: number
    user_id: number
    reward_id: number
    status: number
    claimed_at: number
    fulfilled_at: number
    deleted_at: number
    _all: number
  }


  export type UserRedemptionAvgAggregateInputType = {
    redemption_id?: true
    user_id?: true
    reward_id?: true
  }

  export type UserRedemptionSumAggregateInputType = {
    redemption_id?: true
    user_id?: true
    reward_id?: true
  }

  export type UserRedemptionMinAggregateInputType = {
    redemption_id?: true
    user_id?: true
    reward_id?: true
    status?: true
    claimed_at?: true
    fulfilled_at?: true
    deleted_at?: true
  }

  export type UserRedemptionMaxAggregateInputType = {
    redemption_id?: true
    user_id?: true
    reward_id?: true
    status?: true
    claimed_at?: true
    fulfilled_at?: true
    deleted_at?: true
  }

  export type UserRedemptionCountAggregateInputType = {
    redemption_id?: true
    user_id?: true
    reward_id?: true
    status?: true
    claimed_at?: true
    fulfilled_at?: true
    deleted_at?: true
    _all?: true
  }

  export type UserRedemptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRedemption to aggregate.
     */
    where?: UserRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRedemptions to fetch.
     */
    orderBy?: UserRedemptionOrderByWithRelationInput | UserRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRedemptions
    **/
    _count?: true | UserRedemptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRedemptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRedemptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRedemptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRedemptionMaxAggregateInputType
  }

  export type GetUserRedemptionAggregateType<T extends UserRedemptionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRedemption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRedemption[P]>
      : GetScalarType<T[P], AggregateUserRedemption[P]>
  }




  export type UserRedemptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRedemptionWhereInput
    orderBy?: UserRedemptionOrderByWithAggregationInput | UserRedemptionOrderByWithAggregationInput[]
    by: UserRedemptionScalarFieldEnum[] | UserRedemptionScalarFieldEnum
    having?: UserRedemptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRedemptionCountAggregateInputType | true
    _avg?: UserRedemptionAvgAggregateInputType
    _sum?: UserRedemptionSumAggregateInputType
    _min?: UserRedemptionMinAggregateInputType
    _max?: UserRedemptionMaxAggregateInputType
  }

  export type UserRedemptionGroupByOutputType = {
    redemption_id: number
    user_id: number
    reward_id: number
    status: $Enums.RedemptionStatus
    claimed_at: Date
    fulfilled_at: Date | null
    deleted_at: Date | null
    _count: UserRedemptionCountAggregateOutputType | null
    _avg: UserRedemptionAvgAggregateOutputType | null
    _sum: UserRedemptionSumAggregateOutputType | null
    _min: UserRedemptionMinAggregateOutputType | null
    _max: UserRedemptionMaxAggregateOutputType | null
  }

  type GetUserRedemptionGroupByPayload<T extends UserRedemptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRedemptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRedemptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRedemptionGroupByOutputType[P]>
            : GetScalarType<T[P], UserRedemptionGroupByOutputType[P]>
        }
      >
    >


  export type UserRedemptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    redemption_id?: boolean
    user_id?: boolean
    reward_id?: boolean
    status?: boolean
    claimed_at?: boolean
    fulfilled_at?: boolean
    deleted_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    reward?: boolean | SponsorRewardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRedemption"]>

  export type UserRedemptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    redemption_id?: boolean
    user_id?: boolean
    reward_id?: boolean
    status?: boolean
    claimed_at?: boolean
    fulfilled_at?: boolean
    deleted_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    reward?: boolean | SponsorRewardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRedemption"]>

  export type UserRedemptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    redemption_id?: boolean
    user_id?: boolean
    reward_id?: boolean
    status?: boolean
    claimed_at?: boolean
    fulfilled_at?: boolean
    deleted_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    reward?: boolean | SponsorRewardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRedemption"]>

  export type UserRedemptionSelectScalar = {
    redemption_id?: boolean
    user_id?: boolean
    reward_id?: boolean
    status?: boolean
    claimed_at?: boolean
    fulfilled_at?: boolean
    deleted_at?: boolean
  }

  export type UserRedemptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"redemption_id" | "user_id" | "reward_id" | "status" | "claimed_at" | "fulfilled_at" | "deleted_at", ExtArgs["result"]["userRedemption"]>
  export type UserRedemptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    reward?: boolean | SponsorRewardDefaultArgs<ExtArgs>
  }
  export type UserRedemptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    reward?: boolean | SponsorRewardDefaultArgs<ExtArgs>
  }
  export type UserRedemptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    reward?: boolean | SponsorRewardDefaultArgs<ExtArgs>
  }

  export type $UserRedemptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRedemption"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      reward: Prisma.$SponsorRewardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      redemption_id: number
      user_id: number
      reward_id: number
      status: $Enums.RedemptionStatus
      claimed_at: Date
      fulfilled_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["userRedemption"]>
    composites: {}
  }

  type UserRedemptionGetPayload<S extends boolean | null | undefined | UserRedemptionDefaultArgs> = $Result.GetResult<Prisma.$UserRedemptionPayload, S>

  type UserRedemptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRedemptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRedemptionCountAggregateInputType | true
    }

  export interface UserRedemptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRedemption'], meta: { name: 'UserRedemption' } }
    /**
     * Find zero or one UserRedemption that matches the filter.
     * @param {UserRedemptionFindUniqueArgs} args - Arguments to find a UserRedemption
     * @example
     * // Get one UserRedemption
     * const userRedemption = await prisma.userRedemption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRedemptionFindUniqueArgs>(args: SelectSubset<T, UserRedemptionFindUniqueArgs<ExtArgs>>): Prisma__UserRedemptionClient<$Result.GetResult<Prisma.$UserRedemptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRedemption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRedemptionFindUniqueOrThrowArgs} args - Arguments to find a UserRedemption
     * @example
     * // Get one UserRedemption
     * const userRedemption = await prisma.userRedemption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRedemptionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRedemptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRedemptionClient<$Result.GetResult<Prisma.$UserRedemptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRedemption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRedemptionFindFirstArgs} args - Arguments to find a UserRedemption
     * @example
     * // Get one UserRedemption
     * const userRedemption = await prisma.userRedemption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRedemptionFindFirstArgs>(args?: SelectSubset<T, UserRedemptionFindFirstArgs<ExtArgs>>): Prisma__UserRedemptionClient<$Result.GetResult<Prisma.$UserRedemptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRedemption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRedemptionFindFirstOrThrowArgs} args - Arguments to find a UserRedemption
     * @example
     * // Get one UserRedemption
     * const userRedemption = await prisma.userRedemption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRedemptionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRedemptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRedemptionClient<$Result.GetResult<Prisma.$UserRedemptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRedemptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRedemptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRedemptions
     * const userRedemptions = await prisma.userRedemption.findMany()
     * 
     * // Get first 10 UserRedemptions
     * const userRedemptions = await prisma.userRedemption.findMany({ take: 10 })
     * 
     * // Only select the `redemption_id`
     * const userRedemptionWithRedemption_idOnly = await prisma.userRedemption.findMany({ select: { redemption_id: true } })
     * 
     */
    findMany<T extends UserRedemptionFindManyArgs>(args?: SelectSubset<T, UserRedemptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRedemptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRedemption.
     * @param {UserRedemptionCreateArgs} args - Arguments to create a UserRedemption.
     * @example
     * // Create one UserRedemption
     * const UserRedemption = await prisma.userRedemption.create({
     *   data: {
     *     // ... data to create a UserRedemption
     *   }
     * })
     * 
     */
    create<T extends UserRedemptionCreateArgs>(args: SelectSubset<T, UserRedemptionCreateArgs<ExtArgs>>): Prisma__UserRedemptionClient<$Result.GetResult<Prisma.$UserRedemptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRedemptions.
     * @param {UserRedemptionCreateManyArgs} args - Arguments to create many UserRedemptions.
     * @example
     * // Create many UserRedemptions
     * const userRedemption = await prisma.userRedemption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRedemptionCreateManyArgs>(args?: SelectSubset<T, UserRedemptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRedemptions and returns the data saved in the database.
     * @param {UserRedemptionCreateManyAndReturnArgs} args - Arguments to create many UserRedemptions.
     * @example
     * // Create many UserRedemptions
     * const userRedemption = await prisma.userRedemption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRedemptions and only return the `redemption_id`
     * const userRedemptionWithRedemption_idOnly = await prisma.userRedemption.createManyAndReturn({
     *   select: { redemption_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRedemptionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRedemptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRedemptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRedemption.
     * @param {UserRedemptionDeleteArgs} args - Arguments to delete one UserRedemption.
     * @example
     * // Delete one UserRedemption
     * const UserRedemption = await prisma.userRedemption.delete({
     *   where: {
     *     // ... filter to delete one UserRedemption
     *   }
     * })
     * 
     */
    delete<T extends UserRedemptionDeleteArgs>(args: SelectSubset<T, UserRedemptionDeleteArgs<ExtArgs>>): Prisma__UserRedemptionClient<$Result.GetResult<Prisma.$UserRedemptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRedemption.
     * @param {UserRedemptionUpdateArgs} args - Arguments to update one UserRedemption.
     * @example
     * // Update one UserRedemption
     * const userRedemption = await prisma.userRedemption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRedemptionUpdateArgs>(args: SelectSubset<T, UserRedemptionUpdateArgs<ExtArgs>>): Prisma__UserRedemptionClient<$Result.GetResult<Prisma.$UserRedemptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRedemptions.
     * @param {UserRedemptionDeleteManyArgs} args - Arguments to filter UserRedemptions to delete.
     * @example
     * // Delete a few UserRedemptions
     * const { count } = await prisma.userRedemption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRedemptionDeleteManyArgs>(args?: SelectSubset<T, UserRedemptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRedemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRedemptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRedemptions
     * const userRedemption = await prisma.userRedemption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRedemptionUpdateManyArgs>(args: SelectSubset<T, UserRedemptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRedemptions and returns the data updated in the database.
     * @param {UserRedemptionUpdateManyAndReturnArgs} args - Arguments to update many UserRedemptions.
     * @example
     * // Update many UserRedemptions
     * const userRedemption = await prisma.userRedemption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRedemptions and only return the `redemption_id`
     * const userRedemptionWithRedemption_idOnly = await prisma.userRedemption.updateManyAndReturn({
     *   select: { redemption_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRedemptionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRedemptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRedemptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRedemption.
     * @param {UserRedemptionUpsertArgs} args - Arguments to update or create a UserRedemption.
     * @example
     * // Update or create a UserRedemption
     * const userRedemption = await prisma.userRedemption.upsert({
     *   create: {
     *     // ... data to create a UserRedemption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRedemption we want to update
     *   }
     * })
     */
    upsert<T extends UserRedemptionUpsertArgs>(args: SelectSubset<T, UserRedemptionUpsertArgs<ExtArgs>>): Prisma__UserRedemptionClient<$Result.GetResult<Prisma.$UserRedemptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRedemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRedemptionCountArgs} args - Arguments to filter UserRedemptions to count.
     * @example
     * // Count the number of UserRedemptions
     * const count = await prisma.userRedemption.count({
     *   where: {
     *     // ... the filter for the UserRedemptions we want to count
     *   }
     * })
    **/
    count<T extends UserRedemptionCountArgs>(
      args?: Subset<T, UserRedemptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRedemptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRedemption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRedemptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRedemptionAggregateArgs>(args: Subset<T, UserRedemptionAggregateArgs>): Prisma.PrismaPromise<GetUserRedemptionAggregateType<T>>

    /**
     * Group by UserRedemption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRedemptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRedemptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRedemptionGroupByArgs['orderBy'] }
        : { orderBy?: UserRedemptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRedemptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRedemptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRedemption model
   */
  readonly fields: UserRedemptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRedemption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRedemptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reward<T extends SponsorRewardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SponsorRewardDefaultArgs<ExtArgs>>): Prisma__SponsorRewardClient<$Result.GetResult<Prisma.$SponsorRewardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRedemption model
   */
  interface UserRedemptionFieldRefs {
    readonly redemption_id: FieldRef<"UserRedemption", 'Int'>
    readonly user_id: FieldRef<"UserRedemption", 'Int'>
    readonly reward_id: FieldRef<"UserRedemption", 'Int'>
    readonly status: FieldRef<"UserRedemption", 'RedemptionStatus'>
    readonly claimed_at: FieldRef<"UserRedemption", 'DateTime'>
    readonly fulfilled_at: FieldRef<"UserRedemption", 'DateTime'>
    readonly deleted_at: FieldRef<"UserRedemption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserRedemption findUnique
   */
  export type UserRedemptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRedemption
     */
    select?: UserRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRedemption
     */
    omit?: UserRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which UserRedemption to fetch.
     */
    where: UserRedemptionWhereUniqueInput
  }

  /**
   * UserRedemption findUniqueOrThrow
   */
  export type UserRedemptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRedemption
     */
    select?: UserRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRedemption
     */
    omit?: UserRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which UserRedemption to fetch.
     */
    where: UserRedemptionWhereUniqueInput
  }

  /**
   * UserRedemption findFirst
   */
  export type UserRedemptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRedemption
     */
    select?: UserRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRedemption
     */
    omit?: UserRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which UserRedemption to fetch.
     */
    where?: UserRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRedemptions to fetch.
     */
    orderBy?: UserRedemptionOrderByWithRelationInput | UserRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRedemptions.
     */
    cursor?: UserRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRedemptions.
     */
    distinct?: UserRedemptionScalarFieldEnum | UserRedemptionScalarFieldEnum[]
  }

  /**
   * UserRedemption findFirstOrThrow
   */
  export type UserRedemptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRedemption
     */
    select?: UserRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRedemption
     */
    omit?: UserRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which UserRedemption to fetch.
     */
    where?: UserRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRedemptions to fetch.
     */
    orderBy?: UserRedemptionOrderByWithRelationInput | UserRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRedemptions.
     */
    cursor?: UserRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRedemptions.
     */
    distinct?: UserRedemptionScalarFieldEnum | UserRedemptionScalarFieldEnum[]
  }

  /**
   * UserRedemption findMany
   */
  export type UserRedemptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRedemption
     */
    select?: UserRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRedemption
     */
    omit?: UserRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which UserRedemptions to fetch.
     */
    where?: UserRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRedemptions to fetch.
     */
    orderBy?: UserRedemptionOrderByWithRelationInput | UserRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRedemptions.
     */
    cursor?: UserRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRedemptions.
     */
    skip?: number
    distinct?: UserRedemptionScalarFieldEnum | UserRedemptionScalarFieldEnum[]
  }

  /**
   * UserRedemption create
   */
  export type UserRedemptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRedemption
     */
    select?: UserRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRedemption
     */
    omit?: UserRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRedemptionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRedemption.
     */
    data: XOR<UserRedemptionCreateInput, UserRedemptionUncheckedCreateInput>
  }

  /**
   * UserRedemption createMany
   */
  export type UserRedemptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRedemptions.
     */
    data: UserRedemptionCreateManyInput | UserRedemptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRedemption createManyAndReturn
   */
  export type UserRedemptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRedemption
     */
    select?: UserRedemptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRedemption
     */
    omit?: UserRedemptionOmit<ExtArgs> | null
    /**
     * The data used to create many UserRedemptions.
     */
    data: UserRedemptionCreateManyInput | UserRedemptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRedemptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRedemption update
   */
  export type UserRedemptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRedemption
     */
    select?: UserRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRedemption
     */
    omit?: UserRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRedemptionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRedemption.
     */
    data: XOR<UserRedemptionUpdateInput, UserRedemptionUncheckedUpdateInput>
    /**
     * Choose, which UserRedemption to update.
     */
    where: UserRedemptionWhereUniqueInput
  }

  /**
   * UserRedemption updateMany
   */
  export type UserRedemptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRedemptions.
     */
    data: XOR<UserRedemptionUpdateManyMutationInput, UserRedemptionUncheckedUpdateManyInput>
    /**
     * Filter which UserRedemptions to update
     */
    where?: UserRedemptionWhereInput
    /**
     * Limit how many UserRedemptions to update.
     */
    limit?: number
  }

  /**
   * UserRedemption updateManyAndReturn
   */
  export type UserRedemptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRedemption
     */
    select?: UserRedemptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRedemption
     */
    omit?: UserRedemptionOmit<ExtArgs> | null
    /**
     * The data used to update UserRedemptions.
     */
    data: XOR<UserRedemptionUpdateManyMutationInput, UserRedemptionUncheckedUpdateManyInput>
    /**
     * Filter which UserRedemptions to update
     */
    where?: UserRedemptionWhereInput
    /**
     * Limit how many UserRedemptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRedemptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRedemption upsert
   */
  export type UserRedemptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRedemption
     */
    select?: UserRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRedemption
     */
    omit?: UserRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRedemptionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRedemption to update in case it exists.
     */
    where: UserRedemptionWhereUniqueInput
    /**
     * In case the UserRedemption found by the `where` argument doesn't exist, create a new UserRedemption with this data.
     */
    create: XOR<UserRedemptionCreateInput, UserRedemptionUncheckedCreateInput>
    /**
     * In case the UserRedemption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRedemptionUpdateInput, UserRedemptionUncheckedUpdateInput>
  }

  /**
   * UserRedemption delete
   */
  export type UserRedemptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRedemption
     */
    select?: UserRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRedemption
     */
    omit?: UserRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRedemptionInclude<ExtArgs> | null
    /**
     * Filter which UserRedemption to delete.
     */
    where: UserRedemptionWhereUniqueInput
  }

  /**
   * UserRedemption deleteMany
   */
  export type UserRedemptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRedemptions to delete
     */
    where?: UserRedemptionWhereInput
    /**
     * Limit how many UserRedemptions to delete.
     */
    limit?: number
  }

  /**
   * UserRedemption without action
   */
  export type UserRedemptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRedemption
     */
    select?: UserRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRedemption
     */
    omit?: UserRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRedemptionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    user_id: 'user_id',
    username: 'username',
    email: 'email',
    password_hash: 'password_hash',
    role: 'role',
    is_email_verified: 'is_email_verified',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    user_id: 'user_id',
    full_name: 'full_name',
    bio: 'bio',
    profile_picture_url: 'profile_picture_url',
    points: 'points',
    total_waste_kg: 'total_waste_kg',
    skipped_challenges: 'skipped_challenges',
    home_dashboard_layout: 'home_dashboard_layout',
    deleted_at: 'deleted_at'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    token_id: 'token_id',
    user_id: 'user_id',
    token_hash: 'token_hash',
    expires_at: 'expires_at',
    created_at: 'created_at',
    last_used: 'last_used',
    deleted_at: 'deleted_at'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const CraftIdeaScalarFieldEnum: {
    idea_id: 'idea_id',
    generated_by_user_id: 'generated_by_user_id',
    idea_json: 'idea_json',
    recycled_materials: 'recycled_materials',
    generated_image_url: 'generated_image_url',
    is_saved: 'is_saved',
    created_at: 'created_at',
    deleted_at: 'deleted_at'
  };

  export type CraftIdeaScalarFieldEnum = (typeof CraftIdeaScalarFieldEnum)[keyof typeof CraftIdeaScalarFieldEnum]


  export const ChatbotConversationScalarFieldEnum: {
    conversation_id: 'conversation_id',
    user_id: 'user_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type ChatbotConversationScalarFieldEnum = (typeof ChatbotConversationScalarFieldEnum)[keyof typeof ChatbotConversationScalarFieldEnum]


  export const ChatbotMessageScalarFieldEnum: {
    message_id: 'message_id',
    conversation_id: 'conversation_id',
    sender: 'sender',
    content: 'content',
    created_at: 'created_at',
    deleted_at: 'deleted_at'
  };

  export type ChatbotMessageScalarFieldEnum = (typeof ChatbotMessageScalarFieldEnum)[keyof typeof ChatbotMessageScalarFieldEnum]


  export const PostScalarFieldEnum: {
    post_id: 'post_id',
    user_id: 'user_id',
    title: 'title',
    content: 'content',
    image_url: 'image_url',
    tags: 'tags',
    category: 'category',
    featured: 'featured',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    comment_id: 'comment_id',
    post_id: 'post_id',
    user_id: 'user_id',
    content: 'content',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const LikeScalarFieldEnum: {
    like_id: 'like_id',
    post_id: 'post_id',
    user_id: 'user_id',
    created_at: 'created_at',
    deleted_at: 'deleted_at'
  };

  export type LikeScalarFieldEnum = (typeof LikeScalarFieldEnum)[keyof typeof LikeScalarFieldEnum]


  export const EcoChallengeScalarFieldEnum: {
    challenge_id: 'challenge_id',
    title: 'title',
    description: 'description',
    points_reward: 'points_reward',
    waste_kg: 'waste_kg',
    is_active: 'is_active',
    source: 'source',
    material_type: 'material_type',
    category: 'category',
    created_by_admin_id: 'created_by_admin_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    start_at: 'start_at',
    expires_at: 'expires_at'
  };

  export type EcoChallengeScalarFieldEnum = (typeof EcoChallengeScalarFieldEnum)[keyof typeof EcoChallengeScalarFieldEnum]


  export const UserChallengeScalarFieldEnum: {
    user_challenge_id: 'user_challenge_id',
    user_id: 'user_id',
    challenge_id: 'challenge_id',
    status: 'status',
    proof_url: 'proof_url',
    completed_at: 'completed_at',
    verified_at: 'verified_at',
    verified_by_admin_id: 'verified_by_admin_id',
    verification_type: 'verification_type',
    ai_confidence_score: 'ai_confidence_score',
    points_awarded: 'points_awarded',
    waste_kg_saved: 'waste_kg_saved',
    admin_notes: 'admin_notes',
    created_at: 'created_at',
    deleted_at: 'deleted_at',
    skipped_at: 'skipped_at'
  };

  export type UserChallengeScalarFieldEnum = (typeof UserChallengeScalarFieldEnum)[keyof typeof UserChallengeScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    report_id: 'report_id',
    reporter_id: 'reporter_id',
    reported_post_id: 'reported_post_id',
    reported_comment_id: 'reported_comment_id',
    reason: 'reason',
    status: 'status',
    moderator_notes: 'moderator_notes',
    resolved_by_admin_id: 'resolved_by_admin_id',
    created_at: 'created_at',
    resolved_at: 'resolved_at',
    deleted_at: 'deleted_at'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const AnnouncementScalarFieldEnum: {
    announcement_id: 'announcement_id',
    admin_id: 'admin_id',
    title: 'title',
    content: 'content',
    is_active: 'is_active',
    created_at: 'created_at',
    expires_at: 'expires_at',
    deleted_at: 'deleted_at'
  };

  export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


  export const ModerationLogScalarFieldEnum: {
    log_id: 'log_id',
    admin_id: 'admin_id',
    action: 'action',
    target_id: 'target_id',
    target_user_id: 'target_user_id',
    reason: 'reason',
    created_at: 'created_at',
    deleted_at: 'deleted_at'
  };

  export type ModerationLogScalarFieldEnum = (typeof ModerationLogScalarFieldEnum)[keyof typeof ModerationLogScalarFieldEnum]


  export const SponsorScalarFieldEnum: {
    sponsor_id: 'sponsor_id',
    name: 'name',
    logo_url: 'logo_url',
    description: 'description',
    contact_email: 'contact_email',
    is_active: 'is_active',
    created_by_admin_id: 'created_by_admin_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type SponsorScalarFieldEnum = (typeof SponsorScalarFieldEnum)[keyof typeof SponsorScalarFieldEnum]


  export const SponsorRewardScalarFieldEnum: {
    reward_id: 'reward_id',
    sponsor_id: 'sponsor_id',
    title: 'title',
    description: 'description',
    points_cost: 'points_cost',
    quantity: 'quantity',
    redeemed_count: 'redeemed_count',
    is_active: 'is_active',
    display_on_leaderboard: 'display_on_leaderboard',
    created_at: 'created_at',
    updated_at: 'updated_at',
    expires_at: 'expires_at',
    deleted_at: 'deleted_at'
  };

  export type SponsorRewardScalarFieldEnum = (typeof SponsorRewardScalarFieldEnum)[keyof typeof SponsorRewardScalarFieldEnum]


  export const UserRedemptionScalarFieldEnum: {
    redemption_id: 'redemption_id',
    user_id: 'user_id',
    reward_id: 'reward_id',
    status: 'status',
    claimed_at: 'claimed_at',
    fulfilled_at: 'fulfilled_at',
    deleted_at: 'deleted_at'
  };

  export type UserRedemptionScalarFieldEnum = (typeof UserRedemptionScalarFieldEnum)[keyof typeof UserRedemptionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'MessageSender'
   */
  export type EnumMessageSenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageSender'>
    


  /**
   * Reference to a field of type 'MessageSender[]'
   */
  export type ListEnumMessageSenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageSender[]'>
    


  /**
   * Reference to a field of type 'Category'
   */
  export type EnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category'>
    


  /**
   * Reference to a field of type 'Category[]'
   */
  export type ListEnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category[]'>
    


  /**
   * Reference to a field of type 'ChallengeSource'
   */
  export type EnumChallengeSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeSource'>
    


  /**
   * Reference to a field of type 'ChallengeSource[]'
   */
  export type ListEnumChallengeSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeSource[]'>
    


  /**
   * Reference to a field of type 'MaterialType'
   */
  export type EnumMaterialTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaterialType'>
    


  /**
   * Reference to a field of type 'MaterialType[]'
   */
  export type ListEnumMaterialTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaterialType[]'>
    


  /**
   * Reference to a field of type 'ChallengeCategory'
   */
  export type EnumChallengeCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeCategory'>
    


  /**
   * Reference to a field of type 'ChallengeCategory[]'
   */
  export type ListEnumChallengeCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeCategory[]'>
    


  /**
   * Reference to a field of type 'ChallengeStatus'
   */
  export type EnumChallengeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeStatus'>
    


  /**
   * Reference to a field of type 'ChallengeStatus[]'
   */
  export type ListEnumChallengeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeStatus[]'>
    


  /**
   * Reference to a field of type 'VerificationType'
   */
  export type EnumVerificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationType'>
    


  /**
   * Reference to a field of type 'VerificationType[]'
   */
  export type ListEnumVerificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationType[]'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'ReportStatus[]'
   */
  export type ListEnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus[]'>
    


  /**
   * Reference to a field of type 'ModerationAction'
   */
  export type EnumModerationActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModerationAction'>
    


  /**
   * Reference to a field of type 'ModerationAction[]'
   */
  export type ListEnumModerationActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModerationAction[]'>
    


  /**
   * Reference to a field of type 'RedemptionStatus'
   */
  export type EnumRedemptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RedemptionStatus'>
    


  /**
   * Reference to a field of type 'RedemptionStatus[]'
   */
  export type ListEnumRedemptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RedemptionStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    user_id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password_hash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    is_email_verified?: BoolFilter<"User"> | boolean
    is_active?: BoolFilter<"User"> | boolean
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    deleted_at?: DateTimeNullableFilter<"User"> | Date | string | null
    announcements?: AnnouncementListRelationFilter
    chatbotConversations?: XOR<ChatbotConversationNullableScalarRelationFilter, ChatbotConversationWhereInput> | null
    comments?: CommentListRelationFilter
    craftIdeas?: CraftIdeaListRelationFilter
    createdChallenges?: EcoChallengeListRelationFilter
    likes?: LikeListRelationFilter
    moderationLogs?: ModerationLogListRelationFilter
    moderationTargets?: ModerationLogListRelationFilter
    posts?: PostListRelationFilter
    reportsFiled?: ReportListRelationFilter
    reportsResolved?: ReportListRelationFilter
    userChallenges?: UserChallengeListRelationFilter
    verifiedChallenges?: UserChallengeListRelationFilter
    profile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
    refreshTokens?: RefreshTokenListRelationFilter
    createdSponsors?: SponsorListRelationFilter
    redemptions?: UserRedemptionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    user_id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_email_verified?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    announcements?: AnnouncementOrderByRelationAggregateInput
    chatbotConversations?: ChatbotConversationOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    craftIdeas?: CraftIdeaOrderByRelationAggregateInput
    createdChallenges?: EcoChallengeOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
    moderationLogs?: ModerationLogOrderByRelationAggregateInput
    moderationTargets?: ModerationLogOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    reportsFiled?: ReportOrderByRelationAggregateInput
    reportsResolved?: ReportOrderByRelationAggregateInput
    userChallenges?: UserChallengeOrderByRelationAggregateInput
    verifiedChallenges?: UserChallengeOrderByRelationAggregateInput
    profile?: UserProfileOrderByWithRelationInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    createdSponsors?: SponsorOrderByRelationAggregateInput
    redemptions?: UserRedemptionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    user_id?: number
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password_hash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    is_email_verified?: BoolFilter<"User"> | boolean
    is_active?: BoolFilter<"User"> | boolean
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    deleted_at?: DateTimeNullableFilter<"User"> | Date | string | null
    announcements?: AnnouncementListRelationFilter
    chatbotConversations?: XOR<ChatbotConversationNullableScalarRelationFilter, ChatbotConversationWhereInput> | null
    comments?: CommentListRelationFilter
    craftIdeas?: CraftIdeaListRelationFilter
    createdChallenges?: EcoChallengeListRelationFilter
    likes?: LikeListRelationFilter
    moderationLogs?: ModerationLogListRelationFilter
    moderationTargets?: ModerationLogListRelationFilter
    posts?: PostListRelationFilter
    reportsFiled?: ReportListRelationFilter
    reportsResolved?: ReportListRelationFilter
    userChallenges?: UserChallengeListRelationFilter
    verifiedChallenges?: UserChallengeListRelationFilter
    profile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
    refreshTokens?: RefreshTokenListRelationFilter
    createdSponsors?: SponsorListRelationFilter
    redemptions?: UserRedemptionListRelationFilter
  }, "user_id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    user_id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_email_verified?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password_hash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    is_email_verified?: BoolWithAggregatesFilter<"User"> | boolean
    is_active?: BoolWithAggregatesFilter<"User"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    user_id?: IntFilter<"UserProfile"> | number
    full_name?: StringNullableFilter<"UserProfile"> | string | null
    bio?: StringNullableFilter<"UserProfile"> | string | null
    profile_picture_url?: StringNullableFilter<"UserProfile"> | string | null
    points?: IntFilter<"UserProfile"> | number
    total_waste_kg?: FloatFilter<"UserProfile"> | number
    skipped_challenges?: IntNullableListFilter<"UserProfile">
    home_dashboard_layout?: JsonNullableFilter<"UserProfile">
    deleted_at?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserProfileOrderByWithRelationInput = {
    user_id?: SortOrder
    full_name?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    profile_picture_url?: SortOrderInput | SortOrder
    points?: SortOrder
    total_waste_kg?: SortOrder
    skipped_challenges?: SortOrder
    home_dashboard_layout?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    user_id?: number
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    full_name?: StringNullableFilter<"UserProfile"> | string | null
    bio?: StringNullableFilter<"UserProfile"> | string | null
    profile_picture_url?: StringNullableFilter<"UserProfile"> | string | null
    points?: IntFilter<"UserProfile"> | number
    total_waste_kg?: FloatFilter<"UserProfile"> | number
    skipped_challenges?: IntNullableListFilter<"UserProfile">
    home_dashboard_layout?: JsonNullableFilter<"UserProfile">
    deleted_at?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "user_id">

  export type UserProfileOrderByWithAggregationInput = {
    user_id?: SortOrder
    full_name?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    profile_picture_url?: SortOrderInput | SortOrder
    points?: SortOrder
    total_waste_kg?: SortOrder
    skipped_challenges?: SortOrder
    home_dashboard_layout?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _avg?: UserProfileAvgOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
    _sum?: UserProfileSumOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"UserProfile"> | number
    full_name?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    bio?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    profile_picture_url?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    points?: IntWithAggregatesFilter<"UserProfile"> | number
    total_waste_kg?: FloatWithAggregatesFilter<"UserProfile"> | number
    skipped_challenges?: IntNullableListFilter<"UserProfile">
    home_dashboard_layout?: JsonNullableWithAggregatesFilter<"UserProfile">
    deleted_at?: DateTimeNullableWithAggregatesFilter<"UserProfile"> | Date | string | null
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    token_id?: IntFilter<"RefreshToken"> | number
    user_id?: IntFilter<"RefreshToken"> | number
    token_hash?: StringFilter<"RefreshToken"> | string
    expires_at?: DateTimeFilter<"RefreshToken"> | Date | string
    created_at?: DateTimeFilter<"RefreshToken"> | Date | string
    last_used?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    token_id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    token_id?: number
    token_hash?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    user_id?: IntFilter<"RefreshToken"> | number
    expires_at?: DateTimeFilter<"RefreshToken"> | Date | string
    created_at?: DateTimeFilter<"RefreshToken"> | Date | string
    last_used?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "token_id" | "token_hash">

  export type RefreshTokenOrderByWithAggregationInput = {
    token_id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _avg?: RefreshTokenAvgOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
    _sum?: RefreshTokenSumOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    token_id?: IntWithAggregatesFilter<"RefreshToken"> | number
    user_id?: IntWithAggregatesFilter<"RefreshToken"> | number
    token_hash?: StringWithAggregatesFilter<"RefreshToken"> | string
    expires_at?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    last_used?: DateTimeNullableWithAggregatesFilter<"RefreshToken"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"RefreshToken"> | Date | string | null
  }

  export type CraftIdeaWhereInput = {
    AND?: CraftIdeaWhereInput | CraftIdeaWhereInput[]
    OR?: CraftIdeaWhereInput[]
    NOT?: CraftIdeaWhereInput | CraftIdeaWhereInput[]
    idea_id?: IntFilter<"CraftIdea"> | number
    generated_by_user_id?: IntNullableFilter<"CraftIdea"> | number | null
    idea_json?: JsonFilter<"CraftIdea">
    recycled_materials?: JsonNullableFilter<"CraftIdea">
    generated_image_url?: StringNullableFilter<"CraftIdea"> | string | null
    is_saved?: BoolFilter<"CraftIdea"> | boolean
    created_at?: DateTimeFilter<"CraftIdea"> | Date | string
    deleted_at?: DateTimeNullableFilter<"CraftIdea"> | Date | string | null
    generated_by_user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type CraftIdeaOrderByWithRelationInput = {
    idea_id?: SortOrder
    generated_by_user_id?: SortOrderInput | SortOrder
    idea_json?: SortOrder
    recycled_materials?: SortOrderInput | SortOrder
    generated_image_url?: SortOrderInput | SortOrder
    is_saved?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    generated_by_user?: UserOrderByWithRelationInput
  }

  export type CraftIdeaWhereUniqueInput = Prisma.AtLeast<{
    idea_id?: number
    AND?: CraftIdeaWhereInput | CraftIdeaWhereInput[]
    OR?: CraftIdeaWhereInput[]
    NOT?: CraftIdeaWhereInput | CraftIdeaWhereInput[]
    generated_by_user_id?: IntNullableFilter<"CraftIdea"> | number | null
    idea_json?: JsonFilter<"CraftIdea">
    recycled_materials?: JsonNullableFilter<"CraftIdea">
    generated_image_url?: StringNullableFilter<"CraftIdea"> | string | null
    is_saved?: BoolFilter<"CraftIdea"> | boolean
    created_at?: DateTimeFilter<"CraftIdea"> | Date | string
    deleted_at?: DateTimeNullableFilter<"CraftIdea"> | Date | string | null
    generated_by_user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "idea_id">

  export type CraftIdeaOrderByWithAggregationInput = {
    idea_id?: SortOrder
    generated_by_user_id?: SortOrderInput | SortOrder
    idea_json?: SortOrder
    recycled_materials?: SortOrderInput | SortOrder
    generated_image_url?: SortOrderInput | SortOrder
    is_saved?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: CraftIdeaCountOrderByAggregateInput
    _avg?: CraftIdeaAvgOrderByAggregateInput
    _max?: CraftIdeaMaxOrderByAggregateInput
    _min?: CraftIdeaMinOrderByAggregateInput
    _sum?: CraftIdeaSumOrderByAggregateInput
  }

  export type CraftIdeaScalarWhereWithAggregatesInput = {
    AND?: CraftIdeaScalarWhereWithAggregatesInput | CraftIdeaScalarWhereWithAggregatesInput[]
    OR?: CraftIdeaScalarWhereWithAggregatesInput[]
    NOT?: CraftIdeaScalarWhereWithAggregatesInput | CraftIdeaScalarWhereWithAggregatesInput[]
    idea_id?: IntWithAggregatesFilter<"CraftIdea"> | number
    generated_by_user_id?: IntNullableWithAggregatesFilter<"CraftIdea"> | number | null
    idea_json?: JsonWithAggregatesFilter<"CraftIdea">
    recycled_materials?: JsonNullableWithAggregatesFilter<"CraftIdea">
    generated_image_url?: StringNullableWithAggregatesFilter<"CraftIdea"> | string | null
    is_saved?: BoolWithAggregatesFilter<"CraftIdea"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"CraftIdea"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"CraftIdea"> | Date | string | null
  }

  export type ChatbotConversationWhereInput = {
    AND?: ChatbotConversationWhereInput | ChatbotConversationWhereInput[]
    OR?: ChatbotConversationWhereInput[]
    NOT?: ChatbotConversationWhereInput | ChatbotConversationWhereInput[]
    conversation_id?: IntFilter<"ChatbotConversation"> | number
    user_id?: IntFilter<"ChatbotConversation"> | number
    created_at?: DateTimeFilter<"ChatbotConversation"> | Date | string
    updated_at?: DateTimeFilter<"ChatbotConversation"> | Date | string
    deleted_at?: DateTimeNullableFilter<"ChatbotConversation"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: ChatbotMessageListRelationFilter
  }

  export type ChatbotConversationOrderByWithRelationInput = {
    conversation_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    messages?: ChatbotMessageOrderByRelationAggregateInput
  }

  export type ChatbotConversationWhereUniqueInput = Prisma.AtLeast<{
    conversation_id?: number
    user_id?: number
    AND?: ChatbotConversationWhereInput | ChatbotConversationWhereInput[]
    OR?: ChatbotConversationWhereInput[]
    NOT?: ChatbotConversationWhereInput | ChatbotConversationWhereInput[]
    created_at?: DateTimeFilter<"ChatbotConversation"> | Date | string
    updated_at?: DateTimeFilter<"ChatbotConversation"> | Date | string
    deleted_at?: DateTimeNullableFilter<"ChatbotConversation"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: ChatbotMessageListRelationFilter
  }, "conversation_id" | "user_id">

  export type ChatbotConversationOrderByWithAggregationInput = {
    conversation_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: ChatbotConversationCountOrderByAggregateInput
    _avg?: ChatbotConversationAvgOrderByAggregateInput
    _max?: ChatbotConversationMaxOrderByAggregateInput
    _min?: ChatbotConversationMinOrderByAggregateInput
    _sum?: ChatbotConversationSumOrderByAggregateInput
  }

  export type ChatbotConversationScalarWhereWithAggregatesInput = {
    AND?: ChatbotConversationScalarWhereWithAggregatesInput | ChatbotConversationScalarWhereWithAggregatesInput[]
    OR?: ChatbotConversationScalarWhereWithAggregatesInput[]
    NOT?: ChatbotConversationScalarWhereWithAggregatesInput | ChatbotConversationScalarWhereWithAggregatesInput[]
    conversation_id?: IntWithAggregatesFilter<"ChatbotConversation"> | number
    user_id?: IntWithAggregatesFilter<"ChatbotConversation"> | number
    created_at?: DateTimeWithAggregatesFilter<"ChatbotConversation"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ChatbotConversation"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"ChatbotConversation"> | Date | string | null
  }

  export type ChatbotMessageWhereInput = {
    AND?: ChatbotMessageWhereInput | ChatbotMessageWhereInput[]
    OR?: ChatbotMessageWhereInput[]
    NOT?: ChatbotMessageWhereInput | ChatbotMessageWhereInput[]
    message_id?: IntFilter<"ChatbotMessage"> | number
    conversation_id?: IntFilter<"ChatbotMessage"> | number
    sender?: EnumMessageSenderFilter<"ChatbotMessage"> | $Enums.MessageSender
    content?: StringFilter<"ChatbotMessage"> | string
    created_at?: DateTimeFilter<"ChatbotMessage"> | Date | string
    deleted_at?: DateTimeNullableFilter<"ChatbotMessage"> | Date | string | null
    conversation?: XOR<ChatbotConversationScalarRelationFilter, ChatbotConversationWhereInput>
  }

  export type ChatbotMessageOrderByWithRelationInput = {
    message_id?: SortOrder
    conversation_id?: SortOrder
    sender?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    conversation?: ChatbotConversationOrderByWithRelationInput
  }

  export type ChatbotMessageWhereUniqueInput = Prisma.AtLeast<{
    message_id?: number
    AND?: ChatbotMessageWhereInput | ChatbotMessageWhereInput[]
    OR?: ChatbotMessageWhereInput[]
    NOT?: ChatbotMessageWhereInput | ChatbotMessageWhereInput[]
    conversation_id?: IntFilter<"ChatbotMessage"> | number
    sender?: EnumMessageSenderFilter<"ChatbotMessage"> | $Enums.MessageSender
    content?: StringFilter<"ChatbotMessage"> | string
    created_at?: DateTimeFilter<"ChatbotMessage"> | Date | string
    deleted_at?: DateTimeNullableFilter<"ChatbotMessage"> | Date | string | null
    conversation?: XOR<ChatbotConversationScalarRelationFilter, ChatbotConversationWhereInput>
  }, "message_id">

  export type ChatbotMessageOrderByWithAggregationInput = {
    message_id?: SortOrder
    conversation_id?: SortOrder
    sender?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: ChatbotMessageCountOrderByAggregateInput
    _avg?: ChatbotMessageAvgOrderByAggregateInput
    _max?: ChatbotMessageMaxOrderByAggregateInput
    _min?: ChatbotMessageMinOrderByAggregateInput
    _sum?: ChatbotMessageSumOrderByAggregateInput
  }

  export type ChatbotMessageScalarWhereWithAggregatesInput = {
    AND?: ChatbotMessageScalarWhereWithAggregatesInput | ChatbotMessageScalarWhereWithAggregatesInput[]
    OR?: ChatbotMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatbotMessageScalarWhereWithAggregatesInput | ChatbotMessageScalarWhereWithAggregatesInput[]
    message_id?: IntWithAggregatesFilter<"ChatbotMessage"> | number
    conversation_id?: IntWithAggregatesFilter<"ChatbotMessage"> | number
    sender?: EnumMessageSenderWithAggregatesFilter<"ChatbotMessage"> | $Enums.MessageSender
    content?: StringWithAggregatesFilter<"ChatbotMessage"> | string
    created_at?: DateTimeWithAggregatesFilter<"ChatbotMessage"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"ChatbotMessage"> | Date | string | null
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    post_id?: IntFilter<"Post"> | number
    user_id?: IntFilter<"Post"> | number
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    image_url?: StringNullableFilter<"Post"> | string | null
    tags?: StringNullableListFilter<"Post">
    category?: EnumCategoryFilter<"Post"> | $Enums.Category
    featured?: BoolFilter<"Post"> | boolean
    created_at?: DateTimeFilter<"Post"> | Date | string
    updated_at?: DateTimeFilter<"Post"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Post"> | Date | string | null
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    reports?: ReportListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    post_id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image_url?: SortOrderInput | SortOrder
    tags?: SortOrder
    category?: SortOrder
    featured?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    comments?: CommentOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    reports?: ReportOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    post_id?: number
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    user_id?: IntFilter<"Post"> | number
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    image_url?: StringNullableFilter<"Post"> | string | null
    tags?: StringNullableListFilter<"Post">
    category?: EnumCategoryFilter<"Post"> | $Enums.Category
    featured?: BoolFilter<"Post"> | boolean
    created_at?: DateTimeFilter<"Post"> | Date | string
    updated_at?: DateTimeFilter<"Post"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Post"> | Date | string | null
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    reports?: ReportListRelationFilter
  }, "post_id">

  export type PostOrderByWithAggregationInput = {
    post_id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image_url?: SortOrderInput | SortOrder
    tags?: SortOrder
    category?: SortOrder
    featured?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    post_id?: IntWithAggregatesFilter<"Post"> | number
    user_id?: IntWithAggregatesFilter<"Post"> | number
    title?: StringWithAggregatesFilter<"Post"> | string
    content?: StringWithAggregatesFilter<"Post"> | string
    image_url?: StringNullableWithAggregatesFilter<"Post"> | string | null
    tags?: StringNullableListFilter<"Post">
    category?: EnumCategoryWithAggregatesFilter<"Post"> | $Enums.Category
    featured?: BoolWithAggregatesFilter<"Post"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Post"> | Date | string | null
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    comment_id?: IntFilter<"Comment"> | number
    post_id?: IntFilter<"Comment"> | number
    user_id?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    created_at?: DateTimeFilter<"Comment"> | Date | string
    updated_at?: DateTimeFilter<"Comment"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Comment"> | Date | string | null
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    reports?: ReportListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    comment_id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    post?: PostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    reports?: ReportOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    comment_id?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    post_id?: IntFilter<"Comment"> | number
    user_id?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    created_at?: DateTimeFilter<"Comment"> | Date | string
    updated_at?: DateTimeFilter<"Comment"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Comment"> | Date | string | null
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    reports?: ReportListRelationFilter
  }, "comment_id">

  export type CommentOrderByWithAggregationInput = {
    comment_id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    comment_id?: IntWithAggregatesFilter<"Comment"> | number
    post_id?: IntWithAggregatesFilter<"Comment"> | number
    user_id?: IntWithAggregatesFilter<"Comment"> | number
    content?: StringWithAggregatesFilter<"Comment"> | string
    created_at?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Comment"> | Date | string | null
  }

  export type LikeWhereInput = {
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    like_id?: IntFilter<"Like"> | number
    post_id?: IntFilter<"Like"> | number
    user_id?: IntFilter<"Like"> | number
    created_at?: DateTimeFilter<"Like"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Like"> | Date | string | null
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LikeOrderByWithRelationInput = {
    like_id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    post?: PostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type LikeWhereUniqueInput = Prisma.AtLeast<{
    like_id?: number
    post_id_user_id?: LikePost_idUser_idCompoundUniqueInput
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    post_id?: IntFilter<"Like"> | number
    user_id?: IntFilter<"Like"> | number
    created_at?: DateTimeFilter<"Like"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Like"> | Date | string | null
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "like_id" | "post_id_user_id">

  export type LikeOrderByWithAggregationInput = {
    like_id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: LikeCountOrderByAggregateInput
    _avg?: LikeAvgOrderByAggregateInput
    _max?: LikeMaxOrderByAggregateInput
    _min?: LikeMinOrderByAggregateInput
    _sum?: LikeSumOrderByAggregateInput
  }

  export type LikeScalarWhereWithAggregatesInput = {
    AND?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    OR?: LikeScalarWhereWithAggregatesInput[]
    NOT?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    like_id?: IntWithAggregatesFilter<"Like"> | number
    post_id?: IntWithAggregatesFilter<"Like"> | number
    user_id?: IntWithAggregatesFilter<"Like"> | number
    created_at?: DateTimeWithAggregatesFilter<"Like"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Like"> | Date | string | null
  }

  export type EcoChallengeWhereInput = {
    AND?: EcoChallengeWhereInput | EcoChallengeWhereInput[]
    OR?: EcoChallengeWhereInput[]
    NOT?: EcoChallengeWhereInput | EcoChallengeWhereInput[]
    challenge_id?: IntFilter<"EcoChallenge"> | number
    title?: StringFilter<"EcoChallenge"> | string
    description?: StringFilter<"EcoChallenge"> | string
    points_reward?: IntFilter<"EcoChallenge"> | number
    waste_kg?: FloatFilter<"EcoChallenge"> | number
    is_active?: BoolFilter<"EcoChallenge"> | boolean
    source?: EnumChallengeSourceFilter<"EcoChallenge"> | $Enums.ChallengeSource
    material_type?: EnumMaterialTypeFilter<"EcoChallenge"> | $Enums.MaterialType
    category?: EnumChallengeCategoryFilter<"EcoChallenge"> | $Enums.ChallengeCategory
    created_by_admin_id?: IntNullableFilter<"EcoChallenge"> | number | null
    created_at?: DateTimeFilter<"EcoChallenge"> | Date | string
    updated_at?: DateTimeFilter<"EcoChallenge"> | Date | string
    deleted_at?: DateTimeNullableFilter<"EcoChallenge"> | Date | string | null
    start_at?: DateTimeFilter<"EcoChallenge"> | Date | string
    expires_at?: DateTimeNullableFilter<"EcoChallenge"> | Date | string | null
    created_by_admin?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    participants?: UserChallengeListRelationFilter
  }

  export type EcoChallengeOrderByWithRelationInput = {
    challenge_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points_reward?: SortOrder
    waste_kg?: SortOrder
    is_active?: SortOrder
    source?: SortOrder
    material_type?: SortOrder
    category?: SortOrder
    created_by_admin_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    start_at?: SortOrder
    expires_at?: SortOrderInput | SortOrder
    created_by_admin?: UserOrderByWithRelationInput
    participants?: UserChallengeOrderByRelationAggregateInput
  }

  export type EcoChallengeWhereUniqueInput = Prisma.AtLeast<{
    challenge_id?: number
    AND?: EcoChallengeWhereInput | EcoChallengeWhereInput[]
    OR?: EcoChallengeWhereInput[]
    NOT?: EcoChallengeWhereInput | EcoChallengeWhereInput[]
    title?: StringFilter<"EcoChallenge"> | string
    description?: StringFilter<"EcoChallenge"> | string
    points_reward?: IntFilter<"EcoChallenge"> | number
    waste_kg?: FloatFilter<"EcoChallenge"> | number
    is_active?: BoolFilter<"EcoChallenge"> | boolean
    source?: EnumChallengeSourceFilter<"EcoChallenge"> | $Enums.ChallengeSource
    material_type?: EnumMaterialTypeFilter<"EcoChallenge"> | $Enums.MaterialType
    category?: EnumChallengeCategoryFilter<"EcoChallenge"> | $Enums.ChallengeCategory
    created_by_admin_id?: IntNullableFilter<"EcoChallenge"> | number | null
    created_at?: DateTimeFilter<"EcoChallenge"> | Date | string
    updated_at?: DateTimeFilter<"EcoChallenge"> | Date | string
    deleted_at?: DateTimeNullableFilter<"EcoChallenge"> | Date | string | null
    start_at?: DateTimeFilter<"EcoChallenge"> | Date | string
    expires_at?: DateTimeNullableFilter<"EcoChallenge"> | Date | string | null
    created_by_admin?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    participants?: UserChallengeListRelationFilter
  }, "challenge_id">

  export type EcoChallengeOrderByWithAggregationInput = {
    challenge_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points_reward?: SortOrder
    waste_kg?: SortOrder
    is_active?: SortOrder
    source?: SortOrder
    material_type?: SortOrder
    category?: SortOrder
    created_by_admin_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    start_at?: SortOrder
    expires_at?: SortOrderInput | SortOrder
    _count?: EcoChallengeCountOrderByAggregateInput
    _avg?: EcoChallengeAvgOrderByAggregateInput
    _max?: EcoChallengeMaxOrderByAggregateInput
    _min?: EcoChallengeMinOrderByAggregateInput
    _sum?: EcoChallengeSumOrderByAggregateInput
  }

  export type EcoChallengeScalarWhereWithAggregatesInput = {
    AND?: EcoChallengeScalarWhereWithAggregatesInput | EcoChallengeScalarWhereWithAggregatesInput[]
    OR?: EcoChallengeScalarWhereWithAggregatesInput[]
    NOT?: EcoChallengeScalarWhereWithAggregatesInput | EcoChallengeScalarWhereWithAggregatesInput[]
    challenge_id?: IntWithAggregatesFilter<"EcoChallenge"> | number
    title?: StringWithAggregatesFilter<"EcoChallenge"> | string
    description?: StringWithAggregatesFilter<"EcoChallenge"> | string
    points_reward?: IntWithAggregatesFilter<"EcoChallenge"> | number
    waste_kg?: FloatWithAggregatesFilter<"EcoChallenge"> | number
    is_active?: BoolWithAggregatesFilter<"EcoChallenge"> | boolean
    source?: EnumChallengeSourceWithAggregatesFilter<"EcoChallenge"> | $Enums.ChallengeSource
    material_type?: EnumMaterialTypeWithAggregatesFilter<"EcoChallenge"> | $Enums.MaterialType
    category?: EnumChallengeCategoryWithAggregatesFilter<"EcoChallenge"> | $Enums.ChallengeCategory
    created_by_admin_id?: IntNullableWithAggregatesFilter<"EcoChallenge"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"EcoChallenge"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"EcoChallenge"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"EcoChallenge"> | Date | string | null
    start_at?: DateTimeWithAggregatesFilter<"EcoChallenge"> | Date | string
    expires_at?: DateTimeNullableWithAggregatesFilter<"EcoChallenge"> | Date | string | null
  }

  export type UserChallengeWhereInput = {
    AND?: UserChallengeWhereInput | UserChallengeWhereInput[]
    OR?: UserChallengeWhereInput[]
    NOT?: UserChallengeWhereInput | UserChallengeWhereInput[]
    user_challenge_id?: IntFilter<"UserChallenge"> | number
    user_id?: IntFilter<"UserChallenge"> | number
    challenge_id?: IntFilter<"UserChallenge"> | number
    status?: EnumChallengeStatusFilter<"UserChallenge"> | $Enums.ChallengeStatus
    proof_url?: StringNullableFilter<"UserChallenge"> | string | null
    completed_at?: DateTimeNullableFilter<"UserChallenge"> | Date | string | null
    verified_at?: DateTimeNullableFilter<"UserChallenge"> | Date | string | null
    verified_by_admin_id?: IntNullableFilter<"UserChallenge"> | number | null
    verification_type?: EnumVerificationTypeNullableFilter<"UserChallenge"> | $Enums.VerificationType | null
    ai_confidence_score?: FloatNullableFilter<"UserChallenge"> | number | null
    points_awarded?: IntFilter<"UserChallenge"> | number
    waste_kg_saved?: FloatFilter<"UserChallenge"> | number
    admin_notes?: StringNullableFilter<"UserChallenge"> | string | null
    created_at?: DateTimeFilter<"UserChallenge"> | Date | string
    deleted_at?: DateTimeNullableFilter<"UserChallenge"> | Date | string | null
    skipped_at?: DateTimeNullableFilter<"UserChallenge"> | Date | string | null
    challenge?: XOR<EcoChallengeScalarRelationFilter, EcoChallengeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    verified_by?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type UserChallengeOrderByWithRelationInput = {
    user_challenge_id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    status?: SortOrder
    proof_url?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    verified_at?: SortOrderInput | SortOrder
    verified_by_admin_id?: SortOrderInput | SortOrder
    verification_type?: SortOrderInput | SortOrder
    ai_confidence_score?: SortOrderInput | SortOrder
    points_awarded?: SortOrder
    waste_kg_saved?: SortOrder
    admin_notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    skipped_at?: SortOrderInput | SortOrder
    challenge?: EcoChallengeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    verified_by?: UserOrderByWithRelationInput
  }

  export type UserChallengeWhereUniqueInput = Prisma.AtLeast<{
    user_challenge_id?: number
    user_id_challenge_id?: UserChallengeUser_idChallenge_idCompoundUniqueInput
    AND?: UserChallengeWhereInput | UserChallengeWhereInput[]
    OR?: UserChallengeWhereInput[]
    NOT?: UserChallengeWhereInput | UserChallengeWhereInput[]
    user_id?: IntFilter<"UserChallenge"> | number
    challenge_id?: IntFilter<"UserChallenge"> | number
    status?: EnumChallengeStatusFilter<"UserChallenge"> | $Enums.ChallengeStatus
    proof_url?: StringNullableFilter<"UserChallenge"> | string | null
    completed_at?: DateTimeNullableFilter<"UserChallenge"> | Date | string | null
    verified_at?: DateTimeNullableFilter<"UserChallenge"> | Date | string | null
    verified_by_admin_id?: IntNullableFilter<"UserChallenge"> | number | null
    verification_type?: EnumVerificationTypeNullableFilter<"UserChallenge"> | $Enums.VerificationType | null
    ai_confidence_score?: FloatNullableFilter<"UserChallenge"> | number | null
    points_awarded?: IntFilter<"UserChallenge"> | number
    waste_kg_saved?: FloatFilter<"UserChallenge"> | number
    admin_notes?: StringNullableFilter<"UserChallenge"> | string | null
    created_at?: DateTimeFilter<"UserChallenge"> | Date | string
    deleted_at?: DateTimeNullableFilter<"UserChallenge"> | Date | string | null
    skipped_at?: DateTimeNullableFilter<"UserChallenge"> | Date | string | null
    challenge?: XOR<EcoChallengeScalarRelationFilter, EcoChallengeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    verified_by?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "user_challenge_id" | "user_id_challenge_id">

  export type UserChallengeOrderByWithAggregationInput = {
    user_challenge_id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    status?: SortOrder
    proof_url?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    verified_at?: SortOrderInput | SortOrder
    verified_by_admin_id?: SortOrderInput | SortOrder
    verification_type?: SortOrderInput | SortOrder
    ai_confidence_score?: SortOrderInput | SortOrder
    points_awarded?: SortOrder
    waste_kg_saved?: SortOrder
    admin_notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    skipped_at?: SortOrderInput | SortOrder
    _count?: UserChallengeCountOrderByAggregateInput
    _avg?: UserChallengeAvgOrderByAggregateInput
    _max?: UserChallengeMaxOrderByAggregateInput
    _min?: UserChallengeMinOrderByAggregateInput
    _sum?: UserChallengeSumOrderByAggregateInput
  }

  export type UserChallengeScalarWhereWithAggregatesInput = {
    AND?: UserChallengeScalarWhereWithAggregatesInput | UserChallengeScalarWhereWithAggregatesInput[]
    OR?: UserChallengeScalarWhereWithAggregatesInput[]
    NOT?: UserChallengeScalarWhereWithAggregatesInput | UserChallengeScalarWhereWithAggregatesInput[]
    user_challenge_id?: IntWithAggregatesFilter<"UserChallenge"> | number
    user_id?: IntWithAggregatesFilter<"UserChallenge"> | number
    challenge_id?: IntWithAggregatesFilter<"UserChallenge"> | number
    status?: EnumChallengeStatusWithAggregatesFilter<"UserChallenge"> | $Enums.ChallengeStatus
    proof_url?: StringNullableWithAggregatesFilter<"UserChallenge"> | string | null
    completed_at?: DateTimeNullableWithAggregatesFilter<"UserChallenge"> | Date | string | null
    verified_at?: DateTimeNullableWithAggregatesFilter<"UserChallenge"> | Date | string | null
    verified_by_admin_id?: IntNullableWithAggregatesFilter<"UserChallenge"> | number | null
    verification_type?: EnumVerificationTypeNullableWithAggregatesFilter<"UserChallenge"> | $Enums.VerificationType | null
    ai_confidence_score?: FloatNullableWithAggregatesFilter<"UserChallenge"> | number | null
    points_awarded?: IntWithAggregatesFilter<"UserChallenge"> | number
    waste_kg_saved?: FloatWithAggregatesFilter<"UserChallenge"> | number
    admin_notes?: StringNullableWithAggregatesFilter<"UserChallenge"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"UserChallenge"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"UserChallenge"> | Date | string | null
    skipped_at?: DateTimeNullableWithAggregatesFilter<"UserChallenge"> | Date | string | null
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    report_id?: IntFilter<"Report"> | number
    reporter_id?: IntFilter<"Report"> | number
    reported_post_id?: IntNullableFilter<"Report"> | number | null
    reported_comment_id?: IntNullableFilter<"Report"> | number | null
    reason?: StringFilter<"Report"> | string
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    moderator_notes?: StringNullableFilter<"Report"> | string | null
    resolved_by_admin_id?: IntNullableFilter<"Report"> | number | null
    created_at?: DateTimeFilter<"Report"> | Date | string
    resolved_at?: DateTimeNullableFilter<"Report"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"Report"> | Date | string | null
    reported_comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    reported_post?: XOR<PostNullableScalarRelationFilter, PostWhereInput> | null
    reporter?: XOR<UserScalarRelationFilter, UserWhereInput>
    resolver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ReportOrderByWithRelationInput = {
    report_id?: SortOrder
    reporter_id?: SortOrder
    reported_post_id?: SortOrderInput | SortOrder
    reported_comment_id?: SortOrderInput | SortOrder
    reason?: SortOrder
    status?: SortOrder
    moderator_notes?: SortOrderInput | SortOrder
    resolved_by_admin_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    resolved_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    reported_comment?: CommentOrderByWithRelationInput
    reported_post?: PostOrderByWithRelationInput
    reporter?: UserOrderByWithRelationInput
    resolver?: UserOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    report_id?: number
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    reporter_id?: IntFilter<"Report"> | number
    reported_post_id?: IntNullableFilter<"Report"> | number | null
    reported_comment_id?: IntNullableFilter<"Report"> | number | null
    reason?: StringFilter<"Report"> | string
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    moderator_notes?: StringNullableFilter<"Report"> | string | null
    resolved_by_admin_id?: IntNullableFilter<"Report"> | number | null
    created_at?: DateTimeFilter<"Report"> | Date | string
    resolved_at?: DateTimeNullableFilter<"Report"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"Report"> | Date | string | null
    reported_comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    reported_post?: XOR<PostNullableScalarRelationFilter, PostWhereInput> | null
    reporter?: XOR<UserScalarRelationFilter, UserWhereInput>
    resolver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "report_id">

  export type ReportOrderByWithAggregationInput = {
    report_id?: SortOrder
    reporter_id?: SortOrder
    reported_post_id?: SortOrderInput | SortOrder
    reported_comment_id?: SortOrderInput | SortOrder
    reason?: SortOrder
    status?: SortOrder
    moderator_notes?: SortOrderInput | SortOrder
    resolved_by_admin_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    resolved_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: ReportCountOrderByAggregateInput
    _avg?: ReportAvgOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
    _sum?: ReportSumOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    report_id?: IntWithAggregatesFilter<"Report"> | number
    reporter_id?: IntWithAggregatesFilter<"Report"> | number
    reported_post_id?: IntNullableWithAggregatesFilter<"Report"> | number | null
    reported_comment_id?: IntNullableWithAggregatesFilter<"Report"> | number | null
    reason?: StringWithAggregatesFilter<"Report"> | string
    status?: EnumReportStatusWithAggregatesFilter<"Report"> | $Enums.ReportStatus
    moderator_notes?: StringNullableWithAggregatesFilter<"Report"> | string | null
    resolved_by_admin_id?: IntNullableWithAggregatesFilter<"Report"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    resolved_at?: DateTimeNullableWithAggregatesFilter<"Report"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Report"> | Date | string | null
  }

  export type AnnouncementWhereInput = {
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    announcement_id?: IntFilter<"Announcement"> | number
    admin_id?: IntNullableFilter<"Announcement"> | number | null
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    is_active?: BoolFilter<"Announcement"> | boolean
    created_at?: DateTimeFilter<"Announcement"> | Date | string
    expires_at?: DateTimeNullableFilter<"Announcement"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"Announcement"> | Date | string | null
    admin?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AnnouncementOrderByWithRelationInput = {
    announcement_id?: SortOrder
    admin_id?: SortOrderInput | SortOrder
    title?: SortOrder
    content?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    admin?: UserOrderByWithRelationInput
  }

  export type AnnouncementWhereUniqueInput = Prisma.AtLeast<{
    announcement_id?: number
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    admin_id?: IntNullableFilter<"Announcement"> | number | null
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    is_active?: BoolFilter<"Announcement"> | boolean
    created_at?: DateTimeFilter<"Announcement"> | Date | string
    expires_at?: DateTimeNullableFilter<"Announcement"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"Announcement"> | Date | string | null
    admin?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "announcement_id">

  export type AnnouncementOrderByWithAggregationInput = {
    announcement_id?: SortOrder
    admin_id?: SortOrderInput | SortOrder
    title?: SortOrder
    content?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: AnnouncementCountOrderByAggregateInput
    _avg?: AnnouncementAvgOrderByAggregateInput
    _max?: AnnouncementMaxOrderByAggregateInput
    _min?: AnnouncementMinOrderByAggregateInput
    _sum?: AnnouncementSumOrderByAggregateInput
  }

  export type AnnouncementScalarWhereWithAggregatesInput = {
    AND?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    OR?: AnnouncementScalarWhereWithAggregatesInput[]
    NOT?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    announcement_id?: IntWithAggregatesFilter<"Announcement"> | number
    admin_id?: IntNullableWithAggregatesFilter<"Announcement"> | number | null
    title?: StringWithAggregatesFilter<"Announcement"> | string
    content?: StringWithAggregatesFilter<"Announcement"> | string
    is_active?: BoolWithAggregatesFilter<"Announcement"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
    expires_at?: DateTimeNullableWithAggregatesFilter<"Announcement"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Announcement"> | Date | string | null
  }

  export type ModerationLogWhereInput = {
    AND?: ModerationLogWhereInput | ModerationLogWhereInput[]
    OR?: ModerationLogWhereInput[]
    NOT?: ModerationLogWhereInput | ModerationLogWhereInput[]
    log_id?: IntFilter<"ModerationLog"> | number
    admin_id?: IntNullableFilter<"ModerationLog"> | number | null
    action?: EnumModerationActionFilter<"ModerationLog"> | $Enums.ModerationAction
    target_id?: StringFilter<"ModerationLog"> | string
    target_user_id?: IntNullableFilter<"ModerationLog"> | number | null
    reason?: StringNullableFilter<"ModerationLog"> | string | null
    created_at?: DateTimeFilter<"ModerationLog"> | Date | string
    deleted_at?: DateTimeNullableFilter<"ModerationLog"> | Date | string | null
    admin?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    target_user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ModerationLogOrderByWithRelationInput = {
    log_id?: SortOrder
    admin_id?: SortOrderInput | SortOrder
    action?: SortOrder
    target_id?: SortOrder
    target_user_id?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    admin?: UserOrderByWithRelationInput
    target_user?: UserOrderByWithRelationInput
  }

  export type ModerationLogWhereUniqueInput = Prisma.AtLeast<{
    log_id?: number
    AND?: ModerationLogWhereInput | ModerationLogWhereInput[]
    OR?: ModerationLogWhereInput[]
    NOT?: ModerationLogWhereInput | ModerationLogWhereInput[]
    admin_id?: IntNullableFilter<"ModerationLog"> | number | null
    action?: EnumModerationActionFilter<"ModerationLog"> | $Enums.ModerationAction
    target_id?: StringFilter<"ModerationLog"> | string
    target_user_id?: IntNullableFilter<"ModerationLog"> | number | null
    reason?: StringNullableFilter<"ModerationLog"> | string | null
    created_at?: DateTimeFilter<"ModerationLog"> | Date | string
    deleted_at?: DateTimeNullableFilter<"ModerationLog"> | Date | string | null
    admin?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    target_user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "log_id">

  export type ModerationLogOrderByWithAggregationInput = {
    log_id?: SortOrder
    admin_id?: SortOrderInput | SortOrder
    action?: SortOrder
    target_id?: SortOrder
    target_user_id?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: ModerationLogCountOrderByAggregateInput
    _avg?: ModerationLogAvgOrderByAggregateInput
    _max?: ModerationLogMaxOrderByAggregateInput
    _min?: ModerationLogMinOrderByAggregateInput
    _sum?: ModerationLogSumOrderByAggregateInput
  }

  export type ModerationLogScalarWhereWithAggregatesInput = {
    AND?: ModerationLogScalarWhereWithAggregatesInput | ModerationLogScalarWhereWithAggregatesInput[]
    OR?: ModerationLogScalarWhereWithAggregatesInput[]
    NOT?: ModerationLogScalarWhereWithAggregatesInput | ModerationLogScalarWhereWithAggregatesInput[]
    log_id?: IntWithAggregatesFilter<"ModerationLog"> | number
    admin_id?: IntNullableWithAggregatesFilter<"ModerationLog"> | number | null
    action?: EnumModerationActionWithAggregatesFilter<"ModerationLog"> | $Enums.ModerationAction
    target_id?: StringWithAggregatesFilter<"ModerationLog"> | string
    target_user_id?: IntNullableWithAggregatesFilter<"ModerationLog"> | number | null
    reason?: StringNullableWithAggregatesFilter<"ModerationLog"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ModerationLog"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"ModerationLog"> | Date | string | null
  }

  export type SponsorWhereInput = {
    AND?: SponsorWhereInput | SponsorWhereInput[]
    OR?: SponsorWhereInput[]
    NOT?: SponsorWhereInput | SponsorWhereInput[]
    sponsor_id?: IntFilter<"Sponsor"> | number
    name?: StringFilter<"Sponsor"> | string
    logo_url?: StringNullableFilter<"Sponsor"> | string | null
    description?: StringNullableFilter<"Sponsor"> | string | null
    contact_email?: StringNullableFilter<"Sponsor"> | string | null
    is_active?: BoolFilter<"Sponsor"> | boolean
    created_by_admin_id?: IntNullableFilter<"Sponsor"> | number | null
    created_at?: DateTimeFilter<"Sponsor"> | Date | string
    updated_at?: DateTimeFilter<"Sponsor"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Sponsor"> | Date | string | null
    created_by_admin?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    rewards?: SponsorRewardListRelationFilter
  }

  export type SponsorOrderByWithRelationInput = {
    sponsor_id?: SortOrder
    name?: SortOrder
    logo_url?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    contact_email?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_by_admin_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    created_by_admin?: UserOrderByWithRelationInput
    rewards?: SponsorRewardOrderByRelationAggregateInput
  }

  export type SponsorWhereUniqueInput = Prisma.AtLeast<{
    sponsor_id?: number
    name?: string
    AND?: SponsorWhereInput | SponsorWhereInput[]
    OR?: SponsorWhereInput[]
    NOT?: SponsorWhereInput | SponsorWhereInput[]
    logo_url?: StringNullableFilter<"Sponsor"> | string | null
    description?: StringNullableFilter<"Sponsor"> | string | null
    contact_email?: StringNullableFilter<"Sponsor"> | string | null
    is_active?: BoolFilter<"Sponsor"> | boolean
    created_by_admin_id?: IntNullableFilter<"Sponsor"> | number | null
    created_at?: DateTimeFilter<"Sponsor"> | Date | string
    updated_at?: DateTimeFilter<"Sponsor"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Sponsor"> | Date | string | null
    created_by_admin?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    rewards?: SponsorRewardListRelationFilter
  }, "sponsor_id" | "name">

  export type SponsorOrderByWithAggregationInput = {
    sponsor_id?: SortOrder
    name?: SortOrder
    logo_url?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    contact_email?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_by_admin_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: SponsorCountOrderByAggregateInput
    _avg?: SponsorAvgOrderByAggregateInput
    _max?: SponsorMaxOrderByAggregateInput
    _min?: SponsorMinOrderByAggregateInput
    _sum?: SponsorSumOrderByAggregateInput
  }

  export type SponsorScalarWhereWithAggregatesInput = {
    AND?: SponsorScalarWhereWithAggregatesInput | SponsorScalarWhereWithAggregatesInput[]
    OR?: SponsorScalarWhereWithAggregatesInput[]
    NOT?: SponsorScalarWhereWithAggregatesInput | SponsorScalarWhereWithAggregatesInput[]
    sponsor_id?: IntWithAggregatesFilter<"Sponsor"> | number
    name?: StringWithAggregatesFilter<"Sponsor"> | string
    logo_url?: StringNullableWithAggregatesFilter<"Sponsor"> | string | null
    description?: StringNullableWithAggregatesFilter<"Sponsor"> | string | null
    contact_email?: StringNullableWithAggregatesFilter<"Sponsor"> | string | null
    is_active?: BoolWithAggregatesFilter<"Sponsor"> | boolean
    created_by_admin_id?: IntNullableWithAggregatesFilter<"Sponsor"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"Sponsor"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Sponsor"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Sponsor"> | Date | string | null
  }

  export type SponsorRewardWhereInput = {
    AND?: SponsorRewardWhereInput | SponsorRewardWhereInput[]
    OR?: SponsorRewardWhereInput[]
    NOT?: SponsorRewardWhereInput | SponsorRewardWhereInput[]
    reward_id?: IntFilter<"SponsorReward"> | number
    sponsor_id?: IntFilter<"SponsorReward"> | number
    title?: StringFilter<"SponsorReward"> | string
    description?: StringNullableFilter<"SponsorReward"> | string | null
    points_cost?: IntFilter<"SponsorReward"> | number
    quantity?: IntNullableFilter<"SponsorReward"> | number | null
    redeemed_count?: IntFilter<"SponsorReward"> | number
    is_active?: BoolFilter<"SponsorReward"> | boolean
    display_on_leaderboard?: BoolFilter<"SponsorReward"> | boolean
    created_at?: DateTimeFilter<"SponsorReward"> | Date | string
    updated_at?: DateTimeFilter<"SponsorReward"> | Date | string
    expires_at?: DateTimeNullableFilter<"SponsorReward"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"SponsorReward"> | Date | string | null
    sponsor?: XOR<SponsorScalarRelationFilter, SponsorWhereInput>
    claims?: UserRedemptionListRelationFilter
  }

  export type SponsorRewardOrderByWithRelationInput = {
    reward_id?: SortOrder
    sponsor_id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    points_cost?: SortOrder
    quantity?: SortOrderInput | SortOrder
    redeemed_count?: SortOrder
    is_active?: SortOrder
    display_on_leaderboard?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    expires_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    sponsor?: SponsorOrderByWithRelationInput
    claims?: UserRedemptionOrderByRelationAggregateInput
  }

  export type SponsorRewardWhereUniqueInput = Prisma.AtLeast<{
    reward_id?: number
    AND?: SponsorRewardWhereInput | SponsorRewardWhereInput[]
    OR?: SponsorRewardWhereInput[]
    NOT?: SponsorRewardWhereInput | SponsorRewardWhereInput[]
    sponsor_id?: IntFilter<"SponsorReward"> | number
    title?: StringFilter<"SponsorReward"> | string
    description?: StringNullableFilter<"SponsorReward"> | string | null
    points_cost?: IntFilter<"SponsorReward"> | number
    quantity?: IntNullableFilter<"SponsorReward"> | number | null
    redeemed_count?: IntFilter<"SponsorReward"> | number
    is_active?: BoolFilter<"SponsorReward"> | boolean
    display_on_leaderboard?: BoolFilter<"SponsorReward"> | boolean
    created_at?: DateTimeFilter<"SponsorReward"> | Date | string
    updated_at?: DateTimeFilter<"SponsorReward"> | Date | string
    expires_at?: DateTimeNullableFilter<"SponsorReward"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"SponsorReward"> | Date | string | null
    sponsor?: XOR<SponsorScalarRelationFilter, SponsorWhereInput>
    claims?: UserRedemptionListRelationFilter
  }, "reward_id">

  export type SponsorRewardOrderByWithAggregationInput = {
    reward_id?: SortOrder
    sponsor_id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    points_cost?: SortOrder
    quantity?: SortOrderInput | SortOrder
    redeemed_count?: SortOrder
    is_active?: SortOrder
    display_on_leaderboard?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    expires_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: SponsorRewardCountOrderByAggregateInput
    _avg?: SponsorRewardAvgOrderByAggregateInput
    _max?: SponsorRewardMaxOrderByAggregateInput
    _min?: SponsorRewardMinOrderByAggregateInput
    _sum?: SponsorRewardSumOrderByAggregateInput
  }

  export type SponsorRewardScalarWhereWithAggregatesInput = {
    AND?: SponsorRewardScalarWhereWithAggregatesInput | SponsorRewardScalarWhereWithAggregatesInput[]
    OR?: SponsorRewardScalarWhereWithAggregatesInput[]
    NOT?: SponsorRewardScalarWhereWithAggregatesInput | SponsorRewardScalarWhereWithAggregatesInput[]
    reward_id?: IntWithAggregatesFilter<"SponsorReward"> | number
    sponsor_id?: IntWithAggregatesFilter<"SponsorReward"> | number
    title?: StringWithAggregatesFilter<"SponsorReward"> | string
    description?: StringNullableWithAggregatesFilter<"SponsorReward"> | string | null
    points_cost?: IntWithAggregatesFilter<"SponsorReward"> | number
    quantity?: IntNullableWithAggregatesFilter<"SponsorReward"> | number | null
    redeemed_count?: IntWithAggregatesFilter<"SponsorReward"> | number
    is_active?: BoolWithAggregatesFilter<"SponsorReward"> | boolean
    display_on_leaderboard?: BoolWithAggregatesFilter<"SponsorReward"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"SponsorReward"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"SponsorReward"> | Date | string
    expires_at?: DateTimeNullableWithAggregatesFilter<"SponsorReward"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"SponsorReward"> | Date | string | null
  }

  export type UserRedemptionWhereInput = {
    AND?: UserRedemptionWhereInput | UserRedemptionWhereInput[]
    OR?: UserRedemptionWhereInput[]
    NOT?: UserRedemptionWhereInput | UserRedemptionWhereInput[]
    redemption_id?: IntFilter<"UserRedemption"> | number
    user_id?: IntFilter<"UserRedemption"> | number
    reward_id?: IntFilter<"UserRedemption"> | number
    status?: EnumRedemptionStatusFilter<"UserRedemption"> | $Enums.RedemptionStatus
    claimed_at?: DateTimeFilter<"UserRedemption"> | Date | string
    fulfilled_at?: DateTimeNullableFilter<"UserRedemption"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"UserRedemption"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    reward?: XOR<SponsorRewardScalarRelationFilter, SponsorRewardWhereInput>
  }

  export type UserRedemptionOrderByWithRelationInput = {
    redemption_id?: SortOrder
    user_id?: SortOrder
    reward_id?: SortOrder
    status?: SortOrder
    claimed_at?: SortOrder
    fulfilled_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    reward?: SponsorRewardOrderByWithRelationInput
  }

  export type UserRedemptionWhereUniqueInput = Prisma.AtLeast<{
    redemption_id?: number
    user_id_reward_id?: UserRedemptionUser_idReward_idCompoundUniqueInput
    AND?: UserRedemptionWhereInput | UserRedemptionWhereInput[]
    OR?: UserRedemptionWhereInput[]
    NOT?: UserRedemptionWhereInput | UserRedemptionWhereInput[]
    user_id?: IntFilter<"UserRedemption"> | number
    reward_id?: IntFilter<"UserRedemption"> | number
    status?: EnumRedemptionStatusFilter<"UserRedemption"> | $Enums.RedemptionStatus
    claimed_at?: DateTimeFilter<"UserRedemption"> | Date | string
    fulfilled_at?: DateTimeNullableFilter<"UserRedemption"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"UserRedemption"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    reward?: XOR<SponsorRewardScalarRelationFilter, SponsorRewardWhereInput>
  }, "redemption_id" | "user_id_reward_id">

  export type UserRedemptionOrderByWithAggregationInput = {
    redemption_id?: SortOrder
    user_id?: SortOrder
    reward_id?: SortOrder
    status?: SortOrder
    claimed_at?: SortOrder
    fulfilled_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: UserRedemptionCountOrderByAggregateInput
    _avg?: UserRedemptionAvgOrderByAggregateInput
    _max?: UserRedemptionMaxOrderByAggregateInput
    _min?: UserRedemptionMinOrderByAggregateInput
    _sum?: UserRedemptionSumOrderByAggregateInput
  }

  export type UserRedemptionScalarWhereWithAggregatesInput = {
    AND?: UserRedemptionScalarWhereWithAggregatesInput | UserRedemptionScalarWhereWithAggregatesInput[]
    OR?: UserRedemptionScalarWhereWithAggregatesInput[]
    NOT?: UserRedemptionScalarWhereWithAggregatesInput | UserRedemptionScalarWhereWithAggregatesInput[]
    redemption_id?: IntWithAggregatesFilter<"UserRedemption"> | number
    user_id?: IntWithAggregatesFilter<"UserRedemption"> | number
    reward_id?: IntWithAggregatesFilter<"UserRedemption"> | number
    status?: EnumRedemptionStatusWithAggregatesFilter<"UserRedemption"> | $Enums.RedemptionStatus
    claimed_at?: DateTimeWithAggregatesFilter<"UserRedemption"> | Date | string
    fulfilled_at?: DateTimeNullableWithAggregatesFilter<"UserRedemption"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"UserRedemption"> | Date | string | null
  }

  export type UserCreateInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogCreateNestedManyWithoutTarget_userInput
    posts?: PostCreateNestedManyWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    user_id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaUncheckedCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeUncheckedCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogUncheckedCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogUncheckedCreateNestedManyWithoutTarget_userInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportUncheckedCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeUncheckedCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorUncheckedCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUpdateManyWithoutTarget_userNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUncheckedUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUncheckedUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUncheckedUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUncheckedUpdateManyWithoutTarget_userNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUncheckedUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUncheckedUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    user_id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserProfileCreateInput = {
    full_name?: string | null
    bio?: string | null
    profile_picture_url?: string | null
    points?: number
    total_waste_kg?: number
    skipped_challenges?: UserProfileCreateskipped_challengesInput | number[]
    home_dashboard_layout?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type UserProfileUncheckedCreateInput = {
    user_id: number
    full_name?: string | null
    bio?: string | null
    profile_picture_url?: string | null
    points?: number
    total_waste_kg?: number
    skipped_challenges?: UserProfileCreateskipped_challengesInput | number[]
    home_dashboard_layout?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
  }

  export type UserProfileUpdateInput = {
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    total_waste_kg?: FloatFieldUpdateOperationsInput | number
    skipped_challenges?: UserProfileUpdateskipped_challengesInput | number[]
    home_dashboard_layout?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    total_waste_kg?: FloatFieldUpdateOperationsInput | number
    skipped_challenges?: UserProfileUpdateskipped_challengesInput | number[]
    home_dashboard_layout?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserProfileCreateManyInput = {
    user_id: number
    full_name?: string | null
    bio?: string | null
    profile_picture_url?: string | null
    points?: number
    total_waste_kg?: number
    skipped_challenges?: UserProfileCreateskipped_challengesInput | number[]
    home_dashboard_layout?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
  }

  export type UserProfileUpdateManyMutationInput = {
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    total_waste_kg?: FloatFieldUpdateOperationsInput | number
    skipped_challenges?: UserProfileUpdateskipped_challengesInput | number[]
    home_dashboard_layout?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserProfileUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    total_waste_kg?: FloatFieldUpdateOperationsInput | number
    skipped_challenges?: UserProfileUpdateskipped_challengesInput | number[]
    home_dashboard_layout?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenCreateInput = {
    token_hash: string
    expires_at: Date | string
    created_at?: Date | string
    last_used?: Date | string | null
    deleted_at?: Date | string | null
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    token_id?: number
    user_id: number
    token_hash: string
    expires_at: Date | string
    created_at?: Date | string
    last_used?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type RefreshTokenUpdateInput = {
    token_hash?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    token_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    token_hash?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenCreateManyInput = {
    token_id?: number
    user_id: number
    token_hash: string
    expires_at: Date | string
    created_at?: Date | string
    last_used?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type RefreshTokenUpdateManyMutationInput = {
    token_hash?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    token_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    token_hash?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CraftIdeaCreateInput = {
    idea_json: JsonNullValueInput | InputJsonValue
    recycled_materials?: NullableJsonNullValueInput | InputJsonValue
    generated_image_url?: string | null
    is_saved?: boolean
    created_at?: Date | string
    deleted_at?: Date | string | null
    generated_by_user?: UserCreateNestedOneWithoutCraftIdeasInput
  }

  export type CraftIdeaUncheckedCreateInput = {
    idea_id?: number
    generated_by_user_id?: number | null
    idea_json: JsonNullValueInput | InputJsonValue
    recycled_materials?: NullableJsonNullValueInput | InputJsonValue
    generated_image_url?: string | null
    is_saved?: boolean
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type CraftIdeaUpdateInput = {
    idea_json?: JsonNullValueInput | InputJsonValue
    recycled_materials?: NullableJsonNullValueInput | InputJsonValue
    generated_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    generated_by_user?: UserUpdateOneWithoutCraftIdeasNestedInput
  }

  export type CraftIdeaUncheckedUpdateInput = {
    idea_id?: IntFieldUpdateOperationsInput | number
    generated_by_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    idea_json?: JsonNullValueInput | InputJsonValue
    recycled_materials?: NullableJsonNullValueInput | InputJsonValue
    generated_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CraftIdeaCreateManyInput = {
    idea_id?: number
    generated_by_user_id?: number | null
    idea_json: JsonNullValueInput | InputJsonValue
    recycled_materials?: NullableJsonNullValueInput | InputJsonValue
    generated_image_url?: string | null
    is_saved?: boolean
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type CraftIdeaUpdateManyMutationInput = {
    idea_json?: JsonNullValueInput | InputJsonValue
    recycled_materials?: NullableJsonNullValueInput | InputJsonValue
    generated_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CraftIdeaUncheckedUpdateManyInput = {
    idea_id?: IntFieldUpdateOperationsInput | number
    generated_by_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    idea_json?: JsonNullValueInput | InputJsonValue
    recycled_materials?: NullableJsonNullValueInput | InputJsonValue
    generated_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatbotConversationCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user: UserCreateNestedOneWithoutChatbotConversationsInput
    messages?: ChatbotMessageCreateNestedManyWithoutConversationInput
  }

  export type ChatbotConversationUncheckedCreateInput = {
    conversation_id?: number
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    messages?: ChatbotMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ChatbotConversationUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutChatbotConversationsNestedInput
    messages?: ChatbotMessageUpdateManyWithoutConversationNestedInput
  }

  export type ChatbotConversationUncheckedUpdateInput = {
    conversation_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: ChatbotMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ChatbotConversationCreateManyInput = {
    conversation_id?: number
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ChatbotConversationUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatbotConversationUncheckedUpdateManyInput = {
    conversation_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatbotMessageCreateInput = {
    sender: $Enums.MessageSender
    content: string
    created_at?: Date | string
    deleted_at?: Date | string | null
    conversation: ChatbotConversationCreateNestedOneWithoutMessagesInput
  }

  export type ChatbotMessageUncheckedCreateInput = {
    message_id?: number
    conversation_id: number
    sender: $Enums.MessageSender
    content: string
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ChatbotMessageUpdateInput = {
    sender?: EnumMessageSenderFieldUpdateOperationsInput | $Enums.MessageSender
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversation?: ChatbotConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ChatbotMessageUncheckedUpdateInput = {
    message_id?: IntFieldUpdateOperationsInput | number
    conversation_id?: IntFieldUpdateOperationsInput | number
    sender?: EnumMessageSenderFieldUpdateOperationsInput | $Enums.MessageSender
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatbotMessageCreateManyInput = {
    message_id?: number
    conversation_id: number
    sender: $Enums.MessageSender
    content: string
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ChatbotMessageUpdateManyMutationInput = {
    sender?: EnumMessageSenderFieldUpdateOperationsInput | $Enums.MessageSender
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatbotMessageUncheckedUpdateManyInput = {
    message_id?: IntFieldUpdateOperationsInput | number
    conversation_id?: IntFieldUpdateOperationsInput | number
    sender?: EnumMessageSenderFieldUpdateOperationsInput | $Enums.MessageSender
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostCreateInput = {
    title: string
    content: string
    image_url?: string | null
    tags?: PostCreatetagsInput | string[]
    category: $Enums.Category
    featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    comments?: CommentCreateNestedManyWithoutPostInput
    likes?: LikeCreateNestedManyWithoutPostInput
    user: UserCreateNestedOneWithoutPostsInput
    reports?: ReportCreateNestedManyWithoutReported_postInput
  }

  export type PostUncheckedCreateInput = {
    post_id?: number
    user_id: number
    title: string
    content: string
    image_url?: string | null
    tags?: PostCreatetagsInput | string[]
    category: $Enums.Category
    featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    reports?: ReportUncheckedCreateNestedManyWithoutReported_postInput
  }

  export type PostUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostUpdatetagsInput | string[]
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUpdateManyWithoutPostNestedInput
    likes?: LikeUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
    reports?: ReportUpdateManyWithoutReported_postNestedInput
  }

  export type PostUncheckedUpdateInput = {
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostUpdatetagsInput | string[]
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReported_postNestedInput
  }

  export type PostCreateManyInput = {
    post_id?: number
    user_id: number
    title: string
    content: string
    image_url?: string | null
    tags?: PostCreatetagsInput | string[]
    category: $Enums.Category
    featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type PostUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostUpdatetagsInput | string[]
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostUncheckedUpdateManyInput = {
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostUpdatetagsInput | string[]
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentCreateInput = {
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    post: PostCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
    reports?: ReportCreateNestedManyWithoutReported_commentInput
  }

  export type CommentUncheckedCreateInput = {
    comment_id?: number
    post_id: number
    user_id: number
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    reports?: ReportUncheckedCreateNestedManyWithoutReported_commentInput
  }

  export type CommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    reports?: ReportUpdateManyWithoutReported_commentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reports?: ReportUncheckedUpdateManyWithoutReported_commentNestedInput
  }

  export type CommentCreateManyInput = {
    comment_id?: number
    post_id: number
    user_id: number
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type CommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentUncheckedUpdateManyInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LikeCreateInput = {
    created_at?: Date | string
    deleted_at?: Date | string | null
    post: PostCreateNestedOneWithoutLikesInput
    user: UserCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateInput = {
    like_id?: number
    post_id: number
    user_id: number
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type LikeUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post?: PostUpdateOneRequiredWithoutLikesNestedInput
    user?: UserUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateInput = {
    like_id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LikeCreateManyInput = {
    like_id?: number
    post_id: number
    user_id: number
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type LikeUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LikeUncheckedUpdateManyInput = {
    like_id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EcoChallengeCreateInput = {
    title: string
    description: string
    points_reward: number
    waste_kg?: number
    is_active?: boolean
    source?: $Enums.ChallengeSource
    material_type: $Enums.MaterialType
    category: $Enums.ChallengeCategory
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    start_at?: Date | string
    expires_at?: Date | string | null
    created_by_admin?: UserCreateNestedOneWithoutCreatedChallengesInput
    participants?: UserChallengeCreateNestedManyWithoutChallengeInput
  }

  export type EcoChallengeUncheckedCreateInput = {
    challenge_id?: number
    title: string
    description: string
    points_reward: number
    waste_kg?: number
    is_active?: boolean
    source?: $Enums.ChallengeSource
    material_type: $Enums.MaterialType
    category: $Enums.ChallengeCategory
    created_by_admin_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    start_at?: Date | string
    expires_at?: Date | string | null
    participants?: UserChallengeUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type EcoChallengeUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points_reward?: IntFieldUpdateOperationsInput | number
    waste_kg?: FloatFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    source?: EnumChallengeSourceFieldUpdateOperationsInput | $Enums.ChallengeSource
    material_type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    category?: EnumChallengeCategoryFieldUpdateOperationsInput | $Enums.ChallengeCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by_admin?: UserUpdateOneWithoutCreatedChallengesNestedInput
    participants?: UserChallengeUpdateManyWithoutChallengeNestedInput
  }

  export type EcoChallengeUncheckedUpdateInput = {
    challenge_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points_reward?: IntFieldUpdateOperationsInput | number
    waste_kg?: FloatFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    source?: EnumChallengeSourceFieldUpdateOperationsInput | $Enums.ChallengeSource
    material_type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    category?: EnumChallengeCategoryFieldUpdateOperationsInput | $Enums.ChallengeCategory
    created_by_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participants?: UserChallengeUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type EcoChallengeCreateManyInput = {
    challenge_id?: number
    title: string
    description: string
    points_reward: number
    waste_kg?: number
    is_active?: boolean
    source?: $Enums.ChallengeSource
    material_type: $Enums.MaterialType
    category: $Enums.ChallengeCategory
    created_by_admin_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    start_at?: Date | string
    expires_at?: Date | string | null
  }

  export type EcoChallengeUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points_reward?: IntFieldUpdateOperationsInput | number
    waste_kg?: FloatFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    source?: EnumChallengeSourceFieldUpdateOperationsInput | $Enums.ChallengeSource
    material_type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    category?: EnumChallengeCategoryFieldUpdateOperationsInput | $Enums.ChallengeCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EcoChallengeUncheckedUpdateManyInput = {
    challenge_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points_reward?: IntFieldUpdateOperationsInput | number
    waste_kg?: FloatFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    source?: EnumChallengeSourceFieldUpdateOperationsInput | $Enums.ChallengeSource
    material_type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    category?: EnumChallengeCategoryFieldUpdateOperationsInput | $Enums.ChallengeCategory
    created_by_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserChallengeCreateInput = {
    status?: $Enums.ChallengeStatus
    proof_url?: string | null
    completed_at?: Date | string | null
    verified_at?: Date | string | null
    verification_type?: $Enums.VerificationType | null
    ai_confidence_score?: number | null
    points_awarded?: number
    waste_kg_saved?: number
    admin_notes?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    skipped_at?: Date | string | null
    challenge: EcoChallengeCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutUserChallengesInput
    verified_by?: UserCreateNestedOneWithoutVerifiedChallengesInput
  }

  export type UserChallengeUncheckedCreateInput = {
    user_challenge_id?: number
    user_id: number
    challenge_id: number
    status?: $Enums.ChallengeStatus
    proof_url?: string | null
    completed_at?: Date | string | null
    verified_at?: Date | string | null
    verified_by_admin_id?: number | null
    verification_type?: $Enums.VerificationType | null
    ai_confidence_score?: number | null
    points_awarded?: number
    waste_kg_saved?: number
    admin_notes?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    skipped_at?: Date | string | null
  }

  export type UserChallengeUpdateInput = {
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    proof_url?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_type?: NullableEnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType | null
    ai_confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    points_awarded?: IntFieldUpdateOperationsInput | number
    waste_kg_saved?: FloatFieldUpdateOperationsInput | number
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    challenge?: EcoChallengeUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutUserChallengesNestedInput
    verified_by?: UserUpdateOneWithoutVerifiedChallengesNestedInput
  }

  export type UserChallengeUncheckedUpdateInput = {
    user_challenge_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    challenge_id?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    proof_url?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_by_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    verification_type?: NullableEnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType | null
    ai_confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    points_awarded?: IntFieldUpdateOperationsInput | number
    waste_kg_saved?: FloatFieldUpdateOperationsInput | number
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserChallengeCreateManyInput = {
    user_challenge_id?: number
    user_id: number
    challenge_id: number
    status?: $Enums.ChallengeStatus
    proof_url?: string | null
    completed_at?: Date | string | null
    verified_at?: Date | string | null
    verified_by_admin_id?: number | null
    verification_type?: $Enums.VerificationType | null
    ai_confidence_score?: number | null
    points_awarded?: number
    waste_kg_saved?: number
    admin_notes?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    skipped_at?: Date | string | null
  }

  export type UserChallengeUpdateManyMutationInput = {
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    proof_url?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_type?: NullableEnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType | null
    ai_confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    points_awarded?: IntFieldUpdateOperationsInput | number
    waste_kg_saved?: FloatFieldUpdateOperationsInput | number
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserChallengeUncheckedUpdateManyInput = {
    user_challenge_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    challenge_id?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    proof_url?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_by_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    verification_type?: NullableEnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType | null
    ai_confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    points_awarded?: IntFieldUpdateOperationsInput | number
    waste_kg_saved?: FloatFieldUpdateOperationsInput | number
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportCreateInput = {
    reason: string
    status?: $Enums.ReportStatus
    moderator_notes?: string | null
    created_at?: Date | string
    resolved_at?: Date | string | null
    deleted_at?: Date | string | null
    reported_comment?: CommentCreateNestedOneWithoutReportsInput
    reported_post?: PostCreateNestedOneWithoutReportsInput
    reporter: UserCreateNestedOneWithoutReportsFiledInput
    resolver?: UserCreateNestedOneWithoutReportsResolvedInput
  }

  export type ReportUncheckedCreateInput = {
    report_id?: number
    reporter_id: number
    reported_post_id?: number | null
    reported_comment_id?: number | null
    reason: string
    status?: $Enums.ReportStatus
    moderator_notes?: string | null
    resolved_by_admin_id?: number | null
    created_at?: Date | string
    resolved_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type ReportUpdateInput = {
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    moderator_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reported_comment?: CommentUpdateOneWithoutReportsNestedInput
    reported_post?: PostUpdateOneWithoutReportsNestedInput
    reporter?: UserUpdateOneRequiredWithoutReportsFiledNestedInput
    resolver?: UserUpdateOneWithoutReportsResolvedNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    report_id?: IntFieldUpdateOperationsInput | number
    reporter_id?: IntFieldUpdateOperationsInput | number
    reported_post_id?: NullableIntFieldUpdateOperationsInput | number | null
    reported_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    moderator_notes?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_by_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportCreateManyInput = {
    report_id?: number
    reporter_id: number
    reported_post_id?: number | null
    reported_comment_id?: number | null
    reason: string
    status?: $Enums.ReportStatus
    moderator_notes?: string | null
    resolved_by_admin_id?: number | null
    created_at?: Date | string
    resolved_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type ReportUpdateManyMutationInput = {
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    moderator_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUncheckedUpdateManyInput = {
    report_id?: IntFieldUpdateOperationsInput | number
    reporter_id?: IntFieldUpdateOperationsInput | number
    reported_post_id?: NullableIntFieldUpdateOperationsInput | number | null
    reported_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    moderator_notes?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_by_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnnouncementCreateInput = {
    title: string
    content: string
    is_active?: boolean
    created_at?: Date | string
    expires_at?: Date | string | null
    deleted_at?: Date | string | null
    admin?: UserCreateNestedOneWithoutAnnouncementsInput
  }

  export type AnnouncementUncheckedCreateInput = {
    announcement_id?: number
    admin_id?: number | null
    title: string
    content: string
    is_active?: boolean
    created_at?: Date | string
    expires_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type AnnouncementUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: UserUpdateOneWithoutAnnouncementsNestedInput
  }

  export type AnnouncementUncheckedUpdateInput = {
    announcement_id?: IntFieldUpdateOperationsInput | number
    admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnnouncementCreateManyInput = {
    announcement_id?: number
    admin_id?: number | null
    title: string
    content: string
    is_active?: boolean
    created_at?: Date | string
    expires_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type AnnouncementUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnnouncementUncheckedUpdateManyInput = {
    announcement_id?: IntFieldUpdateOperationsInput | number
    admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModerationLogCreateInput = {
    action: $Enums.ModerationAction
    target_id: string
    reason?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    admin?: UserCreateNestedOneWithoutModerationLogsInput
    target_user?: UserCreateNestedOneWithoutModerationTargetsInput
  }

  export type ModerationLogUncheckedCreateInput = {
    log_id?: number
    admin_id?: number | null
    action: $Enums.ModerationAction
    target_id: string
    target_user_id?: number | null
    reason?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ModerationLogUpdateInput = {
    action?: EnumModerationActionFieldUpdateOperationsInput | $Enums.ModerationAction
    target_id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: UserUpdateOneWithoutModerationLogsNestedInput
    target_user?: UserUpdateOneWithoutModerationTargetsNestedInput
  }

  export type ModerationLogUncheckedUpdateInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    action?: EnumModerationActionFieldUpdateOperationsInput | $Enums.ModerationAction
    target_id?: StringFieldUpdateOperationsInput | string
    target_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModerationLogCreateManyInput = {
    log_id?: number
    admin_id?: number | null
    action: $Enums.ModerationAction
    target_id: string
    target_user_id?: number | null
    reason?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ModerationLogUpdateManyMutationInput = {
    action?: EnumModerationActionFieldUpdateOperationsInput | $Enums.ModerationAction
    target_id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModerationLogUncheckedUpdateManyInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    action?: EnumModerationActionFieldUpdateOperationsInput | $Enums.ModerationAction
    target_id?: StringFieldUpdateOperationsInput | string
    target_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SponsorCreateInput = {
    name: string
    logo_url?: string | null
    description?: string | null
    contact_email?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    created_by_admin?: UserCreateNestedOneWithoutCreatedSponsorsInput
    rewards?: SponsorRewardCreateNestedManyWithoutSponsorInput
  }

  export type SponsorUncheckedCreateInput = {
    sponsor_id?: number
    name: string
    logo_url?: string | null
    description?: string | null
    contact_email?: string | null
    is_active?: boolean
    created_by_admin_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    rewards?: SponsorRewardUncheckedCreateNestedManyWithoutSponsorInput
  }

  export type SponsorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by_admin?: UserUpdateOneWithoutCreatedSponsorsNestedInput
    rewards?: SponsorRewardUpdateManyWithoutSponsorNestedInput
  }

  export type SponsorUncheckedUpdateInput = {
    sponsor_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_by_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rewards?: SponsorRewardUncheckedUpdateManyWithoutSponsorNestedInput
  }

  export type SponsorCreateManyInput = {
    sponsor_id?: number
    name: string
    logo_url?: string | null
    description?: string | null
    contact_email?: string | null
    is_active?: boolean
    created_by_admin_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type SponsorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SponsorUncheckedUpdateManyInput = {
    sponsor_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_by_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SponsorRewardCreateInput = {
    title: string
    description?: string | null
    points_cost: number
    quantity?: number | null
    redeemed_count?: number
    is_active?: boolean
    display_on_leaderboard?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    expires_at?: Date | string | null
    deleted_at?: Date | string | null
    sponsor: SponsorCreateNestedOneWithoutRewardsInput
    claims?: UserRedemptionCreateNestedManyWithoutRewardInput
  }

  export type SponsorRewardUncheckedCreateInput = {
    reward_id?: number
    sponsor_id: number
    title: string
    description?: string | null
    points_cost: number
    quantity?: number | null
    redeemed_count?: number
    is_active?: boolean
    display_on_leaderboard?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    expires_at?: Date | string | null
    deleted_at?: Date | string | null
    claims?: UserRedemptionUncheckedCreateNestedManyWithoutRewardInput
  }

  export type SponsorRewardUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points_cost?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    redeemed_count?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    display_on_leaderboard?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sponsor?: SponsorUpdateOneRequiredWithoutRewardsNestedInput
    claims?: UserRedemptionUpdateManyWithoutRewardNestedInput
  }

  export type SponsorRewardUncheckedUpdateInput = {
    reward_id?: IntFieldUpdateOperationsInput | number
    sponsor_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points_cost?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    redeemed_count?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    display_on_leaderboard?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claims?: UserRedemptionUncheckedUpdateManyWithoutRewardNestedInput
  }

  export type SponsorRewardCreateManyInput = {
    reward_id?: number
    sponsor_id: number
    title: string
    description?: string | null
    points_cost: number
    quantity?: number | null
    redeemed_count?: number
    is_active?: boolean
    display_on_leaderboard?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    expires_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type SponsorRewardUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points_cost?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    redeemed_count?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    display_on_leaderboard?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SponsorRewardUncheckedUpdateManyInput = {
    reward_id?: IntFieldUpdateOperationsInput | number
    sponsor_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points_cost?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    redeemed_count?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    display_on_leaderboard?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserRedemptionCreateInput = {
    status?: $Enums.RedemptionStatus
    claimed_at?: Date | string
    fulfilled_at?: Date | string | null
    deleted_at?: Date | string | null
    user: UserCreateNestedOneWithoutRedemptionsInput
    reward: SponsorRewardCreateNestedOneWithoutClaimsInput
  }

  export type UserRedemptionUncheckedCreateInput = {
    redemption_id?: number
    user_id: number
    reward_id: number
    status?: $Enums.RedemptionStatus
    claimed_at?: Date | string
    fulfilled_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type UserRedemptionUpdateInput = {
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    claimed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfilled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutRedemptionsNestedInput
    reward?: SponsorRewardUpdateOneRequiredWithoutClaimsNestedInput
  }

  export type UserRedemptionUncheckedUpdateInput = {
    redemption_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    reward_id?: IntFieldUpdateOperationsInput | number
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    claimed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfilled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserRedemptionCreateManyInput = {
    redemption_id?: number
    user_id: number
    reward_id: number
    status?: $Enums.RedemptionStatus
    claimed_at?: Date | string
    fulfilled_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type UserRedemptionUpdateManyMutationInput = {
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    claimed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfilled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserRedemptionUncheckedUpdateManyInput = {
    redemption_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    reward_id?: IntFieldUpdateOperationsInput | number
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    claimed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfilled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AnnouncementListRelationFilter = {
    every?: AnnouncementWhereInput
    some?: AnnouncementWhereInput
    none?: AnnouncementWhereInput
  }

  export type ChatbotConversationNullableScalarRelationFilter = {
    is?: ChatbotConversationWhereInput | null
    isNot?: ChatbotConversationWhereInput | null
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type CraftIdeaListRelationFilter = {
    every?: CraftIdeaWhereInput
    some?: CraftIdeaWhereInput
    none?: CraftIdeaWhereInput
  }

  export type EcoChallengeListRelationFilter = {
    every?: EcoChallengeWhereInput
    some?: EcoChallengeWhereInput
    none?: EcoChallengeWhereInput
  }

  export type LikeListRelationFilter = {
    every?: LikeWhereInput
    some?: LikeWhereInput
    none?: LikeWhereInput
  }

  export type ModerationLogListRelationFilter = {
    every?: ModerationLogWhereInput
    some?: ModerationLogWhereInput
    none?: ModerationLogWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type UserChallengeListRelationFilter = {
    every?: UserChallengeWhereInput
    some?: UserChallengeWhereInput
    none?: UserChallengeWhereInput
  }

  export type UserProfileNullableScalarRelationFilter = {
    is?: UserProfileWhereInput | null
    isNot?: UserProfileWhereInput | null
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type SponsorListRelationFilter = {
    every?: SponsorWhereInput
    some?: SponsorWhereInput
    none?: SponsorWhereInput
  }

  export type UserRedemptionListRelationFilter = {
    every?: UserRedemptionWhereInput
    some?: UserRedemptionWhereInput
    none?: UserRedemptionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AnnouncementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CraftIdeaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EcoChallengeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModerationLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserChallengeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SponsorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRedemptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    user_id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_email_verified?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    user_id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_email_verified?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    user_id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_email_verified?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserProfileCountOrderByAggregateInput = {
    user_id?: SortOrder
    full_name?: SortOrder
    bio?: SortOrder
    profile_picture_url?: SortOrder
    points?: SortOrder
    total_waste_kg?: SortOrder
    skipped_challenges?: SortOrder
    home_dashboard_layout?: SortOrder
    deleted_at?: SortOrder
  }

  export type UserProfileAvgOrderByAggregateInput = {
    user_id?: SortOrder
    points?: SortOrder
    total_waste_kg?: SortOrder
    skipped_challenges?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    user_id?: SortOrder
    full_name?: SortOrder
    bio?: SortOrder
    profile_picture_url?: SortOrder
    points?: SortOrder
    total_waste_kg?: SortOrder
    deleted_at?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    user_id?: SortOrder
    full_name?: SortOrder
    bio?: SortOrder
    profile_picture_url?: SortOrder
    points?: SortOrder
    total_waste_kg?: SortOrder
    deleted_at?: SortOrder
  }

  export type UserProfileSumOrderByAggregateInput = {
    user_id?: SortOrder
    points?: SortOrder
    total_waste_kg?: SortOrder
    skipped_challenges?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    token_id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
    deleted_at?: SortOrder
  }

  export type RefreshTokenAvgOrderByAggregateInput = {
    token_id?: SortOrder
    user_id?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    token_id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
    deleted_at?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    token_id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
    deleted_at?: SortOrder
  }

  export type RefreshTokenSumOrderByAggregateInput = {
    token_id?: SortOrder
    user_id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CraftIdeaCountOrderByAggregateInput = {
    idea_id?: SortOrder
    generated_by_user_id?: SortOrder
    idea_json?: SortOrder
    recycled_materials?: SortOrder
    generated_image_url?: SortOrder
    is_saved?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type CraftIdeaAvgOrderByAggregateInput = {
    idea_id?: SortOrder
    generated_by_user_id?: SortOrder
  }

  export type CraftIdeaMaxOrderByAggregateInput = {
    idea_id?: SortOrder
    generated_by_user_id?: SortOrder
    generated_image_url?: SortOrder
    is_saved?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type CraftIdeaMinOrderByAggregateInput = {
    idea_id?: SortOrder
    generated_by_user_id?: SortOrder
    generated_image_url?: SortOrder
    is_saved?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type CraftIdeaSumOrderByAggregateInput = {
    idea_id?: SortOrder
    generated_by_user_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ChatbotMessageListRelationFilter = {
    every?: ChatbotMessageWhereInput
    some?: ChatbotMessageWhereInput
    none?: ChatbotMessageWhereInput
  }

  export type ChatbotMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatbotConversationCountOrderByAggregateInput = {
    conversation_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ChatbotConversationAvgOrderByAggregateInput = {
    conversation_id?: SortOrder
    user_id?: SortOrder
  }

  export type ChatbotConversationMaxOrderByAggregateInput = {
    conversation_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ChatbotConversationMinOrderByAggregateInput = {
    conversation_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ChatbotConversationSumOrderByAggregateInput = {
    conversation_id?: SortOrder
    user_id?: SortOrder
  }

  export type EnumMessageSenderFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageSender | EnumMessageSenderFieldRefInput<$PrismaModel>
    in?: $Enums.MessageSender[] | ListEnumMessageSenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageSender[] | ListEnumMessageSenderFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageSenderFilter<$PrismaModel> | $Enums.MessageSender
  }

  export type ChatbotConversationScalarRelationFilter = {
    is?: ChatbotConversationWhereInput
    isNot?: ChatbotConversationWhereInput
  }

  export type ChatbotMessageCountOrderByAggregateInput = {
    message_id?: SortOrder
    conversation_id?: SortOrder
    sender?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ChatbotMessageAvgOrderByAggregateInput = {
    message_id?: SortOrder
    conversation_id?: SortOrder
  }

  export type ChatbotMessageMaxOrderByAggregateInput = {
    message_id?: SortOrder
    conversation_id?: SortOrder
    sender?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ChatbotMessageMinOrderByAggregateInput = {
    message_id?: SortOrder
    conversation_id?: SortOrder
    sender?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ChatbotMessageSumOrderByAggregateInput = {
    message_id?: SortOrder
    conversation_id?: SortOrder
  }

  export type EnumMessageSenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageSender | EnumMessageSenderFieldRefInput<$PrismaModel>
    in?: $Enums.MessageSender[] | ListEnumMessageSenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageSender[] | ListEnumMessageSenderFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageSenderWithAggregatesFilter<$PrismaModel> | $Enums.MessageSender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageSenderFilter<$PrismaModel>
    _max?: NestedEnumMessageSenderFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryFilter<$PrismaModel> | $Enums.Category
  }

  export type PostCountOrderByAggregateInput = {
    post_id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image_url?: SortOrder
    tags?: SortOrder
    category?: SortOrder
    featured?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    post_id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image_url?: SortOrder
    category?: SortOrder
    featured?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    post_id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image_url?: SortOrder
    category?: SortOrder
    featured?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type EnumCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryWithAggregatesFilter<$PrismaModel> | $Enums.Category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryFilter<$PrismaModel>
    _max?: NestedEnumCategoryFilter<$PrismaModel>
  }

  export type PostScalarRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type CommentCountOrderByAggregateInput = {
    comment_id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    comment_id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    comment_id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    comment_id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    comment_id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type LikePost_idUser_idCompoundUniqueInput = {
    post_id: number
    user_id: number
  }

  export type LikeCountOrderByAggregateInput = {
    like_id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type LikeAvgOrderByAggregateInput = {
    like_id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type LikeMaxOrderByAggregateInput = {
    like_id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type LikeMinOrderByAggregateInput = {
    like_id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type LikeSumOrderByAggregateInput = {
    like_id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type EnumChallengeSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeSource | EnumChallengeSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeSource[] | ListEnumChallengeSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeSource[] | ListEnumChallengeSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeSourceFilter<$PrismaModel> | $Enums.ChallengeSource
  }

  export type EnumMaterialTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialType | EnumMaterialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialType[] | ListEnumMaterialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialType[] | ListEnumMaterialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialTypeFilter<$PrismaModel> | $Enums.MaterialType
  }

  export type EnumChallengeCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeCategory | EnumChallengeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeCategory[] | ListEnumChallengeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeCategory[] | ListEnumChallengeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeCategoryFilter<$PrismaModel> | $Enums.ChallengeCategory
  }

  export type EcoChallengeCountOrderByAggregateInput = {
    challenge_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points_reward?: SortOrder
    waste_kg?: SortOrder
    is_active?: SortOrder
    source?: SortOrder
    material_type?: SortOrder
    category?: SortOrder
    created_by_admin_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    start_at?: SortOrder
    expires_at?: SortOrder
  }

  export type EcoChallengeAvgOrderByAggregateInput = {
    challenge_id?: SortOrder
    points_reward?: SortOrder
    waste_kg?: SortOrder
    created_by_admin_id?: SortOrder
  }

  export type EcoChallengeMaxOrderByAggregateInput = {
    challenge_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points_reward?: SortOrder
    waste_kg?: SortOrder
    is_active?: SortOrder
    source?: SortOrder
    material_type?: SortOrder
    category?: SortOrder
    created_by_admin_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    start_at?: SortOrder
    expires_at?: SortOrder
  }

  export type EcoChallengeMinOrderByAggregateInput = {
    challenge_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points_reward?: SortOrder
    waste_kg?: SortOrder
    is_active?: SortOrder
    source?: SortOrder
    material_type?: SortOrder
    category?: SortOrder
    created_by_admin_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    start_at?: SortOrder
    expires_at?: SortOrder
  }

  export type EcoChallengeSumOrderByAggregateInput = {
    challenge_id?: SortOrder
    points_reward?: SortOrder
    waste_kg?: SortOrder
    created_by_admin_id?: SortOrder
  }

  export type EnumChallengeSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeSource | EnumChallengeSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeSource[] | ListEnumChallengeSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeSource[] | ListEnumChallengeSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeSourceWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeSourceFilter<$PrismaModel>
    _max?: NestedEnumChallengeSourceFilter<$PrismaModel>
  }

  export type EnumMaterialTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialType | EnumMaterialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialType[] | ListEnumMaterialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialType[] | ListEnumMaterialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialTypeWithAggregatesFilter<$PrismaModel> | $Enums.MaterialType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaterialTypeFilter<$PrismaModel>
    _max?: NestedEnumMaterialTypeFilter<$PrismaModel>
  }

  export type EnumChallengeCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeCategory | EnumChallengeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeCategory[] | ListEnumChallengeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeCategory[] | ListEnumChallengeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeCategoryFilter<$PrismaModel>
    _max?: NestedEnumChallengeCategoryFilter<$PrismaModel>
  }

  export type EnumChallengeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatus | EnumChallengeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeStatusFilter<$PrismaModel> | $Enums.ChallengeStatus
  }

  export type EnumVerificationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationType | EnumVerificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerificationTypeNullableFilter<$PrismaModel> | $Enums.VerificationType | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EcoChallengeScalarRelationFilter = {
    is?: EcoChallengeWhereInput
    isNot?: EcoChallengeWhereInput
  }

  export type UserChallengeUser_idChallenge_idCompoundUniqueInput = {
    user_id: number
    challenge_id: number
  }

  export type UserChallengeCountOrderByAggregateInput = {
    user_challenge_id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    status?: SortOrder
    proof_url?: SortOrder
    completed_at?: SortOrder
    verified_at?: SortOrder
    verified_by_admin_id?: SortOrder
    verification_type?: SortOrder
    ai_confidence_score?: SortOrder
    points_awarded?: SortOrder
    waste_kg_saved?: SortOrder
    admin_notes?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
    skipped_at?: SortOrder
  }

  export type UserChallengeAvgOrderByAggregateInput = {
    user_challenge_id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    verified_by_admin_id?: SortOrder
    ai_confidence_score?: SortOrder
    points_awarded?: SortOrder
    waste_kg_saved?: SortOrder
  }

  export type UserChallengeMaxOrderByAggregateInput = {
    user_challenge_id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    status?: SortOrder
    proof_url?: SortOrder
    completed_at?: SortOrder
    verified_at?: SortOrder
    verified_by_admin_id?: SortOrder
    verification_type?: SortOrder
    ai_confidence_score?: SortOrder
    points_awarded?: SortOrder
    waste_kg_saved?: SortOrder
    admin_notes?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
    skipped_at?: SortOrder
  }

  export type UserChallengeMinOrderByAggregateInput = {
    user_challenge_id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    status?: SortOrder
    proof_url?: SortOrder
    completed_at?: SortOrder
    verified_at?: SortOrder
    verified_by_admin_id?: SortOrder
    verification_type?: SortOrder
    ai_confidence_score?: SortOrder
    points_awarded?: SortOrder
    waste_kg_saved?: SortOrder
    admin_notes?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
    skipped_at?: SortOrder
  }

  export type UserChallengeSumOrderByAggregateInput = {
    user_challenge_id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    verified_by_admin_id?: SortOrder
    ai_confidence_score?: SortOrder
    points_awarded?: SortOrder
    waste_kg_saved?: SortOrder
  }

  export type EnumChallengeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatus | EnumChallengeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeStatusFilter<$PrismaModel>
    _max?: NestedEnumChallengeStatusFilter<$PrismaModel>
  }

  export type EnumVerificationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationType | EnumVerificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerificationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.VerificationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVerificationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumVerificationTypeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type PostNullableScalarRelationFilter = {
    is?: PostWhereInput | null
    isNot?: PostWhereInput | null
  }

  export type ReportCountOrderByAggregateInput = {
    report_id?: SortOrder
    reporter_id?: SortOrder
    reported_post_id?: SortOrder
    reported_comment_id?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    moderator_notes?: SortOrder
    resolved_by_admin_id?: SortOrder
    created_at?: SortOrder
    resolved_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ReportAvgOrderByAggregateInput = {
    report_id?: SortOrder
    reporter_id?: SortOrder
    reported_post_id?: SortOrder
    reported_comment_id?: SortOrder
    resolved_by_admin_id?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    report_id?: SortOrder
    reporter_id?: SortOrder
    reported_post_id?: SortOrder
    reported_comment_id?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    moderator_notes?: SortOrder
    resolved_by_admin_id?: SortOrder
    created_at?: SortOrder
    resolved_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    report_id?: SortOrder
    reporter_id?: SortOrder
    reported_post_id?: SortOrder
    reported_comment_id?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    moderator_notes?: SortOrder
    resolved_by_admin_id?: SortOrder
    created_at?: SortOrder
    resolved_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ReportSumOrderByAggregateInput = {
    report_id?: SortOrder
    reporter_id?: SortOrder
    reported_post_id?: SortOrder
    reported_comment_id?: SortOrder
    resolved_by_admin_id?: SortOrder
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type AnnouncementCountOrderByAggregateInput = {
    announcement_id?: SortOrder
    admin_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type AnnouncementAvgOrderByAggregateInput = {
    announcement_id?: SortOrder
    admin_id?: SortOrder
  }

  export type AnnouncementMaxOrderByAggregateInput = {
    announcement_id?: SortOrder
    admin_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type AnnouncementMinOrderByAggregateInput = {
    announcement_id?: SortOrder
    admin_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type AnnouncementSumOrderByAggregateInput = {
    announcement_id?: SortOrder
    admin_id?: SortOrder
  }

  export type EnumModerationActionFilter<$PrismaModel = never> = {
    equals?: $Enums.ModerationAction | EnumModerationActionFieldRefInput<$PrismaModel>
    in?: $Enums.ModerationAction[] | ListEnumModerationActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModerationAction[] | ListEnumModerationActionFieldRefInput<$PrismaModel>
    not?: NestedEnumModerationActionFilter<$PrismaModel> | $Enums.ModerationAction
  }

  export type ModerationLogCountOrderByAggregateInput = {
    log_id?: SortOrder
    admin_id?: SortOrder
    action?: SortOrder
    target_id?: SortOrder
    target_user_id?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ModerationLogAvgOrderByAggregateInput = {
    log_id?: SortOrder
    admin_id?: SortOrder
    target_user_id?: SortOrder
  }

  export type ModerationLogMaxOrderByAggregateInput = {
    log_id?: SortOrder
    admin_id?: SortOrder
    action?: SortOrder
    target_id?: SortOrder
    target_user_id?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ModerationLogMinOrderByAggregateInput = {
    log_id?: SortOrder
    admin_id?: SortOrder
    action?: SortOrder
    target_id?: SortOrder
    target_user_id?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ModerationLogSumOrderByAggregateInput = {
    log_id?: SortOrder
    admin_id?: SortOrder
    target_user_id?: SortOrder
  }

  export type EnumModerationActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModerationAction | EnumModerationActionFieldRefInput<$PrismaModel>
    in?: $Enums.ModerationAction[] | ListEnumModerationActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModerationAction[] | ListEnumModerationActionFieldRefInput<$PrismaModel>
    not?: NestedEnumModerationActionWithAggregatesFilter<$PrismaModel> | $Enums.ModerationAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModerationActionFilter<$PrismaModel>
    _max?: NestedEnumModerationActionFilter<$PrismaModel>
  }

  export type SponsorRewardListRelationFilter = {
    every?: SponsorRewardWhereInput
    some?: SponsorRewardWhereInput
    none?: SponsorRewardWhereInput
  }

  export type SponsorRewardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SponsorCountOrderByAggregateInput = {
    sponsor_id?: SortOrder
    name?: SortOrder
    logo_url?: SortOrder
    description?: SortOrder
    contact_email?: SortOrder
    is_active?: SortOrder
    created_by_admin_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type SponsorAvgOrderByAggregateInput = {
    sponsor_id?: SortOrder
    created_by_admin_id?: SortOrder
  }

  export type SponsorMaxOrderByAggregateInput = {
    sponsor_id?: SortOrder
    name?: SortOrder
    logo_url?: SortOrder
    description?: SortOrder
    contact_email?: SortOrder
    is_active?: SortOrder
    created_by_admin_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type SponsorMinOrderByAggregateInput = {
    sponsor_id?: SortOrder
    name?: SortOrder
    logo_url?: SortOrder
    description?: SortOrder
    contact_email?: SortOrder
    is_active?: SortOrder
    created_by_admin_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type SponsorSumOrderByAggregateInput = {
    sponsor_id?: SortOrder
    created_by_admin_id?: SortOrder
  }

  export type SponsorScalarRelationFilter = {
    is?: SponsorWhereInput
    isNot?: SponsorWhereInput
  }

  export type SponsorRewardCountOrderByAggregateInput = {
    reward_id?: SortOrder
    sponsor_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points_cost?: SortOrder
    quantity?: SortOrder
    redeemed_count?: SortOrder
    is_active?: SortOrder
    display_on_leaderboard?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    expires_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type SponsorRewardAvgOrderByAggregateInput = {
    reward_id?: SortOrder
    sponsor_id?: SortOrder
    points_cost?: SortOrder
    quantity?: SortOrder
    redeemed_count?: SortOrder
  }

  export type SponsorRewardMaxOrderByAggregateInput = {
    reward_id?: SortOrder
    sponsor_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points_cost?: SortOrder
    quantity?: SortOrder
    redeemed_count?: SortOrder
    is_active?: SortOrder
    display_on_leaderboard?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    expires_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type SponsorRewardMinOrderByAggregateInput = {
    reward_id?: SortOrder
    sponsor_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points_cost?: SortOrder
    quantity?: SortOrder
    redeemed_count?: SortOrder
    is_active?: SortOrder
    display_on_leaderboard?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    expires_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type SponsorRewardSumOrderByAggregateInput = {
    reward_id?: SortOrder
    sponsor_id?: SortOrder
    points_cost?: SortOrder
    quantity?: SortOrder
    redeemed_count?: SortOrder
  }

  export type EnumRedemptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RedemptionStatus | EnumRedemptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RedemptionStatus[] | ListEnumRedemptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RedemptionStatus[] | ListEnumRedemptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRedemptionStatusFilter<$PrismaModel> | $Enums.RedemptionStatus
  }

  export type SponsorRewardScalarRelationFilter = {
    is?: SponsorRewardWhereInput
    isNot?: SponsorRewardWhereInput
  }

  export type UserRedemptionUser_idReward_idCompoundUniqueInput = {
    user_id: number
    reward_id: number
  }

  export type UserRedemptionCountOrderByAggregateInput = {
    redemption_id?: SortOrder
    user_id?: SortOrder
    reward_id?: SortOrder
    status?: SortOrder
    claimed_at?: SortOrder
    fulfilled_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type UserRedemptionAvgOrderByAggregateInput = {
    redemption_id?: SortOrder
    user_id?: SortOrder
    reward_id?: SortOrder
  }

  export type UserRedemptionMaxOrderByAggregateInput = {
    redemption_id?: SortOrder
    user_id?: SortOrder
    reward_id?: SortOrder
    status?: SortOrder
    claimed_at?: SortOrder
    fulfilled_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type UserRedemptionMinOrderByAggregateInput = {
    redemption_id?: SortOrder
    user_id?: SortOrder
    reward_id?: SortOrder
    status?: SortOrder
    claimed_at?: SortOrder
    fulfilled_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type UserRedemptionSumOrderByAggregateInput = {
    redemption_id?: SortOrder
    user_id?: SortOrder
    reward_id?: SortOrder
  }

  export type EnumRedemptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RedemptionStatus | EnumRedemptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RedemptionStatus[] | ListEnumRedemptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RedemptionStatus[] | ListEnumRedemptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRedemptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.RedemptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRedemptionStatusFilter<$PrismaModel>
    _max?: NestedEnumRedemptionStatusFilter<$PrismaModel>
  }

  export type AnnouncementCreateNestedManyWithoutAdminInput = {
    create?: XOR<AnnouncementCreateWithoutAdminInput, AnnouncementUncheckedCreateWithoutAdminInput> | AnnouncementCreateWithoutAdminInput[] | AnnouncementUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutAdminInput | AnnouncementCreateOrConnectWithoutAdminInput[]
    createMany?: AnnouncementCreateManyAdminInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type ChatbotConversationCreateNestedOneWithoutUserInput = {
    create?: XOR<ChatbotConversationCreateWithoutUserInput, ChatbotConversationUncheckedCreateWithoutUserInput>
    connectOrCreate?: ChatbotConversationCreateOrConnectWithoutUserInput
    connect?: ChatbotConversationWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CraftIdeaCreateNestedManyWithoutGenerated_by_userInput = {
    create?: XOR<CraftIdeaCreateWithoutGenerated_by_userInput, CraftIdeaUncheckedCreateWithoutGenerated_by_userInput> | CraftIdeaCreateWithoutGenerated_by_userInput[] | CraftIdeaUncheckedCreateWithoutGenerated_by_userInput[]
    connectOrCreate?: CraftIdeaCreateOrConnectWithoutGenerated_by_userInput | CraftIdeaCreateOrConnectWithoutGenerated_by_userInput[]
    createMany?: CraftIdeaCreateManyGenerated_by_userInputEnvelope
    connect?: CraftIdeaWhereUniqueInput | CraftIdeaWhereUniqueInput[]
  }

  export type EcoChallengeCreateNestedManyWithoutCreated_by_adminInput = {
    create?: XOR<EcoChallengeCreateWithoutCreated_by_adminInput, EcoChallengeUncheckedCreateWithoutCreated_by_adminInput> | EcoChallengeCreateWithoutCreated_by_adminInput[] | EcoChallengeUncheckedCreateWithoutCreated_by_adminInput[]
    connectOrCreate?: EcoChallengeCreateOrConnectWithoutCreated_by_adminInput | EcoChallengeCreateOrConnectWithoutCreated_by_adminInput[]
    createMany?: EcoChallengeCreateManyCreated_by_adminInputEnvelope
    connect?: EcoChallengeWhereUniqueInput | EcoChallengeWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type ModerationLogCreateNestedManyWithoutAdminInput = {
    create?: XOR<ModerationLogCreateWithoutAdminInput, ModerationLogUncheckedCreateWithoutAdminInput> | ModerationLogCreateWithoutAdminInput[] | ModerationLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ModerationLogCreateOrConnectWithoutAdminInput | ModerationLogCreateOrConnectWithoutAdminInput[]
    createMany?: ModerationLogCreateManyAdminInputEnvelope
    connect?: ModerationLogWhereUniqueInput | ModerationLogWhereUniqueInput[]
  }

  export type ModerationLogCreateNestedManyWithoutTarget_userInput = {
    create?: XOR<ModerationLogCreateWithoutTarget_userInput, ModerationLogUncheckedCreateWithoutTarget_userInput> | ModerationLogCreateWithoutTarget_userInput[] | ModerationLogUncheckedCreateWithoutTarget_userInput[]
    connectOrCreate?: ModerationLogCreateOrConnectWithoutTarget_userInput | ModerationLogCreateOrConnectWithoutTarget_userInput[]
    createMany?: ModerationLogCreateManyTarget_userInputEnvelope
    connect?: ModerationLogWhereUniqueInput | ModerationLogWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutUserInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutReporterInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutResolverInput = {
    create?: XOR<ReportCreateWithoutResolverInput, ReportUncheckedCreateWithoutResolverInput> | ReportCreateWithoutResolverInput[] | ReportUncheckedCreateWithoutResolverInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutResolverInput | ReportCreateOrConnectWithoutResolverInput[]
    createMany?: ReportCreateManyResolverInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type UserChallengeCreateNestedManyWithoutUserInput = {
    create?: XOR<UserChallengeCreateWithoutUserInput, UserChallengeUncheckedCreateWithoutUserInput> | UserChallengeCreateWithoutUserInput[] | UserChallengeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutUserInput | UserChallengeCreateOrConnectWithoutUserInput[]
    createMany?: UserChallengeCreateManyUserInputEnvelope
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
  }

  export type UserChallengeCreateNestedManyWithoutVerified_byInput = {
    create?: XOR<UserChallengeCreateWithoutVerified_byInput, UserChallengeUncheckedCreateWithoutVerified_byInput> | UserChallengeCreateWithoutVerified_byInput[] | UserChallengeUncheckedCreateWithoutVerified_byInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutVerified_byInput | UserChallengeCreateOrConnectWithoutVerified_byInput[]
    createMany?: UserChallengeCreateManyVerified_byInputEnvelope
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
  }

  export type UserProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type SponsorCreateNestedManyWithoutCreated_by_adminInput = {
    create?: XOR<SponsorCreateWithoutCreated_by_adminInput, SponsorUncheckedCreateWithoutCreated_by_adminInput> | SponsorCreateWithoutCreated_by_adminInput[] | SponsorUncheckedCreateWithoutCreated_by_adminInput[]
    connectOrCreate?: SponsorCreateOrConnectWithoutCreated_by_adminInput | SponsorCreateOrConnectWithoutCreated_by_adminInput[]
    createMany?: SponsorCreateManyCreated_by_adminInputEnvelope
    connect?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
  }

  export type UserRedemptionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRedemptionCreateWithoutUserInput, UserRedemptionUncheckedCreateWithoutUserInput> | UserRedemptionCreateWithoutUserInput[] | UserRedemptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRedemptionCreateOrConnectWithoutUserInput | UserRedemptionCreateOrConnectWithoutUserInput[]
    createMany?: UserRedemptionCreateManyUserInputEnvelope
    connect?: UserRedemptionWhereUniqueInput | UserRedemptionWhereUniqueInput[]
  }

  export type AnnouncementUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AnnouncementCreateWithoutAdminInput, AnnouncementUncheckedCreateWithoutAdminInput> | AnnouncementCreateWithoutAdminInput[] | AnnouncementUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutAdminInput | AnnouncementCreateOrConnectWithoutAdminInput[]
    createMany?: AnnouncementCreateManyAdminInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type ChatbotConversationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ChatbotConversationCreateWithoutUserInput, ChatbotConversationUncheckedCreateWithoutUserInput>
    connectOrCreate?: ChatbotConversationCreateOrConnectWithoutUserInput
    connect?: ChatbotConversationWhereUniqueInput
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CraftIdeaUncheckedCreateNestedManyWithoutGenerated_by_userInput = {
    create?: XOR<CraftIdeaCreateWithoutGenerated_by_userInput, CraftIdeaUncheckedCreateWithoutGenerated_by_userInput> | CraftIdeaCreateWithoutGenerated_by_userInput[] | CraftIdeaUncheckedCreateWithoutGenerated_by_userInput[]
    connectOrCreate?: CraftIdeaCreateOrConnectWithoutGenerated_by_userInput | CraftIdeaCreateOrConnectWithoutGenerated_by_userInput[]
    createMany?: CraftIdeaCreateManyGenerated_by_userInputEnvelope
    connect?: CraftIdeaWhereUniqueInput | CraftIdeaWhereUniqueInput[]
  }

  export type EcoChallengeUncheckedCreateNestedManyWithoutCreated_by_adminInput = {
    create?: XOR<EcoChallengeCreateWithoutCreated_by_adminInput, EcoChallengeUncheckedCreateWithoutCreated_by_adminInput> | EcoChallengeCreateWithoutCreated_by_adminInput[] | EcoChallengeUncheckedCreateWithoutCreated_by_adminInput[]
    connectOrCreate?: EcoChallengeCreateOrConnectWithoutCreated_by_adminInput | EcoChallengeCreateOrConnectWithoutCreated_by_adminInput[]
    createMany?: EcoChallengeCreateManyCreated_by_adminInputEnvelope
    connect?: EcoChallengeWhereUniqueInput | EcoChallengeWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type ModerationLogUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<ModerationLogCreateWithoutAdminInput, ModerationLogUncheckedCreateWithoutAdminInput> | ModerationLogCreateWithoutAdminInput[] | ModerationLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ModerationLogCreateOrConnectWithoutAdminInput | ModerationLogCreateOrConnectWithoutAdminInput[]
    createMany?: ModerationLogCreateManyAdminInputEnvelope
    connect?: ModerationLogWhereUniqueInput | ModerationLogWhereUniqueInput[]
  }

  export type ModerationLogUncheckedCreateNestedManyWithoutTarget_userInput = {
    create?: XOR<ModerationLogCreateWithoutTarget_userInput, ModerationLogUncheckedCreateWithoutTarget_userInput> | ModerationLogCreateWithoutTarget_userInput[] | ModerationLogUncheckedCreateWithoutTarget_userInput[]
    connectOrCreate?: ModerationLogCreateOrConnectWithoutTarget_userInput | ModerationLogCreateOrConnectWithoutTarget_userInput[]
    createMany?: ModerationLogCreateManyTarget_userInputEnvelope
    connect?: ModerationLogWhereUniqueInput | ModerationLogWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutReporterInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutResolverInput = {
    create?: XOR<ReportCreateWithoutResolverInput, ReportUncheckedCreateWithoutResolverInput> | ReportCreateWithoutResolverInput[] | ReportUncheckedCreateWithoutResolverInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutResolverInput | ReportCreateOrConnectWithoutResolverInput[]
    createMany?: ReportCreateManyResolverInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type UserChallengeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserChallengeCreateWithoutUserInput, UserChallengeUncheckedCreateWithoutUserInput> | UserChallengeCreateWithoutUserInput[] | UserChallengeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutUserInput | UserChallengeCreateOrConnectWithoutUserInput[]
    createMany?: UserChallengeCreateManyUserInputEnvelope
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
  }

  export type UserChallengeUncheckedCreateNestedManyWithoutVerified_byInput = {
    create?: XOR<UserChallengeCreateWithoutVerified_byInput, UserChallengeUncheckedCreateWithoutVerified_byInput> | UserChallengeCreateWithoutVerified_byInput[] | UserChallengeUncheckedCreateWithoutVerified_byInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutVerified_byInput | UserChallengeCreateOrConnectWithoutVerified_byInput[]
    createMany?: UserChallengeCreateManyVerified_byInputEnvelope
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type SponsorUncheckedCreateNestedManyWithoutCreated_by_adminInput = {
    create?: XOR<SponsorCreateWithoutCreated_by_adminInput, SponsorUncheckedCreateWithoutCreated_by_adminInput> | SponsorCreateWithoutCreated_by_adminInput[] | SponsorUncheckedCreateWithoutCreated_by_adminInput[]
    connectOrCreate?: SponsorCreateOrConnectWithoutCreated_by_adminInput | SponsorCreateOrConnectWithoutCreated_by_adminInput[]
    createMany?: SponsorCreateManyCreated_by_adminInputEnvelope
    connect?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
  }

  export type UserRedemptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRedemptionCreateWithoutUserInput, UserRedemptionUncheckedCreateWithoutUserInput> | UserRedemptionCreateWithoutUserInput[] | UserRedemptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRedemptionCreateOrConnectWithoutUserInput | UserRedemptionCreateOrConnectWithoutUserInput[]
    createMany?: UserRedemptionCreateManyUserInputEnvelope
    connect?: UserRedemptionWhereUniqueInput | UserRedemptionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AnnouncementUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AnnouncementCreateWithoutAdminInput, AnnouncementUncheckedCreateWithoutAdminInput> | AnnouncementCreateWithoutAdminInput[] | AnnouncementUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutAdminInput | AnnouncementCreateOrConnectWithoutAdminInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutAdminInput | AnnouncementUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AnnouncementCreateManyAdminInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutAdminInput | AnnouncementUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutAdminInput | AnnouncementUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type ChatbotConversationUpdateOneWithoutUserNestedInput = {
    create?: XOR<ChatbotConversationCreateWithoutUserInput, ChatbotConversationUncheckedCreateWithoutUserInput>
    connectOrCreate?: ChatbotConversationCreateOrConnectWithoutUserInput
    upsert?: ChatbotConversationUpsertWithoutUserInput
    disconnect?: ChatbotConversationWhereInput | boolean
    delete?: ChatbotConversationWhereInput | boolean
    connect?: ChatbotConversationWhereUniqueInput
    update?: XOR<XOR<ChatbotConversationUpdateToOneWithWhereWithoutUserInput, ChatbotConversationUpdateWithoutUserInput>, ChatbotConversationUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CraftIdeaUpdateManyWithoutGenerated_by_userNestedInput = {
    create?: XOR<CraftIdeaCreateWithoutGenerated_by_userInput, CraftIdeaUncheckedCreateWithoutGenerated_by_userInput> | CraftIdeaCreateWithoutGenerated_by_userInput[] | CraftIdeaUncheckedCreateWithoutGenerated_by_userInput[]
    connectOrCreate?: CraftIdeaCreateOrConnectWithoutGenerated_by_userInput | CraftIdeaCreateOrConnectWithoutGenerated_by_userInput[]
    upsert?: CraftIdeaUpsertWithWhereUniqueWithoutGenerated_by_userInput | CraftIdeaUpsertWithWhereUniqueWithoutGenerated_by_userInput[]
    createMany?: CraftIdeaCreateManyGenerated_by_userInputEnvelope
    set?: CraftIdeaWhereUniqueInput | CraftIdeaWhereUniqueInput[]
    disconnect?: CraftIdeaWhereUniqueInput | CraftIdeaWhereUniqueInput[]
    delete?: CraftIdeaWhereUniqueInput | CraftIdeaWhereUniqueInput[]
    connect?: CraftIdeaWhereUniqueInput | CraftIdeaWhereUniqueInput[]
    update?: CraftIdeaUpdateWithWhereUniqueWithoutGenerated_by_userInput | CraftIdeaUpdateWithWhereUniqueWithoutGenerated_by_userInput[]
    updateMany?: CraftIdeaUpdateManyWithWhereWithoutGenerated_by_userInput | CraftIdeaUpdateManyWithWhereWithoutGenerated_by_userInput[]
    deleteMany?: CraftIdeaScalarWhereInput | CraftIdeaScalarWhereInput[]
  }

  export type EcoChallengeUpdateManyWithoutCreated_by_adminNestedInput = {
    create?: XOR<EcoChallengeCreateWithoutCreated_by_adminInput, EcoChallengeUncheckedCreateWithoutCreated_by_adminInput> | EcoChallengeCreateWithoutCreated_by_adminInput[] | EcoChallengeUncheckedCreateWithoutCreated_by_adminInput[]
    connectOrCreate?: EcoChallengeCreateOrConnectWithoutCreated_by_adminInput | EcoChallengeCreateOrConnectWithoutCreated_by_adminInput[]
    upsert?: EcoChallengeUpsertWithWhereUniqueWithoutCreated_by_adminInput | EcoChallengeUpsertWithWhereUniqueWithoutCreated_by_adminInput[]
    createMany?: EcoChallengeCreateManyCreated_by_adminInputEnvelope
    set?: EcoChallengeWhereUniqueInput | EcoChallengeWhereUniqueInput[]
    disconnect?: EcoChallengeWhereUniqueInput | EcoChallengeWhereUniqueInput[]
    delete?: EcoChallengeWhereUniqueInput | EcoChallengeWhereUniqueInput[]
    connect?: EcoChallengeWhereUniqueInput | EcoChallengeWhereUniqueInput[]
    update?: EcoChallengeUpdateWithWhereUniqueWithoutCreated_by_adminInput | EcoChallengeUpdateWithWhereUniqueWithoutCreated_by_adminInput[]
    updateMany?: EcoChallengeUpdateManyWithWhereWithoutCreated_by_adminInput | EcoChallengeUpdateManyWithWhereWithoutCreated_by_adminInput[]
    deleteMany?: EcoChallengeScalarWhereInput | EcoChallengeScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutUserInput | LikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutUserInput | LikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutUserInput | LikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type ModerationLogUpdateManyWithoutAdminNestedInput = {
    create?: XOR<ModerationLogCreateWithoutAdminInput, ModerationLogUncheckedCreateWithoutAdminInput> | ModerationLogCreateWithoutAdminInput[] | ModerationLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ModerationLogCreateOrConnectWithoutAdminInput | ModerationLogCreateOrConnectWithoutAdminInput[]
    upsert?: ModerationLogUpsertWithWhereUniqueWithoutAdminInput | ModerationLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: ModerationLogCreateManyAdminInputEnvelope
    set?: ModerationLogWhereUniqueInput | ModerationLogWhereUniqueInput[]
    disconnect?: ModerationLogWhereUniqueInput | ModerationLogWhereUniqueInput[]
    delete?: ModerationLogWhereUniqueInput | ModerationLogWhereUniqueInput[]
    connect?: ModerationLogWhereUniqueInput | ModerationLogWhereUniqueInput[]
    update?: ModerationLogUpdateWithWhereUniqueWithoutAdminInput | ModerationLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: ModerationLogUpdateManyWithWhereWithoutAdminInput | ModerationLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: ModerationLogScalarWhereInput | ModerationLogScalarWhereInput[]
  }

  export type ModerationLogUpdateManyWithoutTarget_userNestedInput = {
    create?: XOR<ModerationLogCreateWithoutTarget_userInput, ModerationLogUncheckedCreateWithoutTarget_userInput> | ModerationLogCreateWithoutTarget_userInput[] | ModerationLogUncheckedCreateWithoutTarget_userInput[]
    connectOrCreate?: ModerationLogCreateOrConnectWithoutTarget_userInput | ModerationLogCreateOrConnectWithoutTarget_userInput[]
    upsert?: ModerationLogUpsertWithWhereUniqueWithoutTarget_userInput | ModerationLogUpsertWithWhereUniqueWithoutTarget_userInput[]
    createMany?: ModerationLogCreateManyTarget_userInputEnvelope
    set?: ModerationLogWhereUniqueInput | ModerationLogWhereUniqueInput[]
    disconnect?: ModerationLogWhereUniqueInput | ModerationLogWhereUniqueInput[]
    delete?: ModerationLogWhereUniqueInput | ModerationLogWhereUniqueInput[]
    connect?: ModerationLogWhereUniqueInput | ModerationLogWhereUniqueInput[]
    update?: ModerationLogUpdateWithWhereUniqueWithoutTarget_userInput | ModerationLogUpdateWithWhereUniqueWithoutTarget_userInput[]
    updateMany?: ModerationLogUpdateManyWithWhereWithoutTarget_userInput | ModerationLogUpdateManyWithWhereWithoutTarget_userInput[]
    deleteMany?: ModerationLogScalarWhereInput | ModerationLogScalarWhereInput[]
  }

  export type PostUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutUserInput | PostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutUserInput | PostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostUpdateManyWithWhereWithoutUserInput | PostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutReporterNestedInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReporterInput | ReportUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReporterInput | ReportUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReporterInput | ReportUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutResolverNestedInput = {
    create?: XOR<ReportCreateWithoutResolverInput, ReportUncheckedCreateWithoutResolverInput> | ReportCreateWithoutResolverInput[] | ReportUncheckedCreateWithoutResolverInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutResolverInput | ReportCreateOrConnectWithoutResolverInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutResolverInput | ReportUpsertWithWhereUniqueWithoutResolverInput[]
    createMany?: ReportCreateManyResolverInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutResolverInput | ReportUpdateWithWhereUniqueWithoutResolverInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutResolverInput | ReportUpdateManyWithWhereWithoutResolverInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type UserChallengeUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserChallengeCreateWithoutUserInput, UserChallengeUncheckedCreateWithoutUserInput> | UserChallengeCreateWithoutUserInput[] | UserChallengeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutUserInput | UserChallengeCreateOrConnectWithoutUserInput[]
    upsert?: UserChallengeUpsertWithWhereUniqueWithoutUserInput | UserChallengeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserChallengeCreateManyUserInputEnvelope
    set?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    disconnect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    delete?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    update?: UserChallengeUpdateWithWhereUniqueWithoutUserInput | UserChallengeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserChallengeUpdateManyWithWhereWithoutUserInput | UserChallengeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserChallengeScalarWhereInput | UserChallengeScalarWhereInput[]
  }

  export type UserChallengeUpdateManyWithoutVerified_byNestedInput = {
    create?: XOR<UserChallengeCreateWithoutVerified_byInput, UserChallengeUncheckedCreateWithoutVerified_byInput> | UserChallengeCreateWithoutVerified_byInput[] | UserChallengeUncheckedCreateWithoutVerified_byInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutVerified_byInput | UserChallengeCreateOrConnectWithoutVerified_byInput[]
    upsert?: UserChallengeUpsertWithWhereUniqueWithoutVerified_byInput | UserChallengeUpsertWithWhereUniqueWithoutVerified_byInput[]
    createMany?: UserChallengeCreateManyVerified_byInputEnvelope
    set?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    disconnect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    delete?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    update?: UserChallengeUpdateWithWhereUniqueWithoutVerified_byInput | UserChallengeUpdateWithWhereUniqueWithoutVerified_byInput[]
    updateMany?: UserChallengeUpdateManyWithWhereWithoutVerified_byInput | UserChallengeUpdateManyWithWhereWithoutVerified_byInput[]
    deleteMany?: UserChallengeScalarWhereInput | UserChallengeScalarWhereInput[]
  }

  export type UserProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type SponsorUpdateManyWithoutCreated_by_adminNestedInput = {
    create?: XOR<SponsorCreateWithoutCreated_by_adminInput, SponsorUncheckedCreateWithoutCreated_by_adminInput> | SponsorCreateWithoutCreated_by_adminInput[] | SponsorUncheckedCreateWithoutCreated_by_adminInput[]
    connectOrCreate?: SponsorCreateOrConnectWithoutCreated_by_adminInput | SponsorCreateOrConnectWithoutCreated_by_adminInput[]
    upsert?: SponsorUpsertWithWhereUniqueWithoutCreated_by_adminInput | SponsorUpsertWithWhereUniqueWithoutCreated_by_adminInput[]
    createMany?: SponsorCreateManyCreated_by_adminInputEnvelope
    set?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    disconnect?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    delete?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    connect?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    update?: SponsorUpdateWithWhereUniqueWithoutCreated_by_adminInput | SponsorUpdateWithWhereUniqueWithoutCreated_by_adminInput[]
    updateMany?: SponsorUpdateManyWithWhereWithoutCreated_by_adminInput | SponsorUpdateManyWithWhereWithoutCreated_by_adminInput[]
    deleteMany?: SponsorScalarWhereInput | SponsorScalarWhereInput[]
  }

  export type UserRedemptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRedemptionCreateWithoutUserInput, UserRedemptionUncheckedCreateWithoutUserInput> | UserRedemptionCreateWithoutUserInput[] | UserRedemptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRedemptionCreateOrConnectWithoutUserInput | UserRedemptionCreateOrConnectWithoutUserInput[]
    upsert?: UserRedemptionUpsertWithWhereUniqueWithoutUserInput | UserRedemptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRedemptionCreateManyUserInputEnvelope
    set?: UserRedemptionWhereUniqueInput | UserRedemptionWhereUniqueInput[]
    disconnect?: UserRedemptionWhereUniqueInput | UserRedemptionWhereUniqueInput[]
    delete?: UserRedemptionWhereUniqueInput | UserRedemptionWhereUniqueInput[]
    connect?: UserRedemptionWhereUniqueInput | UserRedemptionWhereUniqueInput[]
    update?: UserRedemptionUpdateWithWhereUniqueWithoutUserInput | UserRedemptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRedemptionUpdateManyWithWhereWithoutUserInput | UserRedemptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRedemptionScalarWhereInput | UserRedemptionScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AnnouncementUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AnnouncementCreateWithoutAdminInput, AnnouncementUncheckedCreateWithoutAdminInput> | AnnouncementCreateWithoutAdminInput[] | AnnouncementUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutAdminInput | AnnouncementCreateOrConnectWithoutAdminInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutAdminInput | AnnouncementUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AnnouncementCreateManyAdminInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutAdminInput | AnnouncementUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutAdminInput | AnnouncementUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type ChatbotConversationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ChatbotConversationCreateWithoutUserInput, ChatbotConversationUncheckedCreateWithoutUserInput>
    connectOrCreate?: ChatbotConversationCreateOrConnectWithoutUserInput
    upsert?: ChatbotConversationUpsertWithoutUserInput
    disconnect?: ChatbotConversationWhereInput | boolean
    delete?: ChatbotConversationWhereInput | boolean
    connect?: ChatbotConversationWhereUniqueInput
    update?: XOR<XOR<ChatbotConversationUpdateToOneWithWhereWithoutUserInput, ChatbotConversationUpdateWithoutUserInput>, ChatbotConversationUncheckedUpdateWithoutUserInput>
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CraftIdeaUncheckedUpdateManyWithoutGenerated_by_userNestedInput = {
    create?: XOR<CraftIdeaCreateWithoutGenerated_by_userInput, CraftIdeaUncheckedCreateWithoutGenerated_by_userInput> | CraftIdeaCreateWithoutGenerated_by_userInput[] | CraftIdeaUncheckedCreateWithoutGenerated_by_userInput[]
    connectOrCreate?: CraftIdeaCreateOrConnectWithoutGenerated_by_userInput | CraftIdeaCreateOrConnectWithoutGenerated_by_userInput[]
    upsert?: CraftIdeaUpsertWithWhereUniqueWithoutGenerated_by_userInput | CraftIdeaUpsertWithWhereUniqueWithoutGenerated_by_userInput[]
    createMany?: CraftIdeaCreateManyGenerated_by_userInputEnvelope
    set?: CraftIdeaWhereUniqueInput | CraftIdeaWhereUniqueInput[]
    disconnect?: CraftIdeaWhereUniqueInput | CraftIdeaWhereUniqueInput[]
    delete?: CraftIdeaWhereUniqueInput | CraftIdeaWhereUniqueInput[]
    connect?: CraftIdeaWhereUniqueInput | CraftIdeaWhereUniqueInput[]
    update?: CraftIdeaUpdateWithWhereUniqueWithoutGenerated_by_userInput | CraftIdeaUpdateWithWhereUniqueWithoutGenerated_by_userInput[]
    updateMany?: CraftIdeaUpdateManyWithWhereWithoutGenerated_by_userInput | CraftIdeaUpdateManyWithWhereWithoutGenerated_by_userInput[]
    deleteMany?: CraftIdeaScalarWhereInput | CraftIdeaScalarWhereInput[]
  }

  export type EcoChallengeUncheckedUpdateManyWithoutCreated_by_adminNestedInput = {
    create?: XOR<EcoChallengeCreateWithoutCreated_by_adminInput, EcoChallengeUncheckedCreateWithoutCreated_by_adminInput> | EcoChallengeCreateWithoutCreated_by_adminInput[] | EcoChallengeUncheckedCreateWithoutCreated_by_adminInput[]
    connectOrCreate?: EcoChallengeCreateOrConnectWithoutCreated_by_adminInput | EcoChallengeCreateOrConnectWithoutCreated_by_adminInput[]
    upsert?: EcoChallengeUpsertWithWhereUniqueWithoutCreated_by_adminInput | EcoChallengeUpsertWithWhereUniqueWithoutCreated_by_adminInput[]
    createMany?: EcoChallengeCreateManyCreated_by_adminInputEnvelope
    set?: EcoChallengeWhereUniqueInput | EcoChallengeWhereUniqueInput[]
    disconnect?: EcoChallengeWhereUniqueInput | EcoChallengeWhereUniqueInput[]
    delete?: EcoChallengeWhereUniqueInput | EcoChallengeWhereUniqueInput[]
    connect?: EcoChallengeWhereUniqueInput | EcoChallengeWhereUniqueInput[]
    update?: EcoChallengeUpdateWithWhereUniqueWithoutCreated_by_adminInput | EcoChallengeUpdateWithWhereUniqueWithoutCreated_by_adminInput[]
    updateMany?: EcoChallengeUpdateManyWithWhereWithoutCreated_by_adminInput | EcoChallengeUpdateManyWithWhereWithoutCreated_by_adminInput[]
    deleteMany?: EcoChallengeScalarWhereInput | EcoChallengeScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutUserInput | LikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutUserInput | LikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutUserInput | LikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type ModerationLogUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<ModerationLogCreateWithoutAdminInput, ModerationLogUncheckedCreateWithoutAdminInput> | ModerationLogCreateWithoutAdminInput[] | ModerationLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ModerationLogCreateOrConnectWithoutAdminInput | ModerationLogCreateOrConnectWithoutAdminInput[]
    upsert?: ModerationLogUpsertWithWhereUniqueWithoutAdminInput | ModerationLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: ModerationLogCreateManyAdminInputEnvelope
    set?: ModerationLogWhereUniqueInput | ModerationLogWhereUniqueInput[]
    disconnect?: ModerationLogWhereUniqueInput | ModerationLogWhereUniqueInput[]
    delete?: ModerationLogWhereUniqueInput | ModerationLogWhereUniqueInput[]
    connect?: ModerationLogWhereUniqueInput | ModerationLogWhereUniqueInput[]
    update?: ModerationLogUpdateWithWhereUniqueWithoutAdminInput | ModerationLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: ModerationLogUpdateManyWithWhereWithoutAdminInput | ModerationLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: ModerationLogScalarWhereInput | ModerationLogScalarWhereInput[]
  }

  export type ModerationLogUncheckedUpdateManyWithoutTarget_userNestedInput = {
    create?: XOR<ModerationLogCreateWithoutTarget_userInput, ModerationLogUncheckedCreateWithoutTarget_userInput> | ModerationLogCreateWithoutTarget_userInput[] | ModerationLogUncheckedCreateWithoutTarget_userInput[]
    connectOrCreate?: ModerationLogCreateOrConnectWithoutTarget_userInput | ModerationLogCreateOrConnectWithoutTarget_userInput[]
    upsert?: ModerationLogUpsertWithWhereUniqueWithoutTarget_userInput | ModerationLogUpsertWithWhereUniqueWithoutTarget_userInput[]
    createMany?: ModerationLogCreateManyTarget_userInputEnvelope
    set?: ModerationLogWhereUniqueInput | ModerationLogWhereUniqueInput[]
    disconnect?: ModerationLogWhereUniqueInput | ModerationLogWhereUniqueInput[]
    delete?: ModerationLogWhereUniqueInput | ModerationLogWhereUniqueInput[]
    connect?: ModerationLogWhereUniqueInput | ModerationLogWhereUniqueInput[]
    update?: ModerationLogUpdateWithWhereUniqueWithoutTarget_userInput | ModerationLogUpdateWithWhereUniqueWithoutTarget_userInput[]
    updateMany?: ModerationLogUpdateManyWithWhereWithoutTarget_userInput | ModerationLogUpdateManyWithWhereWithoutTarget_userInput[]
    deleteMany?: ModerationLogScalarWhereInput | ModerationLogScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutUserInput | PostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutUserInput | PostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostUpdateManyWithWhereWithoutUserInput | PostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutReporterNestedInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReporterInput | ReportUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReporterInput | ReportUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReporterInput | ReportUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutResolverNestedInput = {
    create?: XOR<ReportCreateWithoutResolverInput, ReportUncheckedCreateWithoutResolverInput> | ReportCreateWithoutResolverInput[] | ReportUncheckedCreateWithoutResolverInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutResolverInput | ReportCreateOrConnectWithoutResolverInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutResolverInput | ReportUpsertWithWhereUniqueWithoutResolverInput[]
    createMany?: ReportCreateManyResolverInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutResolverInput | ReportUpdateWithWhereUniqueWithoutResolverInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutResolverInput | ReportUpdateManyWithWhereWithoutResolverInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type UserChallengeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserChallengeCreateWithoutUserInput, UserChallengeUncheckedCreateWithoutUserInput> | UserChallengeCreateWithoutUserInput[] | UserChallengeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutUserInput | UserChallengeCreateOrConnectWithoutUserInput[]
    upsert?: UserChallengeUpsertWithWhereUniqueWithoutUserInput | UserChallengeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserChallengeCreateManyUserInputEnvelope
    set?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    disconnect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    delete?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    update?: UserChallengeUpdateWithWhereUniqueWithoutUserInput | UserChallengeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserChallengeUpdateManyWithWhereWithoutUserInput | UserChallengeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserChallengeScalarWhereInput | UserChallengeScalarWhereInput[]
  }

  export type UserChallengeUncheckedUpdateManyWithoutVerified_byNestedInput = {
    create?: XOR<UserChallengeCreateWithoutVerified_byInput, UserChallengeUncheckedCreateWithoutVerified_byInput> | UserChallengeCreateWithoutVerified_byInput[] | UserChallengeUncheckedCreateWithoutVerified_byInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutVerified_byInput | UserChallengeCreateOrConnectWithoutVerified_byInput[]
    upsert?: UserChallengeUpsertWithWhereUniqueWithoutVerified_byInput | UserChallengeUpsertWithWhereUniqueWithoutVerified_byInput[]
    createMany?: UserChallengeCreateManyVerified_byInputEnvelope
    set?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    disconnect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    delete?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    update?: UserChallengeUpdateWithWhereUniqueWithoutVerified_byInput | UserChallengeUpdateWithWhereUniqueWithoutVerified_byInput[]
    updateMany?: UserChallengeUpdateManyWithWhereWithoutVerified_byInput | UserChallengeUpdateManyWithWhereWithoutVerified_byInput[]
    deleteMany?: UserChallengeScalarWhereInput | UserChallengeScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type SponsorUncheckedUpdateManyWithoutCreated_by_adminNestedInput = {
    create?: XOR<SponsorCreateWithoutCreated_by_adminInput, SponsorUncheckedCreateWithoutCreated_by_adminInput> | SponsorCreateWithoutCreated_by_adminInput[] | SponsorUncheckedCreateWithoutCreated_by_adminInput[]
    connectOrCreate?: SponsorCreateOrConnectWithoutCreated_by_adminInput | SponsorCreateOrConnectWithoutCreated_by_adminInput[]
    upsert?: SponsorUpsertWithWhereUniqueWithoutCreated_by_adminInput | SponsorUpsertWithWhereUniqueWithoutCreated_by_adminInput[]
    createMany?: SponsorCreateManyCreated_by_adminInputEnvelope
    set?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    disconnect?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    delete?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    connect?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    update?: SponsorUpdateWithWhereUniqueWithoutCreated_by_adminInput | SponsorUpdateWithWhereUniqueWithoutCreated_by_adminInput[]
    updateMany?: SponsorUpdateManyWithWhereWithoutCreated_by_adminInput | SponsorUpdateManyWithWhereWithoutCreated_by_adminInput[]
    deleteMany?: SponsorScalarWhereInput | SponsorScalarWhereInput[]
  }

  export type UserRedemptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRedemptionCreateWithoutUserInput, UserRedemptionUncheckedCreateWithoutUserInput> | UserRedemptionCreateWithoutUserInput[] | UserRedemptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRedemptionCreateOrConnectWithoutUserInput | UserRedemptionCreateOrConnectWithoutUserInput[]
    upsert?: UserRedemptionUpsertWithWhereUniqueWithoutUserInput | UserRedemptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRedemptionCreateManyUserInputEnvelope
    set?: UserRedemptionWhereUniqueInput | UserRedemptionWhereUniqueInput[]
    disconnect?: UserRedemptionWhereUniqueInput | UserRedemptionWhereUniqueInput[]
    delete?: UserRedemptionWhereUniqueInput | UserRedemptionWhereUniqueInput[]
    connect?: UserRedemptionWhereUniqueInput | UserRedemptionWhereUniqueInput[]
    update?: UserRedemptionUpdateWithWhereUniqueWithoutUserInput | UserRedemptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRedemptionUpdateManyWithWhereWithoutUserInput | UserRedemptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRedemptionScalarWhereInput | UserRedemptionScalarWhereInput[]
  }

  export type UserProfileCreateskipped_challengesInput = {
    set: number[]
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserProfileUpdateskipped_challengesInput = {
    set?: number[]
    push?: number | number[]
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutCraftIdeasInput = {
    create?: XOR<UserCreateWithoutCraftIdeasInput, UserUncheckedCreateWithoutCraftIdeasInput>
    connectOrCreate?: UserCreateOrConnectWithoutCraftIdeasInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutCraftIdeasNestedInput = {
    create?: XOR<UserCreateWithoutCraftIdeasInput, UserUncheckedCreateWithoutCraftIdeasInput>
    connectOrCreate?: UserCreateOrConnectWithoutCraftIdeasInput
    upsert?: UserUpsertWithoutCraftIdeasInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCraftIdeasInput, UserUpdateWithoutCraftIdeasInput>, UserUncheckedUpdateWithoutCraftIdeasInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutChatbotConversationsInput = {
    create?: XOR<UserCreateWithoutChatbotConversationsInput, UserUncheckedCreateWithoutChatbotConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatbotConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type ChatbotMessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<ChatbotMessageCreateWithoutConversationInput, ChatbotMessageUncheckedCreateWithoutConversationInput> | ChatbotMessageCreateWithoutConversationInput[] | ChatbotMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ChatbotMessageCreateOrConnectWithoutConversationInput | ChatbotMessageCreateOrConnectWithoutConversationInput[]
    createMany?: ChatbotMessageCreateManyConversationInputEnvelope
    connect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
  }

  export type ChatbotMessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ChatbotMessageCreateWithoutConversationInput, ChatbotMessageUncheckedCreateWithoutConversationInput> | ChatbotMessageCreateWithoutConversationInput[] | ChatbotMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ChatbotMessageCreateOrConnectWithoutConversationInput | ChatbotMessageCreateOrConnectWithoutConversationInput[]
    createMany?: ChatbotMessageCreateManyConversationInputEnvelope
    connect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutChatbotConversationsNestedInput = {
    create?: XOR<UserCreateWithoutChatbotConversationsInput, UserUncheckedCreateWithoutChatbotConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatbotConversationsInput
    upsert?: UserUpsertWithoutChatbotConversationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatbotConversationsInput, UserUpdateWithoutChatbotConversationsInput>, UserUncheckedUpdateWithoutChatbotConversationsInput>
  }

  export type ChatbotMessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ChatbotMessageCreateWithoutConversationInput, ChatbotMessageUncheckedCreateWithoutConversationInput> | ChatbotMessageCreateWithoutConversationInput[] | ChatbotMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ChatbotMessageCreateOrConnectWithoutConversationInput | ChatbotMessageCreateOrConnectWithoutConversationInput[]
    upsert?: ChatbotMessageUpsertWithWhereUniqueWithoutConversationInput | ChatbotMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ChatbotMessageCreateManyConversationInputEnvelope
    set?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    disconnect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    delete?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    connect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    update?: ChatbotMessageUpdateWithWhereUniqueWithoutConversationInput | ChatbotMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ChatbotMessageUpdateManyWithWhereWithoutConversationInput | ChatbotMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ChatbotMessageScalarWhereInput | ChatbotMessageScalarWhereInput[]
  }

  export type ChatbotMessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ChatbotMessageCreateWithoutConversationInput, ChatbotMessageUncheckedCreateWithoutConversationInput> | ChatbotMessageCreateWithoutConversationInput[] | ChatbotMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ChatbotMessageCreateOrConnectWithoutConversationInput | ChatbotMessageCreateOrConnectWithoutConversationInput[]
    upsert?: ChatbotMessageUpsertWithWhereUniqueWithoutConversationInput | ChatbotMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ChatbotMessageCreateManyConversationInputEnvelope
    set?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    disconnect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    delete?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    connect?: ChatbotMessageWhereUniqueInput | ChatbotMessageWhereUniqueInput[]
    update?: ChatbotMessageUpdateWithWhereUniqueWithoutConversationInput | ChatbotMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ChatbotMessageUpdateManyWithWhereWithoutConversationInput | ChatbotMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ChatbotMessageScalarWhereInput | ChatbotMessageScalarWhereInput[]
  }

  export type ChatbotConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatbotConversationCreateWithoutMessagesInput, ChatbotConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatbotConversationCreateOrConnectWithoutMessagesInput
    connect?: ChatbotConversationWhereUniqueInput
  }

  export type EnumMessageSenderFieldUpdateOperationsInput = {
    set?: $Enums.MessageSender
  }

  export type ChatbotConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatbotConversationCreateWithoutMessagesInput, ChatbotConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatbotConversationCreateOrConnectWithoutMessagesInput
    upsert?: ChatbotConversationUpsertWithoutMessagesInput
    connect?: ChatbotConversationWhereUniqueInput
    update?: XOR<XOR<ChatbotConversationUpdateToOneWithWhereWithoutMessagesInput, ChatbotConversationUpdateWithoutMessagesInput>, ChatbotConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type PostCreatetagsInput = {
    set: string[]
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutPostInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type ReportCreateNestedManyWithoutReported_postInput = {
    create?: XOR<ReportCreateWithoutReported_postInput, ReportUncheckedCreateWithoutReported_postInput> | ReportCreateWithoutReported_postInput[] | ReportUncheckedCreateWithoutReported_postInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReported_postInput | ReportCreateOrConnectWithoutReported_postInput[]
    createMany?: ReportCreateManyReported_postInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutReported_postInput = {
    create?: XOR<ReportCreateWithoutReported_postInput, ReportUncheckedCreateWithoutReported_postInput> | ReportCreateWithoutReported_postInput[] | ReportUncheckedCreateWithoutReported_postInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReported_postInput | ReportCreateOrConnectWithoutReported_postInput[]
    createMany?: ReportCreateManyReported_postInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type PostUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumCategoryFieldUpdateOperationsInput = {
    set?: $Enums.Category
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutPostNestedInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPostInput | LikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPostInput | LikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPostInput | LikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostsInput, UserUpdateWithoutPostsInput>, UserUncheckedUpdateWithoutPostsInput>
  }

  export type ReportUpdateManyWithoutReported_postNestedInput = {
    create?: XOR<ReportCreateWithoutReported_postInput, ReportUncheckedCreateWithoutReported_postInput> | ReportCreateWithoutReported_postInput[] | ReportUncheckedCreateWithoutReported_postInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReported_postInput | ReportCreateOrConnectWithoutReported_postInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReported_postInput | ReportUpsertWithWhereUniqueWithoutReported_postInput[]
    createMany?: ReportCreateManyReported_postInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReported_postInput | ReportUpdateWithWhereUniqueWithoutReported_postInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReported_postInput | ReportUpdateManyWithWhereWithoutReported_postInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPostInput | LikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPostInput | LikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPostInput | LikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutReported_postNestedInput = {
    create?: XOR<ReportCreateWithoutReported_postInput, ReportUncheckedCreateWithoutReported_postInput> | ReportCreateWithoutReported_postInput[] | ReportUncheckedCreateWithoutReported_postInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReported_postInput | ReportCreateOrConnectWithoutReported_postInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReported_postInput | ReportUpsertWithWhereUniqueWithoutReported_postInput[]
    createMany?: ReportCreateManyReported_postInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReported_postInput | ReportUpdateWithWhereUniqueWithoutReported_postInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReported_postInput | ReportUpdateManyWithWhereWithoutReported_postInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type ReportCreateNestedManyWithoutReported_commentInput = {
    create?: XOR<ReportCreateWithoutReported_commentInput, ReportUncheckedCreateWithoutReported_commentInput> | ReportCreateWithoutReported_commentInput[] | ReportUncheckedCreateWithoutReported_commentInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReported_commentInput | ReportCreateOrConnectWithoutReported_commentInput[]
    createMany?: ReportCreateManyReported_commentInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutReported_commentInput = {
    create?: XOR<ReportCreateWithoutReported_commentInput, ReportUncheckedCreateWithoutReported_commentInput> | ReportCreateWithoutReported_commentInput[] | ReportUncheckedCreateWithoutReported_commentInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReported_commentInput | ReportCreateOrConnectWithoutReported_commentInput[]
    createMany?: ReportCreateManyReported_commentInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type ReportUpdateManyWithoutReported_commentNestedInput = {
    create?: XOR<ReportCreateWithoutReported_commentInput, ReportUncheckedCreateWithoutReported_commentInput> | ReportCreateWithoutReported_commentInput[] | ReportUncheckedCreateWithoutReported_commentInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReported_commentInput | ReportCreateOrConnectWithoutReported_commentInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReported_commentInput | ReportUpsertWithWhereUniqueWithoutReported_commentInput[]
    createMany?: ReportCreateManyReported_commentInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReported_commentInput | ReportUpdateWithWhereUniqueWithoutReported_commentInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReported_commentInput | ReportUpdateManyWithWhereWithoutReported_commentInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutReported_commentNestedInput = {
    create?: XOR<ReportCreateWithoutReported_commentInput, ReportUncheckedCreateWithoutReported_commentInput> | ReportCreateWithoutReported_commentInput[] | ReportUncheckedCreateWithoutReported_commentInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReported_commentInput | ReportCreateOrConnectWithoutReported_commentInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReported_commentInput | ReportUpsertWithWhereUniqueWithoutReported_commentInput[]
    createMany?: ReportCreateManyReported_commentInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReported_commentInput | ReportUpdateWithWhereUniqueWithoutReported_commentInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReported_commentInput | ReportUpdateManyWithWhereWithoutReported_commentInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutLikesInput = {
    create?: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PostCreateOrConnectWithoutLikesInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLikesInput = {
    create?: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesInput
    connect?: UserWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PostCreateOrConnectWithoutLikesInput
    upsert?: PostUpsertWithoutLikesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutLikesInput, PostUpdateWithoutLikesInput>, PostUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesInput
    upsert?: UserUpsertWithoutLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikesInput, UserUpdateWithoutLikesInput>, UserUncheckedUpdateWithoutLikesInput>
  }

  export type UserCreateNestedOneWithoutCreatedChallengesInput = {
    create?: XOR<UserCreateWithoutCreatedChallengesInput, UserUncheckedCreateWithoutCreatedChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedChallengesInput
    connect?: UserWhereUniqueInput
  }

  export type UserChallengeCreateNestedManyWithoutChallengeInput = {
    create?: XOR<UserChallengeCreateWithoutChallengeInput, UserChallengeUncheckedCreateWithoutChallengeInput> | UserChallengeCreateWithoutChallengeInput[] | UserChallengeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutChallengeInput | UserChallengeCreateOrConnectWithoutChallengeInput[]
    createMany?: UserChallengeCreateManyChallengeInputEnvelope
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
  }

  export type UserChallengeUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<UserChallengeCreateWithoutChallengeInput, UserChallengeUncheckedCreateWithoutChallengeInput> | UserChallengeCreateWithoutChallengeInput[] | UserChallengeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutChallengeInput | UserChallengeCreateOrConnectWithoutChallengeInput[]
    createMany?: UserChallengeCreateManyChallengeInputEnvelope
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
  }

  export type EnumChallengeSourceFieldUpdateOperationsInput = {
    set?: $Enums.ChallengeSource
  }

  export type EnumMaterialTypeFieldUpdateOperationsInput = {
    set?: $Enums.MaterialType
  }

  export type EnumChallengeCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ChallengeCategory
  }

  export type UserUpdateOneWithoutCreatedChallengesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedChallengesInput, UserUncheckedCreateWithoutCreatedChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedChallengesInput
    upsert?: UserUpsertWithoutCreatedChallengesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedChallengesInput, UserUpdateWithoutCreatedChallengesInput>, UserUncheckedUpdateWithoutCreatedChallengesInput>
  }

  export type UserChallengeUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<UserChallengeCreateWithoutChallengeInput, UserChallengeUncheckedCreateWithoutChallengeInput> | UserChallengeCreateWithoutChallengeInput[] | UserChallengeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutChallengeInput | UserChallengeCreateOrConnectWithoutChallengeInput[]
    upsert?: UserChallengeUpsertWithWhereUniqueWithoutChallengeInput | UserChallengeUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: UserChallengeCreateManyChallengeInputEnvelope
    set?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    disconnect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    delete?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    update?: UserChallengeUpdateWithWhereUniqueWithoutChallengeInput | UserChallengeUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: UserChallengeUpdateManyWithWhereWithoutChallengeInput | UserChallengeUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: UserChallengeScalarWhereInput | UserChallengeScalarWhereInput[]
  }

  export type UserChallengeUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<UserChallengeCreateWithoutChallengeInput, UserChallengeUncheckedCreateWithoutChallengeInput> | UserChallengeCreateWithoutChallengeInput[] | UserChallengeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutChallengeInput | UserChallengeCreateOrConnectWithoutChallengeInput[]
    upsert?: UserChallengeUpsertWithWhereUniqueWithoutChallengeInput | UserChallengeUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: UserChallengeCreateManyChallengeInputEnvelope
    set?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    disconnect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    delete?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    update?: UserChallengeUpdateWithWhereUniqueWithoutChallengeInput | UserChallengeUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: UserChallengeUpdateManyWithWhereWithoutChallengeInput | UserChallengeUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: UserChallengeScalarWhereInput | UserChallengeScalarWhereInput[]
  }

  export type EcoChallengeCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<EcoChallengeCreateWithoutParticipantsInput, EcoChallengeUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: EcoChallengeCreateOrConnectWithoutParticipantsInput
    connect?: EcoChallengeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserChallengesInput = {
    create?: XOR<UserCreateWithoutUserChallengesInput, UserUncheckedCreateWithoutUserChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserChallengesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVerifiedChallengesInput = {
    create?: XOR<UserCreateWithoutVerifiedChallengesInput, UserUncheckedCreateWithoutVerifiedChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifiedChallengesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumChallengeStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChallengeStatus
  }

  export type NullableEnumVerificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.VerificationType | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EcoChallengeUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<EcoChallengeCreateWithoutParticipantsInput, EcoChallengeUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: EcoChallengeCreateOrConnectWithoutParticipantsInput
    upsert?: EcoChallengeUpsertWithoutParticipantsInput
    connect?: EcoChallengeWhereUniqueInput
    update?: XOR<XOR<EcoChallengeUpdateToOneWithWhereWithoutParticipantsInput, EcoChallengeUpdateWithoutParticipantsInput>, EcoChallengeUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutUserChallengesNestedInput = {
    create?: XOR<UserCreateWithoutUserChallengesInput, UserUncheckedCreateWithoutUserChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserChallengesInput
    upsert?: UserUpsertWithoutUserChallengesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserChallengesInput, UserUpdateWithoutUserChallengesInput>, UserUncheckedUpdateWithoutUserChallengesInput>
  }

  export type UserUpdateOneWithoutVerifiedChallengesNestedInput = {
    create?: XOR<UserCreateWithoutVerifiedChallengesInput, UserUncheckedCreateWithoutVerifiedChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifiedChallengesInput
    upsert?: UserUpsertWithoutVerifiedChallengesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerifiedChallengesInput, UserUpdateWithoutVerifiedChallengesInput>, UserUncheckedUpdateWithoutVerifiedChallengesInput>
  }

  export type CommentCreateNestedOneWithoutReportsInput = {
    create?: XOR<CommentCreateWithoutReportsInput, CommentUncheckedCreateWithoutReportsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutReportsInput
    connect?: CommentWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutReportsInput = {
    create?: XOR<PostCreateWithoutReportsInput, PostUncheckedCreateWithoutReportsInput>
    connectOrCreate?: PostCreateOrConnectWithoutReportsInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportsFiledInput = {
    create?: XOR<UserCreateWithoutReportsFiledInput, UserUncheckedCreateWithoutReportsFiledInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsFiledInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportsResolvedInput = {
    create?: XOR<UserCreateWithoutReportsResolvedInput, UserUncheckedCreateWithoutReportsResolvedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsResolvedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type CommentUpdateOneWithoutReportsNestedInput = {
    create?: XOR<CommentCreateWithoutReportsInput, CommentUncheckedCreateWithoutReportsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutReportsInput
    upsert?: CommentUpsertWithoutReportsInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutReportsInput, CommentUpdateWithoutReportsInput>, CommentUncheckedUpdateWithoutReportsInput>
  }

  export type PostUpdateOneWithoutReportsNestedInput = {
    create?: XOR<PostCreateWithoutReportsInput, PostUncheckedCreateWithoutReportsInput>
    connectOrCreate?: PostCreateOrConnectWithoutReportsInput
    upsert?: PostUpsertWithoutReportsInput
    disconnect?: PostWhereInput | boolean
    delete?: PostWhereInput | boolean
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutReportsInput, PostUpdateWithoutReportsInput>, PostUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateOneRequiredWithoutReportsFiledNestedInput = {
    create?: XOR<UserCreateWithoutReportsFiledInput, UserUncheckedCreateWithoutReportsFiledInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsFiledInput
    upsert?: UserUpsertWithoutReportsFiledInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsFiledInput, UserUpdateWithoutReportsFiledInput>, UserUncheckedUpdateWithoutReportsFiledInput>
  }

  export type UserUpdateOneWithoutReportsResolvedNestedInput = {
    create?: XOR<UserCreateWithoutReportsResolvedInput, UserUncheckedCreateWithoutReportsResolvedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsResolvedInput
    upsert?: UserUpsertWithoutReportsResolvedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsResolvedInput, UserUpdateWithoutReportsResolvedInput>, UserUncheckedUpdateWithoutReportsResolvedInput>
  }

  export type UserCreateNestedOneWithoutAnnouncementsInput = {
    create?: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAnnouncementsNestedInput = {
    create?: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementsInput
    upsert?: UserUpsertWithoutAnnouncementsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnnouncementsInput, UserUpdateWithoutAnnouncementsInput>, UserUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type UserCreateNestedOneWithoutModerationLogsInput = {
    create?: XOR<UserCreateWithoutModerationLogsInput, UserUncheckedCreateWithoutModerationLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutModerationLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutModerationTargetsInput = {
    create?: XOR<UserCreateWithoutModerationTargetsInput, UserUncheckedCreateWithoutModerationTargetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutModerationTargetsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumModerationActionFieldUpdateOperationsInput = {
    set?: $Enums.ModerationAction
  }

  export type UserUpdateOneWithoutModerationLogsNestedInput = {
    create?: XOR<UserCreateWithoutModerationLogsInput, UserUncheckedCreateWithoutModerationLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutModerationLogsInput
    upsert?: UserUpsertWithoutModerationLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutModerationLogsInput, UserUpdateWithoutModerationLogsInput>, UserUncheckedUpdateWithoutModerationLogsInput>
  }

  export type UserUpdateOneWithoutModerationTargetsNestedInput = {
    create?: XOR<UserCreateWithoutModerationTargetsInput, UserUncheckedCreateWithoutModerationTargetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutModerationTargetsInput
    upsert?: UserUpsertWithoutModerationTargetsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutModerationTargetsInput, UserUpdateWithoutModerationTargetsInput>, UserUncheckedUpdateWithoutModerationTargetsInput>
  }

  export type UserCreateNestedOneWithoutCreatedSponsorsInput = {
    create?: XOR<UserCreateWithoutCreatedSponsorsInput, UserUncheckedCreateWithoutCreatedSponsorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSponsorsInput
    connect?: UserWhereUniqueInput
  }

  export type SponsorRewardCreateNestedManyWithoutSponsorInput = {
    create?: XOR<SponsorRewardCreateWithoutSponsorInput, SponsorRewardUncheckedCreateWithoutSponsorInput> | SponsorRewardCreateWithoutSponsorInput[] | SponsorRewardUncheckedCreateWithoutSponsorInput[]
    connectOrCreate?: SponsorRewardCreateOrConnectWithoutSponsorInput | SponsorRewardCreateOrConnectWithoutSponsorInput[]
    createMany?: SponsorRewardCreateManySponsorInputEnvelope
    connect?: SponsorRewardWhereUniqueInput | SponsorRewardWhereUniqueInput[]
  }

  export type SponsorRewardUncheckedCreateNestedManyWithoutSponsorInput = {
    create?: XOR<SponsorRewardCreateWithoutSponsorInput, SponsorRewardUncheckedCreateWithoutSponsorInput> | SponsorRewardCreateWithoutSponsorInput[] | SponsorRewardUncheckedCreateWithoutSponsorInput[]
    connectOrCreate?: SponsorRewardCreateOrConnectWithoutSponsorInput | SponsorRewardCreateOrConnectWithoutSponsorInput[]
    createMany?: SponsorRewardCreateManySponsorInputEnvelope
    connect?: SponsorRewardWhereUniqueInput | SponsorRewardWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCreatedSponsorsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedSponsorsInput, UserUncheckedCreateWithoutCreatedSponsorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSponsorsInput
    upsert?: UserUpsertWithoutCreatedSponsorsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedSponsorsInput, UserUpdateWithoutCreatedSponsorsInput>, UserUncheckedUpdateWithoutCreatedSponsorsInput>
  }

  export type SponsorRewardUpdateManyWithoutSponsorNestedInput = {
    create?: XOR<SponsorRewardCreateWithoutSponsorInput, SponsorRewardUncheckedCreateWithoutSponsorInput> | SponsorRewardCreateWithoutSponsorInput[] | SponsorRewardUncheckedCreateWithoutSponsorInput[]
    connectOrCreate?: SponsorRewardCreateOrConnectWithoutSponsorInput | SponsorRewardCreateOrConnectWithoutSponsorInput[]
    upsert?: SponsorRewardUpsertWithWhereUniqueWithoutSponsorInput | SponsorRewardUpsertWithWhereUniqueWithoutSponsorInput[]
    createMany?: SponsorRewardCreateManySponsorInputEnvelope
    set?: SponsorRewardWhereUniqueInput | SponsorRewardWhereUniqueInput[]
    disconnect?: SponsorRewardWhereUniqueInput | SponsorRewardWhereUniqueInput[]
    delete?: SponsorRewardWhereUniqueInput | SponsorRewardWhereUniqueInput[]
    connect?: SponsorRewardWhereUniqueInput | SponsorRewardWhereUniqueInput[]
    update?: SponsorRewardUpdateWithWhereUniqueWithoutSponsorInput | SponsorRewardUpdateWithWhereUniqueWithoutSponsorInput[]
    updateMany?: SponsorRewardUpdateManyWithWhereWithoutSponsorInput | SponsorRewardUpdateManyWithWhereWithoutSponsorInput[]
    deleteMany?: SponsorRewardScalarWhereInput | SponsorRewardScalarWhereInput[]
  }

  export type SponsorRewardUncheckedUpdateManyWithoutSponsorNestedInput = {
    create?: XOR<SponsorRewardCreateWithoutSponsorInput, SponsorRewardUncheckedCreateWithoutSponsorInput> | SponsorRewardCreateWithoutSponsorInput[] | SponsorRewardUncheckedCreateWithoutSponsorInput[]
    connectOrCreate?: SponsorRewardCreateOrConnectWithoutSponsorInput | SponsorRewardCreateOrConnectWithoutSponsorInput[]
    upsert?: SponsorRewardUpsertWithWhereUniqueWithoutSponsorInput | SponsorRewardUpsertWithWhereUniqueWithoutSponsorInput[]
    createMany?: SponsorRewardCreateManySponsorInputEnvelope
    set?: SponsorRewardWhereUniqueInput | SponsorRewardWhereUniqueInput[]
    disconnect?: SponsorRewardWhereUniqueInput | SponsorRewardWhereUniqueInput[]
    delete?: SponsorRewardWhereUniqueInput | SponsorRewardWhereUniqueInput[]
    connect?: SponsorRewardWhereUniqueInput | SponsorRewardWhereUniqueInput[]
    update?: SponsorRewardUpdateWithWhereUniqueWithoutSponsorInput | SponsorRewardUpdateWithWhereUniqueWithoutSponsorInput[]
    updateMany?: SponsorRewardUpdateManyWithWhereWithoutSponsorInput | SponsorRewardUpdateManyWithWhereWithoutSponsorInput[]
    deleteMany?: SponsorRewardScalarWhereInput | SponsorRewardScalarWhereInput[]
  }

  export type SponsorCreateNestedOneWithoutRewardsInput = {
    create?: XOR<SponsorCreateWithoutRewardsInput, SponsorUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: SponsorCreateOrConnectWithoutRewardsInput
    connect?: SponsorWhereUniqueInput
  }

  export type UserRedemptionCreateNestedManyWithoutRewardInput = {
    create?: XOR<UserRedemptionCreateWithoutRewardInput, UserRedemptionUncheckedCreateWithoutRewardInput> | UserRedemptionCreateWithoutRewardInput[] | UserRedemptionUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: UserRedemptionCreateOrConnectWithoutRewardInput | UserRedemptionCreateOrConnectWithoutRewardInput[]
    createMany?: UserRedemptionCreateManyRewardInputEnvelope
    connect?: UserRedemptionWhereUniqueInput | UserRedemptionWhereUniqueInput[]
  }

  export type UserRedemptionUncheckedCreateNestedManyWithoutRewardInput = {
    create?: XOR<UserRedemptionCreateWithoutRewardInput, UserRedemptionUncheckedCreateWithoutRewardInput> | UserRedemptionCreateWithoutRewardInput[] | UserRedemptionUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: UserRedemptionCreateOrConnectWithoutRewardInput | UserRedemptionCreateOrConnectWithoutRewardInput[]
    createMany?: UserRedemptionCreateManyRewardInputEnvelope
    connect?: UserRedemptionWhereUniqueInput | UserRedemptionWhereUniqueInput[]
  }

  export type SponsorUpdateOneRequiredWithoutRewardsNestedInput = {
    create?: XOR<SponsorCreateWithoutRewardsInput, SponsorUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: SponsorCreateOrConnectWithoutRewardsInput
    upsert?: SponsorUpsertWithoutRewardsInput
    connect?: SponsorWhereUniqueInput
    update?: XOR<XOR<SponsorUpdateToOneWithWhereWithoutRewardsInput, SponsorUpdateWithoutRewardsInput>, SponsorUncheckedUpdateWithoutRewardsInput>
  }

  export type UserRedemptionUpdateManyWithoutRewardNestedInput = {
    create?: XOR<UserRedemptionCreateWithoutRewardInput, UserRedemptionUncheckedCreateWithoutRewardInput> | UserRedemptionCreateWithoutRewardInput[] | UserRedemptionUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: UserRedemptionCreateOrConnectWithoutRewardInput | UserRedemptionCreateOrConnectWithoutRewardInput[]
    upsert?: UserRedemptionUpsertWithWhereUniqueWithoutRewardInput | UserRedemptionUpsertWithWhereUniqueWithoutRewardInput[]
    createMany?: UserRedemptionCreateManyRewardInputEnvelope
    set?: UserRedemptionWhereUniqueInput | UserRedemptionWhereUniqueInput[]
    disconnect?: UserRedemptionWhereUniqueInput | UserRedemptionWhereUniqueInput[]
    delete?: UserRedemptionWhereUniqueInput | UserRedemptionWhereUniqueInput[]
    connect?: UserRedemptionWhereUniqueInput | UserRedemptionWhereUniqueInput[]
    update?: UserRedemptionUpdateWithWhereUniqueWithoutRewardInput | UserRedemptionUpdateWithWhereUniqueWithoutRewardInput[]
    updateMany?: UserRedemptionUpdateManyWithWhereWithoutRewardInput | UserRedemptionUpdateManyWithWhereWithoutRewardInput[]
    deleteMany?: UserRedemptionScalarWhereInput | UserRedemptionScalarWhereInput[]
  }

  export type UserRedemptionUncheckedUpdateManyWithoutRewardNestedInput = {
    create?: XOR<UserRedemptionCreateWithoutRewardInput, UserRedemptionUncheckedCreateWithoutRewardInput> | UserRedemptionCreateWithoutRewardInput[] | UserRedemptionUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: UserRedemptionCreateOrConnectWithoutRewardInput | UserRedemptionCreateOrConnectWithoutRewardInput[]
    upsert?: UserRedemptionUpsertWithWhereUniqueWithoutRewardInput | UserRedemptionUpsertWithWhereUniqueWithoutRewardInput[]
    createMany?: UserRedemptionCreateManyRewardInputEnvelope
    set?: UserRedemptionWhereUniqueInput | UserRedemptionWhereUniqueInput[]
    disconnect?: UserRedemptionWhereUniqueInput | UserRedemptionWhereUniqueInput[]
    delete?: UserRedemptionWhereUniqueInput | UserRedemptionWhereUniqueInput[]
    connect?: UserRedemptionWhereUniqueInput | UserRedemptionWhereUniqueInput[]
    update?: UserRedemptionUpdateWithWhereUniqueWithoutRewardInput | UserRedemptionUpdateWithWhereUniqueWithoutRewardInput[]
    updateMany?: UserRedemptionUpdateManyWithWhereWithoutRewardInput | UserRedemptionUpdateManyWithWhereWithoutRewardInput[]
    deleteMany?: UserRedemptionScalarWhereInput | UserRedemptionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRedemptionsInput = {
    create?: XOR<UserCreateWithoutRedemptionsInput, UserUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRedemptionsInput
    connect?: UserWhereUniqueInput
  }

  export type SponsorRewardCreateNestedOneWithoutClaimsInput = {
    create?: XOR<SponsorRewardCreateWithoutClaimsInput, SponsorRewardUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: SponsorRewardCreateOrConnectWithoutClaimsInput
    connect?: SponsorRewardWhereUniqueInput
  }

  export type EnumRedemptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.RedemptionStatus
  }

  export type UserUpdateOneRequiredWithoutRedemptionsNestedInput = {
    create?: XOR<UserCreateWithoutRedemptionsInput, UserUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRedemptionsInput
    upsert?: UserUpsertWithoutRedemptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRedemptionsInput, UserUpdateWithoutRedemptionsInput>, UserUncheckedUpdateWithoutRedemptionsInput>
  }

  export type SponsorRewardUpdateOneRequiredWithoutClaimsNestedInput = {
    create?: XOR<SponsorRewardCreateWithoutClaimsInput, SponsorRewardUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: SponsorRewardCreateOrConnectWithoutClaimsInput
    upsert?: SponsorRewardUpsertWithoutClaimsInput
    connect?: SponsorRewardWhereUniqueInput
    update?: XOR<XOR<SponsorRewardUpdateToOneWithWhereWithoutClaimsInput, SponsorRewardUpdateWithoutClaimsInput>, SponsorRewardUncheckedUpdateWithoutClaimsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMessageSenderFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageSender | EnumMessageSenderFieldRefInput<$PrismaModel>
    in?: $Enums.MessageSender[] | ListEnumMessageSenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageSender[] | ListEnumMessageSenderFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageSenderFilter<$PrismaModel> | $Enums.MessageSender
  }

  export type NestedEnumMessageSenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageSender | EnumMessageSenderFieldRefInput<$PrismaModel>
    in?: $Enums.MessageSender[] | ListEnumMessageSenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageSender[] | ListEnumMessageSenderFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageSenderWithAggregatesFilter<$PrismaModel> | $Enums.MessageSender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageSenderFilter<$PrismaModel>
    _max?: NestedEnumMessageSenderFilter<$PrismaModel>
  }

  export type NestedEnumCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryFilter<$PrismaModel> | $Enums.Category
  }

  export type NestedEnumCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryWithAggregatesFilter<$PrismaModel> | $Enums.Category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryFilter<$PrismaModel>
    _max?: NestedEnumCategoryFilter<$PrismaModel>
  }

  export type NestedEnumChallengeSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeSource | EnumChallengeSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeSource[] | ListEnumChallengeSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeSource[] | ListEnumChallengeSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeSourceFilter<$PrismaModel> | $Enums.ChallengeSource
  }

  export type NestedEnumMaterialTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialType | EnumMaterialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialType[] | ListEnumMaterialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialType[] | ListEnumMaterialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialTypeFilter<$PrismaModel> | $Enums.MaterialType
  }

  export type NestedEnumChallengeCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeCategory | EnumChallengeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeCategory[] | ListEnumChallengeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeCategory[] | ListEnumChallengeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeCategoryFilter<$PrismaModel> | $Enums.ChallengeCategory
  }

  export type NestedEnumChallengeSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeSource | EnumChallengeSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeSource[] | ListEnumChallengeSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeSource[] | ListEnumChallengeSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeSourceWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeSourceFilter<$PrismaModel>
    _max?: NestedEnumChallengeSourceFilter<$PrismaModel>
  }

  export type NestedEnumMaterialTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialType | EnumMaterialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialType[] | ListEnumMaterialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialType[] | ListEnumMaterialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialTypeWithAggregatesFilter<$PrismaModel> | $Enums.MaterialType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaterialTypeFilter<$PrismaModel>
    _max?: NestedEnumMaterialTypeFilter<$PrismaModel>
  }

  export type NestedEnumChallengeCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeCategory | EnumChallengeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeCategory[] | ListEnumChallengeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeCategory[] | ListEnumChallengeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeCategoryFilter<$PrismaModel>
    _max?: NestedEnumChallengeCategoryFilter<$PrismaModel>
  }

  export type NestedEnumChallengeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatus | EnumChallengeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeStatusFilter<$PrismaModel> | $Enums.ChallengeStatus
  }

  export type NestedEnumVerificationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationType | EnumVerificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerificationTypeNullableFilter<$PrismaModel> | $Enums.VerificationType | null
  }

  export type NestedEnumChallengeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatus | EnumChallengeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeStatusFilter<$PrismaModel>
    _max?: NestedEnumChallengeStatusFilter<$PrismaModel>
  }

  export type NestedEnumVerificationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationType | EnumVerificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerificationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.VerificationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVerificationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumVerificationTypeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type NestedEnumModerationActionFilter<$PrismaModel = never> = {
    equals?: $Enums.ModerationAction | EnumModerationActionFieldRefInput<$PrismaModel>
    in?: $Enums.ModerationAction[] | ListEnumModerationActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModerationAction[] | ListEnumModerationActionFieldRefInput<$PrismaModel>
    not?: NestedEnumModerationActionFilter<$PrismaModel> | $Enums.ModerationAction
  }

  export type NestedEnumModerationActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModerationAction | EnumModerationActionFieldRefInput<$PrismaModel>
    in?: $Enums.ModerationAction[] | ListEnumModerationActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModerationAction[] | ListEnumModerationActionFieldRefInput<$PrismaModel>
    not?: NestedEnumModerationActionWithAggregatesFilter<$PrismaModel> | $Enums.ModerationAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModerationActionFilter<$PrismaModel>
    _max?: NestedEnumModerationActionFilter<$PrismaModel>
  }

  export type NestedEnumRedemptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RedemptionStatus | EnumRedemptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RedemptionStatus[] | ListEnumRedemptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RedemptionStatus[] | ListEnumRedemptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRedemptionStatusFilter<$PrismaModel> | $Enums.RedemptionStatus
  }

  export type NestedEnumRedemptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RedemptionStatus | EnumRedemptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RedemptionStatus[] | ListEnumRedemptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RedemptionStatus[] | ListEnumRedemptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRedemptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.RedemptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRedemptionStatusFilter<$PrismaModel>
    _max?: NestedEnumRedemptionStatusFilter<$PrismaModel>
  }

  export type AnnouncementCreateWithoutAdminInput = {
    title: string
    content: string
    is_active?: boolean
    created_at?: Date | string
    expires_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type AnnouncementUncheckedCreateWithoutAdminInput = {
    announcement_id?: number
    title: string
    content: string
    is_active?: boolean
    created_at?: Date | string
    expires_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type AnnouncementCreateOrConnectWithoutAdminInput = {
    where: AnnouncementWhereUniqueInput
    create: XOR<AnnouncementCreateWithoutAdminInput, AnnouncementUncheckedCreateWithoutAdminInput>
  }

  export type AnnouncementCreateManyAdminInputEnvelope = {
    data: AnnouncementCreateManyAdminInput | AnnouncementCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type ChatbotConversationCreateWithoutUserInput = {
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    messages?: ChatbotMessageCreateNestedManyWithoutConversationInput
  }

  export type ChatbotConversationUncheckedCreateWithoutUserInput = {
    conversation_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    messages?: ChatbotMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ChatbotConversationCreateOrConnectWithoutUserInput = {
    where: ChatbotConversationWhereUniqueInput
    create: XOR<ChatbotConversationCreateWithoutUserInput, ChatbotConversationUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateWithoutUserInput = {
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    post: PostCreateNestedOneWithoutCommentsInput
    reports?: ReportCreateNestedManyWithoutReported_commentInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    comment_id?: number
    post_id: number
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    reports?: ReportUncheckedCreateNestedManyWithoutReported_commentInput
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CraftIdeaCreateWithoutGenerated_by_userInput = {
    idea_json: JsonNullValueInput | InputJsonValue
    recycled_materials?: NullableJsonNullValueInput | InputJsonValue
    generated_image_url?: string | null
    is_saved?: boolean
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type CraftIdeaUncheckedCreateWithoutGenerated_by_userInput = {
    idea_id?: number
    idea_json: JsonNullValueInput | InputJsonValue
    recycled_materials?: NullableJsonNullValueInput | InputJsonValue
    generated_image_url?: string | null
    is_saved?: boolean
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type CraftIdeaCreateOrConnectWithoutGenerated_by_userInput = {
    where: CraftIdeaWhereUniqueInput
    create: XOR<CraftIdeaCreateWithoutGenerated_by_userInput, CraftIdeaUncheckedCreateWithoutGenerated_by_userInput>
  }

  export type CraftIdeaCreateManyGenerated_by_userInputEnvelope = {
    data: CraftIdeaCreateManyGenerated_by_userInput | CraftIdeaCreateManyGenerated_by_userInput[]
    skipDuplicates?: boolean
  }

  export type EcoChallengeCreateWithoutCreated_by_adminInput = {
    title: string
    description: string
    points_reward: number
    waste_kg?: number
    is_active?: boolean
    source?: $Enums.ChallengeSource
    material_type: $Enums.MaterialType
    category: $Enums.ChallengeCategory
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    start_at?: Date | string
    expires_at?: Date | string | null
    participants?: UserChallengeCreateNestedManyWithoutChallengeInput
  }

  export type EcoChallengeUncheckedCreateWithoutCreated_by_adminInput = {
    challenge_id?: number
    title: string
    description: string
    points_reward: number
    waste_kg?: number
    is_active?: boolean
    source?: $Enums.ChallengeSource
    material_type: $Enums.MaterialType
    category: $Enums.ChallengeCategory
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    start_at?: Date | string
    expires_at?: Date | string | null
    participants?: UserChallengeUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type EcoChallengeCreateOrConnectWithoutCreated_by_adminInput = {
    where: EcoChallengeWhereUniqueInput
    create: XOR<EcoChallengeCreateWithoutCreated_by_adminInput, EcoChallengeUncheckedCreateWithoutCreated_by_adminInput>
  }

  export type EcoChallengeCreateManyCreated_by_adminInputEnvelope = {
    data: EcoChallengeCreateManyCreated_by_adminInput | EcoChallengeCreateManyCreated_by_adminInput[]
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutUserInput = {
    created_at?: Date | string
    deleted_at?: Date | string | null
    post: PostCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutUserInput = {
    like_id?: number
    post_id: number
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type LikeCreateOrConnectWithoutUserInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput>
  }

  export type LikeCreateManyUserInputEnvelope = {
    data: LikeCreateManyUserInput | LikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ModerationLogCreateWithoutAdminInput = {
    action: $Enums.ModerationAction
    target_id: string
    reason?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    target_user?: UserCreateNestedOneWithoutModerationTargetsInput
  }

  export type ModerationLogUncheckedCreateWithoutAdminInput = {
    log_id?: number
    action: $Enums.ModerationAction
    target_id: string
    target_user_id?: number | null
    reason?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ModerationLogCreateOrConnectWithoutAdminInput = {
    where: ModerationLogWhereUniqueInput
    create: XOR<ModerationLogCreateWithoutAdminInput, ModerationLogUncheckedCreateWithoutAdminInput>
  }

  export type ModerationLogCreateManyAdminInputEnvelope = {
    data: ModerationLogCreateManyAdminInput | ModerationLogCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type ModerationLogCreateWithoutTarget_userInput = {
    action: $Enums.ModerationAction
    target_id: string
    reason?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    admin?: UserCreateNestedOneWithoutModerationLogsInput
  }

  export type ModerationLogUncheckedCreateWithoutTarget_userInput = {
    log_id?: number
    admin_id?: number | null
    action: $Enums.ModerationAction
    target_id: string
    reason?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ModerationLogCreateOrConnectWithoutTarget_userInput = {
    where: ModerationLogWhereUniqueInput
    create: XOR<ModerationLogCreateWithoutTarget_userInput, ModerationLogUncheckedCreateWithoutTarget_userInput>
  }

  export type ModerationLogCreateManyTarget_userInputEnvelope = {
    data: ModerationLogCreateManyTarget_userInput | ModerationLogCreateManyTarget_userInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutUserInput = {
    title: string
    content: string
    image_url?: string | null
    tags?: PostCreatetagsInput | string[]
    category: $Enums.Category
    featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    comments?: CommentCreateNestedManyWithoutPostInput
    likes?: LikeCreateNestedManyWithoutPostInput
    reports?: ReportCreateNestedManyWithoutReported_postInput
  }

  export type PostUncheckedCreateWithoutUserInput = {
    post_id?: number
    title: string
    content: string
    image_url?: string | null
    tags?: PostCreatetagsInput | string[]
    category: $Enums.Category
    featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    reports?: ReportUncheckedCreateNestedManyWithoutReported_postInput
  }

  export type PostCreateOrConnectWithoutUserInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostCreateManyUserInputEnvelope = {
    data: PostCreateManyUserInput | PostCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutReporterInput = {
    reason: string
    status?: $Enums.ReportStatus
    moderator_notes?: string | null
    created_at?: Date | string
    resolved_at?: Date | string | null
    deleted_at?: Date | string | null
    reported_comment?: CommentCreateNestedOneWithoutReportsInput
    reported_post?: PostCreateNestedOneWithoutReportsInput
    resolver?: UserCreateNestedOneWithoutReportsResolvedInput
  }

  export type ReportUncheckedCreateWithoutReporterInput = {
    report_id?: number
    reported_post_id?: number | null
    reported_comment_id?: number | null
    reason: string
    status?: $Enums.ReportStatus
    moderator_notes?: string | null
    resolved_by_admin_id?: number | null
    created_at?: Date | string
    resolved_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type ReportCreateOrConnectWithoutReporterInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput>
  }

  export type ReportCreateManyReporterInputEnvelope = {
    data: ReportCreateManyReporterInput | ReportCreateManyReporterInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutResolverInput = {
    reason: string
    status?: $Enums.ReportStatus
    moderator_notes?: string | null
    created_at?: Date | string
    resolved_at?: Date | string | null
    deleted_at?: Date | string | null
    reported_comment?: CommentCreateNestedOneWithoutReportsInput
    reported_post?: PostCreateNestedOneWithoutReportsInput
    reporter: UserCreateNestedOneWithoutReportsFiledInput
  }

  export type ReportUncheckedCreateWithoutResolverInput = {
    report_id?: number
    reporter_id: number
    reported_post_id?: number | null
    reported_comment_id?: number | null
    reason: string
    status?: $Enums.ReportStatus
    moderator_notes?: string | null
    created_at?: Date | string
    resolved_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type ReportCreateOrConnectWithoutResolverInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutResolverInput, ReportUncheckedCreateWithoutResolverInput>
  }

  export type ReportCreateManyResolverInputEnvelope = {
    data: ReportCreateManyResolverInput | ReportCreateManyResolverInput[]
    skipDuplicates?: boolean
  }

  export type UserChallengeCreateWithoutUserInput = {
    status?: $Enums.ChallengeStatus
    proof_url?: string | null
    completed_at?: Date | string | null
    verified_at?: Date | string | null
    verification_type?: $Enums.VerificationType | null
    ai_confidence_score?: number | null
    points_awarded?: number
    waste_kg_saved?: number
    admin_notes?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    skipped_at?: Date | string | null
    challenge: EcoChallengeCreateNestedOneWithoutParticipantsInput
    verified_by?: UserCreateNestedOneWithoutVerifiedChallengesInput
  }

  export type UserChallengeUncheckedCreateWithoutUserInput = {
    user_challenge_id?: number
    challenge_id: number
    status?: $Enums.ChallengeStatus
    proof_url?: string | null
    completed_at?: Date | string | null
    verified_at?: Date | string | null
    verified_by_admin_id?: number | null
    verification_type?: $Enums.VerificationType | null
    ai_confidence_score?: number | null
    points_awarded?: number
    waste_kg_saved?: number
    admin_notes?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    skipped_at?: Date | string | null
  }

  export type UserChallengeCreateOrConnectWithoutUserInput = {
    where: UserChallengeWhereUniqueInput
    create: XOR<UserChallengeCreateWithoutUserInput, UserChallengeUncheckedCreateWithoutUserInput>
  }

  export type UserChallengeCreateManyUserInputEnvelope = {
    data: UserChallengeCreateManyUserInput | UserChallengeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserChallengeCreateWithoutVerified_byInput = {
    status?: $Enums.ChallengeStatus
    proof_url?: string | null
    completed_at?: Date | string | null
    verified_at?: Date | string | null
    verification_type?: $Enums.VerificationType | null
    ai_confidence_score?: number | null
    points_awarded?: number
    waste_kg_saved?: number
    admin_notes?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    skipped_at?: Date | string | null
    challenge: EcoChallengeCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutUserChallengesInput
  }

  export type UserChallengeUncheckedCreateWithoutVerified_byInput = {
    user_challenge_id?: number
    user_id: number
    challenge_id: number
    status?: $Enums.ChallengeStatus
    proof_url?: string | null
    completed_at?: Date | string | null
    verified_at?: Date | string | null
    verification_type?: $Enums.VerificationType | null
    ai_confidence_score?: number | null
    points_awarded?: number
    waste_kg_saved?: number
    admin_notes?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    skipped_at?: Date | string | null
  }

  export type UserChallengeCreateOrConnectWithoutVerified_byInput = {
    where: UserChallengeWhereUniqueInput
    create: XOR<UserChallengeCreateWithoutVerified_byInput, UserChallengeUncheckedCreateWithoutVerified_byInput>
  }

  export type UserChallengeCreateManyVerified_byInputEnvelope = {
    data: UserChallengeCreateManyVerified_byInput | UserChallengeCreateManyVerified_byInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileCreateWithoutUserInput = {
    full_name?: string | null
    bio?: string | null
    profile_picture_url?: string | null
    points?: number
    total_waste_kg?: number
    skipped_challenges?: UserProfileCreateskipped_challengesInput | number[]
    home_dashboard_layout?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
  }

  export type UserProfileUncheckedCreateWithoutUserInput = {
    full_name?: string | null
    bio?: string | null
    profile_picture_url?: string | null
    points?: number
    total_waste_kg?: number
    skipped_challenges?: UserProfileCreateskipped_challengesInput | number[]
    home_dashboard_layout?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
  }

  export type UserProfileCreateOrConnectWithoutUserInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateWithoutUserInput = {
    token_hash: string
    expires_at: Date | string
    created_at?: Date | string
    last_used?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    token_id?: number
    token_hash: string
    expires_at: Date | string
    created_at?: Date | string
    last_used?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SponsorCreateWithoutCreated_by_adminInput = {
    name: string
    logo_url?: string | null
    description?: string | null
    contact_email?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    rewards?: SponsorRewardCreateNestedManyWithoutSponsorInput
  }

  export type SponsorUncheckedCreateWithoutCreated_by_adminInput = {
    sponsor_id?: number
    name: string
    logo_url?: string | null
    description?: string | null
    contact_email?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    rewards?: SponsorRewardUncheckedCreateNestedManyWithoutSponsorInput
  }

  export type SponsorCreateOrConnectWithoutCreated_by_adminInput = {
    where: SponsorWhereUniqueInput
    create: XOR<SponsorCreateWithoutCreated_by_adminInput, SponsorUncheckedCreateWithoutCreated_by_adminInput>
  }

  export type SponsorCreateManyCreated_by_adminInputEnvelope = {
    data: SponsorCreateManyCreated_by_adminInput | SponsorCreateManyCreated_by_adminInput[]
    skipDuplicates?: boolean
  }

  export type UserRedemptionCreateWithoutUserInput = {
    status?: $Enums.RedemptionStatus
    claimed_at?: Date | string
    fulfilled_at?: Date | string | null
    deleted_at?: Date | string | null
    reward: SponsorRewardCreateNestedOneWithoutClaimsInput
  }

  export type UserRedemptionUncheckedCreateWithoutUserInput = {
    redemption_id?: number
    reward_id: number
    status?: $Enums.RedemptionStatus
    claimed_at?: Date | string
    fulfilled_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type UserRedemptionCreateOrConnectWithoutUserInput = {
    where: UserRedemptionWhereUniqueInput
    create: XOR<UserRedemptionCreateWithoutUserInput, UserRedemptionUncheckedCreateWithoutUserInput>
  }

  export type UserRedemptionCreateManyUserInputEnvelope = {
    data: UserRedemptionCreateManyUserInput | UserRedemptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AnnouncementUpsertWithWhereUniqueWithoutAdminInput = {
    where: AnnouncementWhereUniqueInput
    update: XOR<AnnouncementUpdateWithoutAdminInput, AnnouncementUncheckedUpdateWithoutAdminInput>
    create: XOR<AnnouncementCreateWithoutAdminInput, AnnouncementUncheckedCreateWithoutAdminInput>
  }

  export type AnnouncementUpdateWithWhereUniqueWithoutAdminInput = {
    where: AnnouncementWhereUniqueInput
    data: XOR<AnnouncementUpdateWithoutAdminInput, AnnouncementUncheckedUpdateWithoutAdminInput>
  }

  export type AnnouncementUpdateManyWithWhereWithoutAdminInput = {
    where: AnnouncementScalarWhereInput
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyWithoutAdminInput>
  }

  export type AnnouncementScalarWhereInput = {
    AND?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    OR?: AnnouncementScalarWhereInput[]
    NOT?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    announcement_id?: IntFilter<"Announcement"> | number
    admin_id?: IntNullableFilter<"Announcement"> | number | null
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    is_active?: BoolFilter<"Announcement"> | boolean
    created_at?: DateTimeFilter<"Announcement"> | Date | string
    expires_at?: DateTimeNullableFilter<"Announcement"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"Announcement"> | Date | string | null
  }

  export type ChatbotConversationUpsertWithoutUserInput = {
    update: XOR<ChatbotConversationUpdateWithoutUserInput, ChatbotConversationUncheckedUpdateWithoutUserInput>
    create: XOR<ChatbotConversationCreateWithoutUserInput, ChatbotConversationUncheckedCreateWithoutUserInput>
    where?: ChatbotConversationWhereInput
  }

  export type ChatbotConversationUpdateToOneWithWhereWithoutUserInput = {
    where?: ChatbotConversationWhereInput
    data: XOR<ChatbotConversationUpdateWithoutUserInput, ChatbotConversationUncheckedUpdateWithoutUserInput>
  }

  export type ChatbotConversationUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: ChatbotMessageUpdateManyWithoutConversationNestedInput
  }

  export type ChatbotConversationUncheckedUpdateWithoutUserInput = {
    conversation_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: ChatbotMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    comment_id?: IntFilter<"Comment"> | number
    post_id?: IntFilter<"Comment"> | number
    user_id?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    created_at?: DateTimeFilter<"Comment"> | Date | string
    updated_at?: DateTimeFilter<"Comment"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Comment"> | Date | string | null
  }

  export type CraftIdeaUpsertWithWhereUniqueWithoutGenerated_by_userInput = {
    where: CraftIdeaWhereUniqueInput
    update: XOR<CraftIdeaUpdateWithoutGenerated_by_userInput, CraftIdeaUncheckedUpdateWithoutGenerated_by_userInput>
    create: XOR<CraftIdeaCreateWithoutGenerated_by_userInput, CraftIdeaUncheckedCreateWithoutGenerated_by_userInput>
  }

  export type CraftIdeaUpdateWithWhereUniqueWithoutGenerated_by_userInput = {
    where: CraftIdeaWhereUniqueInput
    data: XOR<CraftIdeaUpdateWithoutGenerated_by_userInput, CraftIdeaUncheckedUpdateWithoutGenerated_by_userInput>
  }

  export type CraftIdeaUpdateManyWithWhereWithoutGenerated_by_userInput = {
    where: CraftIdeaScalarWhereInput
    data: XOR<CraftIdeaUpdateManyMutationInput, CraftIdeaUncheckedUpdateManyWithoutGenerated_by_userInput>
  }

  export type CraftIdeaScalarWhereInput = {
    AND?: CraftIdeaScalarWhereInput | CraftIdeaScalarWhereInput[]
    OR?: CraftIdeaScalarWhereInput[]
    NOT?: CraftIdeaScalarWhereInput | CraftIdeaScalarWhereInput[]
    idea_id?: IntFilter<"CraftIdea"> | number
    generated_by_user_id?: IntNullableFilter<"CraftIdea"> | number | null
    idea_json?: JsonFilter<"CraftIdea">
    recycled_materials?: JsonNullableFilter<"CraftIdea">
    generated_image_url?: StringNullableFilter<"CraftIdea"> | string | null
    is_saved?: BoolFilter<"CraftIdea"> | boolean
    created_at?: DateTimeFilter<"CraftIdea"> | Date | string
    deleted_at?: DateTimeNullableFilter<"CraftIdea"> | Date | string | null
  }

  export type EcoChallengeUpsertWithWhereUniqueWithoutCreated_by_adminInput = {
    where: EcoChallengeWhereUniqueInput
    update: XOR<EcoChallengeUpdateWithoutCreated_by_adminInput, EcoChallengeUncheckedUpdateWithoutCreated_by_adminInput>
    create: XOR<EcoChallengeCreateWithoutCreated_by_adminInput, EcoChallengeUncheckedCreateWithoutCreated_by_adminInput>
  }

  export type EcoChallengeUpdateWithWhereUniqueWithoutCreated_by_adminInput = {
    where: EcoChallengeWhereUniqueInput
    data: XOR<EcoChallengeUpdateWithoutCreated_by_adminInput, EcoChallengeUncheckedUpdateWithoutCreated_by_adminInput>
  }

  export type EcoChallengeUpdateManyWithWhereWithoutCreated_by_adminInput = {
    where: EcoChallengeScalarWhereInput
    data: XOR<EcoChallengeUpdateManyMutationInput, EcoChallengeUncheckedUpdateManyWithoutCreated_by_adminInput>
  }

  export type EcoChallengeScalarWhereInput = {
    AND?: EcoChallengeScalarWhereInput | EcoChallengeScalarWhereInput[]
    OR?: EcoChallengeScalarWhereInput[]
    NOT?: EcoChallengeScalarWhereInput | EcoChallengeScalarWhereInput[]
    challenge_id?: IntFilter<"EcoChallenge"> | number
    title?: StringFilter<"EcoChallenge"> | string
    description?: StringFilter<"EcoChallenge"> | string
    points_reward?: IntFilter<"EcoChallenge"> | number
    waste_kg?: FloatFilter<"EcoChallenge"> | number
    is_active?: BoolFilter<"EcoChallenge"> | boolean
    source?: EnumChallengeSourceFilter<"EcoChallenge"> | $Enums.ChallengeSource
    material_type?: EnumMaterialTypeFilter<"EcoChallenge"> | $Enums.MaterialType
    category?: EnumChallengeCategoryFilter<"EcoChallenge"> | $Enums.ChallengeCategory
    created_by_admin_id?: IntNullableFilter<"EcoChallenge"> | number | null
    created_at?: DateTimeFilter<"EcoChallenge"> | Date | string
    updated_at?: DateTimeFilter<"EcoChallenge"> | Date | string
    deleted_at?: DateTimeNullableFilter<"EcoChallenge"> | Date | string | null
    start_at?: DateTimeFilter<"EcoChallenge"> | Date | string
    expires_at?: DateTimeNullableFilter<"EcoChallenge"> | Date | string | null
  }

  export type LikeUpsertWithWhereUniqueWithoutUserInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutUserInput, LikeUncheckedUpdateWithoutUserInput>
    create: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutUserInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutUserInput, LikeUncheckedUpdateWithoutUserInput>
  }

  export type LikeUpdateManyWithWhereWithoutUserInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutUserInput>
  }

  export type LikeScalarWhereInput = {
    AND?: LikeScalarWhereInput | LikeScalarWhereInput[]
    OR?: LikeScalarWhereInput[]
    NOT?: LikeScalarWhereInput | LikeScalarWhereInput[]
    like_id?: IntFilter<"Like"> | number
    post_id?: IntFilter<"Like"> | number
    user_id?: IntFilter<"Like"> | number
    created_at?: DateTimeFilter<"Like"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Like"> | Date | string | null
  }

  export type ModerationLogUpsertWithWhereUniqueWithoutAdminInput = {
    where: ModerationLogWhereUniqueInput
    update: XOR<ModerationLogUpdateWithoutAdminInput, ModerationLogUncheckedUpdateWithoutAdminInput>
    create: XOR<ModerationLogCreateWithoutAdminInput, ModerationLogUncheckedCreateWithoutAdminInput>
  }

  export type ModerationLogUpdateWithWhereUniqueWithoutAdminInput = {
    where: ModerationLogWhereUniqueInput
    data: XOR<ModerationLogUpdateWithoutAdminInput, ModerationLogUncheckedUpdateWithoutAdminInput>
  }

  export type ModerationLogUpdateManyWithWhereWithoutAdminInput = {
    where: ModerationLogScalarWhereInput
    data: XOR<ModerationLogUpdateManyMutationInput, ModerationLogUncheckedUpdateManyWithoutAdminInput>
  }

  export type ModerationLogScalarWhereInput = {
    AND?: ModerationLogScalarWhereInput | ModerationLogScalarWhereInput[]
    OR?: ModerationLogScalarWhereInput[]
    NOT?: ModerationLogScalarWhereInput | ModerationLogScalarWhereInput[]
    log_id?: IntFilter<"ModerationLog"> | number
    admin_id?: IntNullableFilter<"ModerationLog"> | number | null
    action?: EnumModerationActionFilter<"ModerationLog"> | $Enums.ModerationAction
    target_id?: StringFilter<"ModerationLog"> | string
    target_user_id?: IntNullableFilter<"ModerationLog"> | number | null
    reason?: StringNullableFilter<"ModerationLog"> | string | null
    created_at?: DateTimeFilter<"ModerationLog"> | Date | string
    deleted_at?: DateTimeNullableFilter<"ModerationLog"> | Date | string | null
  }

  export type ModerationLogUpsertWithWhereUniqueWithoutTarget_userInput = {
    where: ModerationLogWhereUniqueInput
    update: XOR<ModerationLogUpdateWithoutTarget_userInput, ModerationLogUncheckedUpdateWithoutTarget_userInput>
    create: XOR<ModerationLogCreateWithoutTarget_userInput, ModerationLogUncheckedCreateWithoutTarget_userInput>
  }

  export type ModerationLogUpdateWithWhereUniqueWithoutTarget_userInput = {
    where: ModerationLogWhereUniqueInput
    data: XOR<ModerationLogUpdateWithoutTarget_userInput, ModerationLogUncheckedUpdateWithoutTarget_userInput>
  }

  export type ModerationLogUpdateManyWithWhereWithoutTarget_userInput = {
    where: ModerationLogScalarWhereInput
    data: XOR<ModerationLogUpdateManyMutationInput, ModerationLogUncheckedUpdateManyWithoutTarget_userInput>
  }

  export type PostUpsertWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostUpdateWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
  }

  export type PostUpdateManyWithWhereWithoutUserInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutUserInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    post_id?: IntFilter<"Post"> | number
    user_id?: IntFilter<"Post"> | number
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    image_url?: StringNullableFilter<"Post"> | string | null
    tags?: StringNullableListFilter<"Post">
    category?: EnumCategoryFilter<"Post"> | $Enums.Category
    featured?: BoolFilter<"Post"> | boolean
    created_at?: DateTimeFilter<"Post"> | Date | string
    updated_at?: DateTimeFilter<"Post"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Post"> | Date | string | null
  }

  export type ReportUpsertWithWhereUniqueWithoutReporterInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReporterInput, ReportUncheckedUpdateWithoutReporterInput>
    create: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReporterInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReporterInput, ReportUncheckedUpdateWithoutReporterInput>
  }

  export type ReportUpdateManyWithWhereWithoutReporterInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReporterInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    report_id?: IntFilter<"Report"> | number
    reporter_id?: IntFilter<"Report"> | number
    reported_post_id?: IntNullableFilter<"Report"> | number | null
    reported_comment_id?: IntNullableFilter<"Report"> | number | null
    reason?: StringFilter<"Report"> | string
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    moderator_notes?: StringNullableFilter<"Report"> | string | null
    resolved_by_admin_id?: IntNullableFilter<"Report"> | number | null
    created_at?: DateTimeFilter<"Report"> | Date | string
    resolved_at?: DateTimeNullableFilter<"Report"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"Report"> | Date | string | null
  }

  export type ReportUpsertWithWhereUniqueWithoutResolverInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutResolverInput, ReportUncheckedUpdateWithoutResolverInput>
    create: XOR<ReportCreateWithoutResolverInput, ReportUncheckedCreateWithoutResolverInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutResolverInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutResolverInput, ReportUncheckedUpdateWithoutResolverInput>
  }

  export type ReportUpdateManyWithWhereWithoutResolverInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutResolverInput>
  }

  export type UserChallengeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserChallengeWhereUniqueInput
    update: XOR<UserChallengeUpdateWithoutUserInput, UserChallengeUncheckedUpdateWithoutUserInput>
    create: XOR<UserChallengeCreateWithoutUserInput, UserChallengeUncheckedCreateWithoutUserInput>
  }

  export type UserChallengeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserChallengeWhereUniqueInput
    data: XOR<UserChallengeUpdateWithoutUserInput, UserChallengeUncheckedUpdateWithoutUserInput>
  }

  export type UserChallengeUpdateManyWithWhereWithoutUserInput = {
    where: UserChallengeScalarWhereInput
    data: XOR<UserChallengeUpdateManyMutationInput, UserChallengeUncheckedUpdateManyWithoutUserInput>
  }

  export type UserChallengeScalarWhereInput = {
    AND?: UserChallengeScalarWhereInput | UserChallengeScalarWhereInput[]
    OR?: UserChallengeScalarWhereInput[]
    NOT?: UserChallengeScalarWhereInput | UserChallengeScalarWhereInput[]
    user_challenge_id?: IntFilter<"UserChallenge"> | number
    user_id?: IntFilter<"UserChallenge"> | number
    challenge_id?: IntFilter<"UserChallenge"> | number
    status?: EnumChallengeStatusFilter<"UserChallenge"> | $Enums.ChallengeStatus
    proof_url?: StringNullableFilter<"UserChallenge"> | string | null
    completed_at?: DateTimeNullableFilter<"UserChallenge"> | Date | string | null
    verified_at?: DateTimeNullableFilter<"UserChallenge"> | Date | string | null
    verified_by_admin_id?: IntNullableFilter<"UserChallenge"> | number | null
    verification_type?: EnumVerificationTypeNullableFilter<"UserChallenge"> | $Enums.VerificationType | null
    ai_confidence_score?: FloatNullableFilter<"UserChallenge"> | number | null
    points_awarded?: IntFilter<"UserChallenge"> | number
    waste_kg_saved?: FloatFilter<"UserChallenge"> | number
    admin_notes?: StringNullableFilter<"UserChallenge"> | string | null
    created_at?: DateTimeFilter<"UserChallenge"> | Date | string
    deleted_at?: DateTimeNullableFilter<"UserChallenge"> | Date | string | null
    skipped_at?: DateTimeNullableFilter<"UserChallenge"> | Date | string | null
  }

  export type UserChallengeUpsertWithWhereUniqueWithoutVerified_byInput = {
    where: UserChallengeWhereUniqueInput
    update: XOR<UserChallengeUpdateWithoutVerified_byInput, UserChallengeUncheckedUpdateWithoutVerified_byInput>
    create: XOR<UserChallengeCreateWithoutVerified_byInput, UserChallengeUncheckedCreateWithoutVerified_byInput>
  }

  export type UserChallengeUpdateWithWhereUniqueWithoutVerified_byInput = {
    where: UserChallengeWhereUniqueInput
    data: XOR<UserChallengeUpdateWithoutVerified_byInput, UserChallengeUncheckedUpdateWithoutVerified_byInput>
  }

  export type UserChallengeUpdateManyWithWhereWithoutVerified_byInput = {
    where: UserChallengeScalarWhereInput
    data: XOR<UserChallengeUpdateManyMutationInput, UserChallengeUncheckedUpdateManyWithoutVerified_byInput>
  }

  export type UserProfileUpsertWithoutUserInput = {
    update: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserProfileUpdateWithoutUserInput = {
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    total_waste_kg?: FloatFieldUpdateOperationsInput | number
    skipped_challenges?: UserProfileUpdateskipped_challengesInput | number[]
    home_dashboard_layout?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserProfileUncheckedUpdateWithoutUserInput = {
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    total_waste_kg?: FloatFieldUpdateOperationsInput | number
    skipped_challenges?: UserProfileUpdateskipped_challengesInput | number[]
    home_dashboard_layout?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    token_id?: IntFilter<"RefreshToken"> | number
    user_id?: IntFilter<"RefreshToken"> | number
    token_hash?: StringFilter<"RefreshToken"> | string
    expires_at?: DateTimeFilter<"RefreshToken"> | Date | string
    created_at?: DateTimeFilter<"RefreshToken"> | Date | string
    last_used?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
  }

  export type SponsorUpsertWithWhereUniqueWithoutCreated_by_adminInput = {
    where: SponsorWhereUniqueInput
    update: XOR<SponsorUpdateWithoutCreated_by_adminInput, SponsorUncheckedUpdateWithoutCreated_by_adminInput>
    create: XOR<SponsorCreateWithoutCreated_by_adminInput, SponsorUncheckedCreateWithoutCreated_by_adminInput>
  }

  export type SponsorUpdateWithWhereUniqueWithoutCreated_by_adminInput = {
    where: SponsorWhereUniqueInput
    data: XOR<SponsorUpdateWithoutCreated_by_adminInput, SponsorUncheckedUpdateWithoutCreated_by_adminInput>
  }

  export type SponsorUpdateManyWithWhereWithoutCreated_by_adminInput = {
    where: SponsorScalarWhereInput
    data: XOR<SponsorUpdateManyMutationInput, SponsorUncheckedUpdateManyWithoutCreated_by_adminInput>
  }

  export type SponsorScalarWhereInput = {
    AND?: SponsorScalarWhereInput | SponsorScalarWhereInput[]
    OR?: SponsorScalarWhereInput[]
    NOT?: SponsorScalarWhereInput | SponsorScalarWhereInput[]
    sponsor_id?: IntFilter<"Sponsor"> | number
    name?: StringFilter<"Sponsor"> | string
    logo_url?: StringNullableFilter<"Sponsor"> | string | null
    description?: StringNullableFilter<"Sponsor"> | string | null
    contact_email?: StringNullableFilter<"Sponsor"> | string | null
    is_active?: BoolFilter<"Sponsor"> | boolean
    created_by_admin_id?: IntNullableFilter<"Sponsor"> | number | null
    created_at?: DateTimeFilter<"Sponsor"> | Date | string
    updated_at?: DateTimeFilter<"Sponsor"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Sponsor"> | Date | string | null
  }

  export type UserRedemptionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRedemptionWhereUniqueInput
    update: XOR<UserRedemptionUpdateWithoutUserInput, UserRedemptionUncheckedUpdateWithoutUserInput>
    create: XOR<UserRedemptionCreateWithoutUserInput, UserRedemptionUncheckedCreateWithoutUserInput>
  }

  export type UserRedemptionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRedemptionWhereUniqueInput
    data: XOR<UserRedemptionUpdateWithoutUserInput, UserRedemptionUncheckedUpdateWithoutUserInput>
  }

  export type UserRedemptionUpdateManyWithWhereWithoutUserInput = {
    where: UserRedemptionScalarWhereInput
    data: XOR<UserRedemptionUpdateManyMutationInput, UserRedemptionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRedemptionScalarWhereInput = {
    AND?: UserRedemptionScalarWhereInput | UserRedemptionScalarWhereInput[]
    OR?: UserRedemptionScalarWhereInput[]
    NOT?: UserRedemptionScalarWhereInput | UserRedemptionScalarWhereInput[]
    redemption_id?: IntFilter<"UserRedemption"> | number
    user_id?: IntFilter<"UserRedemption"> | number
    reward_id?: IntFilter<"UserRedemption"> | number
    status?: EnumRedemptionStatusFilter<"UserRedemption"> | $Enums.RedemptionStatus
    claimed_at?: DateTimeFilter<"UserRedemption"> | Date | string
    fulfilled_at?: DateTimeNullableFilter<"UserRedemption"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"UserRedemption"> | Date | string | null
  }

  export type UserCreateWithoutProfileInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogCreateNestedManyWithoutTarget_userInput
    posts?: PostCreateNestedManyWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeCreateNestedManyWithoutVerified_byInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    user_id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaUncheckedCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeUncheckedCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogUncheckedCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogUncheckedCreateNestedManyWithoutTarget_userInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportUncheckedCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeUncheckedCreateNestedManyWithoutVerified_byInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorUncheckedCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUpdateManyWithoutTarget_userNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUpdateManyWithoutVerified_byNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUncheckedUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUncheckedUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUncheckedUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUncheckedUpdateManyWithoutTarget_userNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUncheckedUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUncheckedUpdateManyWithoutVerified_byNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRefreshTokensInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogCreateNestedManyWithoutTarget_userInput
    posts?: PostCreateNestedManyWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    createdSponsors?: SponsorCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    user_id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaUncheckedCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeUncheckedCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogUncheckedCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogUncheckedCreateNestedManyWithoutTarget_userInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportUncheckedCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeUncheckedCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    createdSponsors?: SponsorUncheckedCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUpdateManyWithoutTarget_userNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    createdSponsors?: SponsorUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUncheckedUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUncheckedUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUncheckedUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUncheckedUpdateManyWithoutTarget_userNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUncheckedUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUncheckedUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    createdSponsors?: SponsorUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCraftIdeasInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdChallenges?: EcoChallengeCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogCreateNestedManyWithoutTarget_userInput
    posts?: PostCreateNestedManyWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCraftIdeasInput = {
    user_id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdChallenges?: EcoChallengeUncheckedCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogUncheckedCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogUncheckedCreateNestedManyWithoutTarget_userInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportUncheckedCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeUncheckedCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorUncheckedCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCraftIdeasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCraftIdeasInput, UserUncheckedCreateWithoutCraftIdeasInput>
  }

  export type UserUpsertWithoutCraftIdeasInput = {
    update: XOR<UserUpdateWithoutCraftIdeasInput, UserUncheckedUpdateWithoutCraftIdeasInput>
    create: XOR<UserCreateWithoutCraftIdeasInput, UserUncheckedCreateWithoutCraftIdeasInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCraftIdeasInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCraftIdeasInput, UserUncheckedUpdateWithoutCraftIdeasInput>
  }

  export type UserUpdateWithoutCraftIdeasInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdChallenges?: EcoChallengeUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUpdateManyWithoutTarget_userNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCraftIdeasInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUncheckedUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdChallenges?: EcoChallengeUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUncheckedUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUncheckedUpdateManyWithoutTarget_userNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUncheckedUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUncheckedUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutChatbotConversationsInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementCreateNestedManyWithoutAdminInput
    comments?: CommentCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogCreateNestedManyWithoutTarget_userInput
    posts?: PostCreateNestedManyWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChatbotConversationsInput = {
    user_id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAdminInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaUncheckedCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeUncheckedCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogUncheckedCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogUncheckedCreateNestedManyWithoutTarget_userInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportUncheckedCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeUncheckedCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorUncheckedCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatbotConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatbotConversationsInput, UserUncheckedCreateWithoutChatbotConversationsInput>
  }

  export type ChatbotMessageCreateWithoutConversationInput = {
    sender: $Enums.MessageSender
    content: string
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ChatbotMessageUncheckedCreateWithoutConversationInput = {
    message_id?: number
    sender: $Enums.MessageSender
    content: string
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ChatbotMessageCreateOrConnectWithoutConversationInput = {
    where: ChatbotMessageWhereUniqueInput
    create: XOR<ChatbotMessageCreateWithoutConversationInput, ChatbotMessageUncheckedCreateWithoutConversationInput>
  }

  export type ChatbotMessageCreateManyConversationInputEnvelope = {
    data: ChatbotMessageCreateManyConversationInput | ChatbotMessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutChatbotConversationsInput = {
    update: XOR<UserUpdateWithoutChatbotConversationsInput, UserUncheckedUpdateWithoutChatbotConversationsInput>
    create: XOR<UserCreateWithoutChatbotConversationsInput, UserUncheckedCreateWithoutChatbotConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatbotConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatbotConversationsInput, UserUncheckedUpdateWithoutChatbotConversationsInput>
  }

  export type UserUpdateWithoutChatbotConversationsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUpdateManyWithoutAdminNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUpdateManyWithoutTarget_userNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChatbotConversationsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUncheckedUpdateManyWithoutAdminNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUncheckedUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUncheckedUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUncheckedUpdateManyWithoutTarget_userNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUncheckedUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUncheckedUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChatbotMessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: ChatbotMessageWhereUniqueInput
    update: XOR<ChatbotMessageUpdateWithoutConversationInput, ChatbotMessageUncheckedUpdateWithoutConversationInput>
    create: XOR<ChatbotMessageCreateWithoutConversationInput, ChatbotMessageUncheckedCreateWithoutConversationInput>
  }

  export type ChatbotMessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: ChatbotMessageWhereUniqueInput
    data: XOR<ChatbotMessageUpdateWithoutConversationInput, ChatbotMessageUncheckedUpdateWithoutConversationInput>
  }

  export type ChatbotMessageUpdateManyWithWhereWithoutConversationInput = {
    where: ChatbotMessageScalarWhereInput
    data: XOR<ChatbotMessageUpdateManyMutationInput, ChatbotMessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ChatbotMessageScalarWhereInput = {
    AND?: ChatbotMessageScalarWhereInput | ChatbotMessageScalarWhereInput[]
    OR?: ChatbotMessageScalarWhereInput[]
    NOT?: ChatbotMessageScalarWhereInput | ChatbotMessageScalarWhereInput[]
    message_id?: IntFilter<"ChatbotMessage"> | number
    conversation_id?: IntFilter<"ChatbotMessage"> | number
    sender?: EnumMessageSenderFilter<"ChatbotMessage"> | $Enums.MessageSender
    content?: StringFilter<"ChatbotMessage"> | string
    created_at?: DateTimeFilter<"ChatbotMessage"> | Date | string
    deleted_at?: DateTimeNullableFilter<"ChatbotMessage"> | Date | string | null
  }

  export type ChatbotConversationCreateWithoutMessagesInput = {
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user: UserCreateNestedOneWithoutChatbotConversationsInput
  }

  export type ChatbotConversationUncheckedCreateWithoutMessagesInput = {
    conversation_id?: number
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ChatbotConversationCreateOrConnectWithoutMessagesInput = {
    where: ChatbotConversationWhereUniqueInput
    create: XOR<ChatbotConversationCreateWithoutMessagesInput, ChatbotConversationUncheckedCreateWithoutMessagesInput>
  }

  export type ChatbotConversationUpsertWithoutMessagesInput = {
    update: XOR<ChatbotConversationUpdateWithoutMessagesInput, ChatbotConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatbotConversationCreateWithoutMessagesInput, ChatbotConversationUncheckedCreateWithoutMessagesInput>
    where?: ChatbotConversationWhereInput
  }

  export type ChatbotConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatbotConversationWhereInput
    data: XOR<ChatbotConversationUpdateWithoutMessagesInput, ChatbotConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatbotConversationUpdateWithoutMessagesInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutChatbotConversationsNestedInput
  }

  export type ChatbotConversationUncheckedUpdateWithoutMessagesInput = {
    conversation_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentCreateWithoutPostInput = {
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user: UserCreateNestedOneWithoutCommentsInput
    reports?: ReportCreateNestedManyWithoutReported_commentInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    comment_id?: number
    user_id: number
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    reports?: ReportUncheckedCreateNestedManyWithoutReported_commentInput
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutPostInput = {
    created_at?: Date | string
    deleted_at?: Date | string | null
    user: UserCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutPostInput = {
    like_id?: number
    user_id: number
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type LikeCreateOrConnectWithoutPostInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput>
  }

  export type LikeCreateManyPostInputEnvelope = {
    data: LikeCreateManyPostInput | LikeCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPostsInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogCreateNestedManyWithoutTarget_userInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    user_id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaUncheckedCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeUncheckedCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogUncheckedCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogUncheckedCreateNestedManyWithoutTarget_userInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportUncheckedCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeUncheckedCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorUncheckedCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type ReportCreateWithoutReported_postInput = {
    reason: string
    status?: $Enums.ReportStatus
    moderator_notes?: string | null
    created_at?: Date | string
    resolved_at?: Date | string | null
    deleted_at?: Date | string | null
    reported_comment?: CommentCreateNestedOneWithoutReportsInput
    reporter: UserCreateNestedOneWithoutReportsFiledInput
    resolver?: UserCreateNestedOneWithoutReportsResolvedInput
  }

  export type ReportUncheckedCreateWithoutReported_postInput = {
    report_id?: number
    reporter_id: number
    reported_comment_id?: number | null
    reason: string
    status?: $Enums.ReportStatus
    moderator_notes?: string | null
    resolved_by_admin_id?: number | null
    created_at?: Date | string
    resolved_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type ReportCreateOrConnectWithoutReported_postInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReported_postInput, ReportUncheckedCreateWithoutReported_postInput>
  }

  export type ReportCreateManyReported_postInputEnvelope = {
    data: ReportCreateManyReported_postInput | ReportCreateManyReported_postInput[]
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type LikeUpsertWithWhereUniqueWithoutPostInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutPostInput, LikeUncheckedUpdateWithoutPostInput>
    create: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutPostInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutPostInput, LikeUncheckedUpdateWithoutPostInput>
  }

  export type LikeUpdateManyWithWhereWithoutPostInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutPostInput>
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUpdateManyWithoutTarget_userNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUncheckedUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUncheckedUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUncheckedUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUncheckedUpdateManyWithoutTarget_userNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUncheckedUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUncheckedUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReportUpsertWithWhereUniqueWithoutReported_postInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReported_postInput, ReportUncheckedUpdateWithoutReported_postInput>
    create: XOR<ReportCreateWithoutReported_postInput, ReportUncheckedCreateWithoutReported_postInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReported_postInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReported_postInput, ReportUncheckedUpdateWithoutReported_postInput>
  }

  export type ReportUpdateManyWithWhereWithoutReported_postInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReported_postInput>
  }

  export type PostCreateWithoutCommentsInput = {
    title: string
    content: string
    image_url?: string | null
    tags?: PostCreatetagsInput | string[]
    category: $Enums.Category
    featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    likes?: LikeCreateNestedManyWithoutPostInput
    user: UserCreateNestedOneWithoutPostsInput
    reports?: ReportCreateNestedManyWithoutReported_postInput
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    post_id?: number
    user_id: number
    title: string
    content: string
    image_url?: string | null
    tags?: PostCreatetagsInput | string[]
    category: $Enums.Category
    featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    reports?: ReportUncheckedCreateNestedManyWithoutReported_postInput
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationCreateNestedOneWithoutUserInput
    craftIdeas?: CraftIdeaCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogCreateNestedManyWithoutTarget_userInput
    posts?: PostCreateNestedManyWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    user_id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationUncheckedCreateNestedOneWithoutUserInput
    craftIdeas?: CraftIdeaUncheckedCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeUncheckedCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogUncheckedCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogUncheckedCreateNestedManyWithoutTarget_userInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportUncheckedCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeUncheckedCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorUncheckedCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type ReportCreateWithoutReported_commentInput = {
    reason: string
    status?: $Enums.ReportStatus
    moderator_notes?: string | null
    created_at?: Date | string
    resolved_at?: Date | string | null
    deleted_at?: Date | string | null
    reported_post?: PostCreateNestedOneWithoutReportsInput
    reporter: UserCreateNestedOneWithoutReportsFiledInput
    resolver?: UserCreateNestedOneWithoutReportsResolvedInput
  }

  export type ReportUncheckedCreateWithoutReported_commentInput = {
    report_id?: number
    reporter_id: number
    reported_post_id?: number | null
    reason: string
    status?: $Enums.ReportStatus
    moderator_notes?: string | null
    resolved_by_admin_id?: number | null
    created_at?: Date | string
    resolved_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type ReportCreateOrConnectWithoutReported_commentInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReported_commentInput, ReportUncheckedCreateWithoutReported_commentInput>
  }

  export type ReportCreateManyReported_commentInputEnvelope = {
    data: ReportCreateManyReported_commentInput | ReportCreateManyReported_commentInput[]
    skipDuplicates?: boolean
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostUpdatetagsInput | string[]
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    likes?: LikeUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
    reports?: ReportUpdateManyWithoutReported_postNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostUpdatetagsInput | string[]
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReported_postNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUpdateOneWithoutUserNestedInput
    craftIdeas?: CraftIdeaUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUpdateManyWithoutTarget_userNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUncheckedUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUncheckedUpdateOneWithoutUserNestedInput
    craftIdeas?: CraftIdeaUncheckedUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUncheckedUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUncheckedUpdateManyWithoutTarget_userNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUncheckedUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUncheckedUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReportUpsertWithWhereUniqueWithoutReported_commentInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReported_commentInput, ReportUncheckedUpdateWithoutReported_commentInput>
    create: XOR<ReportCreateWithoutReported_commentInput, ReportUncheckedCreateWithoutReported_commentInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReported_commentInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReported_commentInput, ReportUncheckedUpdateWithoutReported_commentInput>
  }

  export type ReportUpdateManyWithWhereWithoutReported_commentInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReported_commentInput>
  }

  export type PostCreateWithoutLikesInput = {
    title: string
    content: string
    image_url?: string | null
    tags?: PostCreatetagsInput | string[]
    category: $Enums.Category
    featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    comments?: CommentCreateNestedManyWithoutPostInput
    user: UserCreateNestedOneWithoutPostsInput
    reports?: ReportCreateNestedManyWithoutReported_postInput
  }

  export type PostUncheckedCreateWithoutLikesInput = {
    post_id?: number
    user_id: number
    title: string
    content: string
    image_url?: string | null
    tags?: PostCreatetagsInput | string[]
    category: $Enums.Category
    featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reports?: ReportUncheckedCreateNestedManyWithoutReported_postInput
  }

  export type PostCreateOrConnectWithoutLikesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
  }

  export type UserCreateWithoutLikesInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeCreateNestedManyWithoutCreated_by_adminInput
    moderationLogs?: ModerationLogCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogCreateNestedManyWithoutTarget_userInput
    posts?: PostCreateNestedManyWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLikesInput = {
    user_id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaUncheckedCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeUncheckedCreateNestedManyWithoutCreated_by_adminInput
    moderationLogs?: ModerationLogUncheckedCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogUncheckedCreateNestedManyWithoutTarget_userInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportUncheckedCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeUncheckedCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorUncheckedCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
  }

  export type PostUpsertWithoutLikesInput = {
    update: XOR<PostUpdateWithoutLikesInput, PostUncheckedUpdateWithoutLikesInput>
    create: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutLikesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutLikesInput, PostUncheckedUpdateWithoutLikesInput>
  }

  export type PostUpdateWithoutLikesInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostUpdatetagsInput | string[]
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
    reports?: ReportUpdateManyWithoutReported_postNestedInput
  }

  export type PostUncheckedUpdateWithoutLikesInput = {
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostUpdatetagsInput | string[]
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReported_postNestedInput
  }

  export type UserUpsertWithoutLikesInput = {
    update: XOR<UserUpdateWithoutLikesInput, UserUncheckedUpdateWithoutLikesInput>
    create: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikesInput, UserUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateWithoutLikesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUpdateManyWithoutCreated_by_adminNestedInput
    moderationLogs?: ModerationLogUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUpdateManyWithoutTarget_userNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLikesInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUncheckedUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUncheckedUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    moderationLogs?: ModerationLogUncheckedUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUncheckedUpdateManyWithoutTarget_userNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUncheckedUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUncheckedUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCreatedChallengesInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaCreateNestedManyWithoutGenerated_by_userInput
    likes?: LikeCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogCreateNestedManyWithoutTarget_userInput
    posts?: PostCreateNestedManyWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedChallengesInput = {
    user_id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaUncheckedCreateNestedManyWithoutGenerated_by_userInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogUncheckedCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogUncheckedCreateNestedManyWithoutTarget_userInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportUncheckedCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeUncheckedCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorUncheckedCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedChallengesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedChallengesInput, UserUncheckedCreateWithoutCreatedChallengesInput>
  }

  export type UserChallengeCreateWithoutChallengeInput = {
    status?: $Enums.ChallengeStatus
    proof_url?: string | null
    completed_at?: Date | string | null
    verified_at?: Date | string | null
    verification_type?: $Enums.VerificationType | null
    ai_confidence_score?: number | null
    points_awarded?: number
    waste_kg_saved?: number
    admin_notes?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    skipped_at?: Date | string | null
    user: UserCreateNestedOneWithoutUserChallengesInput
    verified_by?: UserCreateNestedOneWithoutVerifiedChallengesInput
  }

  export type UserChallengeUncheckedCreateWithoutChallengeInput = {
    user_challenge_id?: number
    user_id: number
    status?: $Enums.ChallengeStatus
    proof_url?: string | null
    completed_at?: Date | string | null
    verified_at?: Date | string | null
    verified_by_admin_id?: number | null
    verification_type?: $Enums.VerificationType | null
    ai_confidence_score?: number | null
    points_awarded?: number
    waste_kg_saved?: number
    admin_notes?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    skipped_at?: Date | string | null
  }

  export type UserChallengeCreateOrConnectWithoutChallengeInput = {
    where: UserChallengeWhereUniqueInput
    create: XOR<UserChallengeCreateWithoutChallengeInput, UserChallengeUncheckedCreateWithoutChallengeInput>
  }

  export type UserChallengeCreateManyChallengeInputEnvelope = {
    data: UserChallengeCreateManyChallengeInput | UserChallengeCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedChallengesInput = {
    update: XOR<UserUpdateWithoutCreatedChallengesInput, UserUncheckedUpdateWithoutCreatedChallengesInput>
    create: XOR<UserCreateWithoutCreatedChallengesInput, UserUncheckedCreateWithoutCreatedChallengesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedChallengesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedChallengesInput, UserUncheckedUpdateWithoutCreatedChallengesInput>
  }

  export type UserUpdateWithoutCreatedChallengesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUpdateManyWithoutGenerated_by_userNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUpdateManyWithoutTarget_userNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedChallengesInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUncheckedUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUncheckedUpdateManyWithoutGenerated_by_userNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUncheckedUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUncheckedUpdateManyWithoutTarget_userNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUncheckedUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUncheckedUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserChallengeUpsertWithWhereUniqueWithoutChallengeInput = {
    where: UserChallengeWhereUniqueInput
    update: XOR<UserChallengeUpdateWithoutChallengeInput, UserChallengeUncheckedUpdateWithoutChallengeInput>
    create: XOR<UserChallengeCreateWithoutChallengeInput, UserChallengeUncheckedCreateWithoutChallengeInput>
  }

  export type UserChallengeUpdateWithWhereUniqueWithoutChallengeInput = {
    where: UserChallengeWhereUniqueInput
    data: XOR<UserChallengeUpdateWithoutChallengeInput, UserChallengeUncheckedUpdateWithoutChallengeInput>
  }

  export type UserChallengeUpdateManyWithWhereWithoutChallengeInput = {
    where: UserChallengeScalarWhereInput
    data: XOR<UserChallengeUpdateManyMutationInput, UserChallengeUncheckedUpdateManyWithoutChallengeInput>
  }

  export type EcoChallengeCreateWithoutParticipantsInput = {
    title: string
    description: string
    points_reward: number
    waste_kg?: number
    is_active?: boolean
    source?: $Enums.ChallengeSource
    material_type: $Enums.MaterialType
    category: $Enums.ChallengeCategory
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    start_at?: Date | string
    expires_at?: Date | string | null
    created_by_admin?: UserCreateNestedOneWithoutCreatedChallengesInput
  }

  export type EcoChallengeUncheckedCreateWithoutParticipantsInput = {
    challenge_id?: number
    title: string
    description: string
    points_reward: number
    waste_kg?: number
    is_active?: boolean
    source?: $Enums.ChallengeSource
    material_type: $Enums.MaterialType
    category: $Enums.ChallengeCategory
    created_by_admin_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    start_at?: Date | string
    expires_at?: Date | string | null
  }

  export type EcoChallengeCreateOrConnectWithoutParticipantsInput = {
    where: EcoChallengeWhereUniqueInput
    create: XOR<EcoChallengeCreateWithoutParticipantsInput, EcoChallengeUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutUserChallengesInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogCreateNestedManyWithoutTarget_userInput
    posts?: PostCreateNestedManyWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportCreateNestedManyWithoutResolverInput
    verifiedChallenges?: UserChallengeCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserChallengesInput = {
    user_id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaUncheckedCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeUncheckedCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogUncheckedCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogUncheckedCreateNestedManyWithoutTarget_userInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportUncheckedCreateNestedManyWithoutResolverInput
    verifiedChallenges?: UserChallengeUncheckedCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorUncheckedCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserChallengesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserChallengesInput, UserUncheckedCreateWithoutUserChallengesInput>
  }

  export type UserCreateWithoutVerifiedChallengesInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogCreateNestedManyWithoutTarget_userInput
    posts?: PostCreateNestedManyWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVerifiedChallengesInput = {
    user_id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaUncheckedCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeUncheckedCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogUncheckedCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogUncheckedCreateNestedManyWithoutTarget_userInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportUncheckedCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorUncheckedCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVerifiedChallengesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerifiedChallengesInput, UserUncheckedCreateWithoutVerifiedChallengesInput>
  }

  export type EcoChallengeUpsertWithoutParticipantsInput = {
    update: XOR<EcoChallengeUpdateWithoutParticipantsInput, EcoChallengeUncheckedUpdateWithoutParticipantsInput>
    create: XOR<EcoChallengeCreateWithoutParticipantsInput, EcoChallengeUncheckedCreateWithoutParticipantsInput>
    where?: EcoChallengeWhereInput
  }

  export type EcoChallengeUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: EcoChallengeWhereInput
    data: XOR<EcoChallengeUpdateWithoutParticipantsInput, EcoChallengeUncheckedUpdateWithoutParticipantsInput>
  }

  export type EcoChallengeUpdateWithoutParticipantsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points_reward?: IntFieldUpdateOperationsInput | number
    waste_kg?: FloatFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    source?: EnumChallengeSourceFieldUpdateOperationsInput | $Enums.ChallengeSource
    material_type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    category?: EnumChallengeCategoryFieldUpdateOperationsInput | $Enums.ChallengeCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by_admin?: UserUpdateOneWithoutCreatedChallengesNestedInput
  }

  export type EcoChallengeUncheckedUpdateWithoutParticipantsInput = {
    challenge_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points_reward?: IntFieldUpdateOperationsInput | number
    waste_kg?: FloatFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    source?: EnumChallengeSourceFieldUpdateOperationsInput | $Enums.ChallengeSource
    material_type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    category?: EnumChallengeCategoryFieldUpdateOperationsInput | $Enums.ChallengeCategory
    created_by_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpsertWithoutUserChallengesInput = {
    update: XOR<UserUpdateWithoutUserChallengesInput, UserUncheckedUpdateWithoutUserChallengesInput>
    create: XOR<UserCreateWithoutUserChallengesInput, UserUncheckedCreateWithoutUserChallengesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserChallengesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserChallengesInput, UserUncheckedUpdateWithoutUserChallengesInput>
  }

  export type UserUpdateWithoutUserChallengesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUpdateManyWithoutTarget_userNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUpdateManyWithoutResolverNestedInput
    verifiedChallenges?: UserChallengeUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserChallengesInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUncheckedUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUncheckedUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUncheckedUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUncheckedUpdateManyWithoutTarget_userNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUncheckedUpdateManyWithoutResolverNestedInput
    verifiedChallenges?: UserChallengeUncheckedUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutVerifiedChallengesInput = {
    update: XOR<UserUpdateWithoutVerifiedChallengesInput, UserUncheckedUpdateWithoutVerifiedChallengesInput>
    create: XOR<UserCreateWithoutVerifiedChallengesInput, UserUncheckedCreateWithoutVerifiedChallengesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerifiedChallengesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerifiedChallengesInput, UserUncheckedUpdateWithoutVerifiedChallengesInput>
  }

  export type UserUpdateWithoutVerifiedChallengesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUpdateManyWithoutTarget_userNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVerifiedChallengesInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUncheckedUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUncheckedUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUncheckedUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUncheckedUpdateManyWithoutTarget_userNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUncheckedUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentCreateWithoutReportsInput = {
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    post: PostCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutReportsInput = {
    comment_id?: number
    post_id: number
    user_id: number
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type CommentCreateOrConnectWithoutReportsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutReportsInput, CommentUncheckedCreateWithoutReportsInput>
  }

  export type PostCreateWithoutReportsInput = {
    title: string
    content: string
    image_url?: string | null
    tags?: PostCreatetagsInput | string[]
    category: $Enums.Category
    featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    comments?: CommentCreateNestedManyWithoutPostInput
    likes?: LikeCreateNestedManyWithoutPostInput
    user: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutReportsInput = {
    post_id?: number
    user_id: number
    title: string
    content: string
    image_url?: string | null
    tags?: PostCreatetagsInput | string[]
    category: $Enums.Category
    featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutReportsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutReportsInput, PostUncheckedCreateWithoutReportsInput>
  }

  export type UserCreateWithoutReportsFiledInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogCreateNestedManyWithoutTarget_userInput
    posts?: PostCreateNestedManyWithoutUserInput
    reportsResolved?: ReportCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportsFiledInput = {
    user_id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaUncheckedCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeUncheckedCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogUncheckedCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogUncheckedCreateNestedManyWithoutTarget_userInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reportsResolved?: ReportUncheckedCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeUncheckedCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorUncheckedCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportsFiledInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsFiledInput, UserUncheckedCreateWithoutReportsFiledInput>
  }

  export type UserCreateWithoutReportsResolvedInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogCreateNestedManyWithoutTarget_userInput
    posts?: PostCreateNestedManyWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportsResolvedInput = {
    user_id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaUncheckedCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeUncheckedCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogUncheckedCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogUncheckedCreateNestedManyWithoutTarget_userInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeUncheckedCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorUncheckedCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportsResolvedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsResolvedInput, UserUncheckedCreateWithoutReportsResolvedInput>
  }

  export type CommentUpsertWithoutReportsInput = {
    update: XOR<CommentUpdateWithoutReportsInput, CommentUncheckedUpdateWithoutReportsInput>
    create: XOR<CommentCreateWithoutReportsInput, CommentUncheckedCreateWithoutReportsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutReportsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutReportsInput, CommentUncheckedUpdateWithoutReportsInput>
  }

  export type CommentUpdateWithoutReportsInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutReportsInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostUpsertWithoutReportsInput = {
    update: XOR<PostUpdateWithoutReportsInput, PostUncheckedUpdateWithoutReportsInput>
    create: XOR<PostCreateWithoutReportsInput, PostUncheckedCreateWithoutReportsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutReportsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutReportsInput, PostUncheckedUpdateWithoutReportsInput>
  }

  export type PostUpdateWithoutReportsInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostUpdatetagsInput | string[]
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUpdateManyWithoutPostNestedInput
    likes?: LikeUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutReportsInput = {
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostUpdatetagsInput | string[]
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutReportsFiledInput = {
    update: XOR<UserUpdateWithoutReportsFiledInput, UserUncheckedUpdateWithoutReportsFiledInput>
    create: XOR<UserCreateWithoutReportsFiledInput, UserUncheckedCreateWithoutReportsFiledInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsFiledInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsFiledInput, UserUncheckedUpdateWithoutReportsFiledInput>
  }

  export type UserUpdateWithoutReportsFiledInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUpdateManyWithoutTarget_userNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reportsResolved?: ReportUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsFiledInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUncheckedUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUncheckedUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUncheckedUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUncheckedUpdateManyWithoutTarget_userNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reportsResolved?: ReportUncheckedUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUncheckedUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReportsResolvedInput = {
    update: XOR<UserUpdateWithoutReportsResolvedInput, UserUncheckedUpdateWithoutReportsResolvedInput>
    create: XOR<UserCreateWithoutReportsResolvedInput, UserUncheckedCreateWithoutReportsResolvedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsResolvedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsResolvedInput, UserUncheckedUpdateWithoutReportsResolvedInput>
  }

  export type UserUpdateWithoutReportsResolvedInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUpdateManyWithoutTarget_userNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsResolvedInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUncheckedUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUncheckedUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUncheckedUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUncheckedUpdateManyWithoutTarget_userNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUncheckedUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAnnouncementsInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    chatbotConversations?: ChatbotConversationCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogCreateNestedManyWithoutTarget_userInput
    posts?: PostCreateNestedManyWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnnouncementsInput = {
    user_id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    chatbotConversations?: ChatbotConversationUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaUncheckedCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeUncheckedCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogUncheckedCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogUncheckedCreateNestedManyWithoutTarget_userInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportUncheckedCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeUncheckedCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorUncheckedCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnnouncementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput>
  }

  export type UserUpsertWithoutAnnouncementsInput = {
    update: XOR<UserUpdateWithoutAnnouncementsInput, UserUncheckedUpdateWithoutAnnouncementsInput>
    create: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnnouncementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnnouncementsInput, UserUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type UserUpdateWithoutAnnouncementsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chatbotConversations?: ChatbotConversationUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUpdateManyWithoutTarget_userNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnnouncementsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chatbotConversations?: ChatbotConversationUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUncheckedUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUncheckedUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUncheckedUpdateManyWithoutTarget_userNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUncheckedUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUncheckedUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutModerationLogsInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeCreateNestedManyWithoutUserInput
    moderationTargets?: ModerationLogCreateNestedManyWithoutTarget_userInput
    posts?: PostCreateNestedManyWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutModerationLogsInput = {
    user_id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaUncheckedCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeUncheckedCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    moderationTargets?: ModerationLogUncheckedCreateNestedManyWithoutTarget_userInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportUncheckedCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeUncheckedCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorUncheckedCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutModerationLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutModerationLogsInput, UserUncheckedCreateWithoutModerationLogsInput>
  }

  export type UserCreateWithoutModerationTargetsInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogCreateNestedManyWithoutAdminInput
    posts?: PostCreateNestedManyWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutModerationTargetsInput = {
    user_id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaUncheckedCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeUncheckedCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogUncheckedCreateNestedManyWithoutAdminInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportUncheckedCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeUncheckedCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorUncheckedCreateNestedManyWithoutCreated_by_adminInput
    redemptions?: UserRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutModerationTargetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutModerationTargetsInput, UserUncheckedCreateWithoutModerationTargetsInput>
  }

  export type UserUpsertWithoutModerationLogsInput = {
    update: XOR<UserUpdateWithoutModerationLogsInput, UserUncheckedUpdateWithoutModerationLogsInput>
    create: XOR<UserCreateWithoutModerationLogsInput, UserUncheckedCreateWithoutModerationLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutModerationLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutModerationLogsInput, UserUncheckedUpdateWithoutModerationLogsInput>
  }

  export type UserUpdateWithoutModerationLogsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    moderationTargets?: ModerationLogUpdateManyWithoutTarget_userNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutModerationLogsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUncheckedUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUncheckedUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    moderationTargets?: ModerationLogUncheckedUpdateManyWithoutTarget_userNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUncheckedUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUncheckedUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutModerationTargetsInput = {
    update: XOR<UserUpdateWithoutModerationTargetsInput, UserUncheckedUpdateWithoutModerationTargetsInput>
    create: XOR<UserCreateWithoutModerationTargetsInput, UserUncheckedCreateWithoutModerationTargetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutModerationTargetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutModerationTargetsInput, UserUncheckedUpdateWithoutModerationTargetsInput>
  }

  export type UserUpdateWithoutModerationTargetsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUpdateManyWithoutAdminNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutModerationTargetsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUncheckedUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUncheckedUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUncheckedUpdateManyWithoutAdminNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUncheckedUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUncheckedUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    redemptions?: UserRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCreatedSponsorsInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogCreateNestedManyWithoutTarget_userInput
    posts?: PostCreateNestedManyWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    redemptions?: UserRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedSponsorsInput = {
    user_id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaUncheckedCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeUncheckedCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogUncheckedCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogUncheckedCreateNestedManyWithoutTarget_userInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportUncheckedCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeUncheckedCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    redemptions?: UserRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedSponsorsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedSponsorsInput, UserUncheckedCreateWithoutCreatedSponsorsInput>
  }

  export type SponsorRewardCreateWithoutSponsorInput = {
    title: string
    description?: string | null
    points_cost: number
    quantity?: number | null
    redeemed_count?: number
    is_active?: boolean
    display_on_leaderboard?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    expires_at?: Date | string | null
    deleted_at?: Date | string | null
    claims?: UserRedemptionCreateNestedManyWithoutRewardInput
  }

  export type SponsorRewardUncheckedCreateWithoutSponsorInput = {
    reward_id?: number
    title: string
    description?: string | null
    points_cost: number
    quantity?: number | null
    redeemed_count?: number
    is_active?: boolean
    display_on_leaderboard?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    expires_at?: Date | string | null
    deleted_at?: Date | string | null
    claims?: UserRedemptionUncheckedCreateNestedManyWithoutRewardInput
  }

  export type SponsorRewardCreateOrConnectWithoutSponsorInput = {
    where: SponsorRewardWhereUniqueInput
    create: XOR<SponsorRewardCreateWithoutSponsorInput, SponsorRewardUncheckedCreateWithoutSponsorInput>
  }

  export type SponsorRewardCreateManySponsorInputEnvelope = {
    data: SponsorRewardCreateManySponsorInput | SponsorRewardCreateManySponsorInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedSponsorsInput = {
    update: XOR<UserUpdateWithoutCreatedSponsorsInput, UserUncheckedUpdateWithoutCreatedSponsorsInput>
    create: XOR<UserCreateWithoutCreatedSponsorsInput, UserUncheckedCreateWithoutCreatedSponsorsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedSponsorsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedSponsorsInput, UserUncheckedUpdateWithoutCreatedSponsorsInput>
  }

  export type UserUpdateWithoutCreatedSponsorsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUpdateManyWithoutTarget_userNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    redemptions?: UserRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedSponsorsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUncheckedUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUncheckedUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUncheckedUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUncheckedUpdateManyWithoutTarget_userNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUncheckedUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUncheckedUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    redemptions?: UserRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SponsorRewardUpsertWithWhereUniqueWithoutSponsorInput = {
    where: SponsorRewardWhereUniqueInput
    update: XOR<SponsorRewardUpdateWithoutSponsorInput, SponsorRewardUncheckedUpdateWithoutSponsorInput>
    create: XOR<SponsorRewardCreateWithoutSponsorInput, SponsorRewardUncheckedCreateWithoutSponsorInput>
  }

  export type SponsorRewardUpdateWithWhereUniqueWithoutSponsorInput = {
    where: SponsorRewardWhereUniqueInput
    data: XOR<SponsorRewardUpdateWithoutSponsorInput, SponsorRewardUncheckedUpdateWithoutSponsorInput>
  }

  export type SponsorRewardUpdateManyWithWhereWithoutSponsorInput = {
    where: SponsorRewardScalarWhereInput
    data: XOR<SponsorRewardUpdateManyMutationInput, SponsorRewardUncheckedUpdateManyWithoutSponsorInput>
  }

  export type SponsorRewardScalarWhereInput = {
    AND?: SponsorRewardScalarWhereInput | SponsorRewardScalarWhereInput[]
    OR?: SponsorRewardScalarWhereInput[]
    NOT?: SponsorRewardScalarWhereInput | SponsorRewardScalarWhereInput[]
    reward_id?: IntFilter<"SponsorReward"> | number
    sponsor_id?: IntFilter<"SponsorReward"> | number
    title?: StringFilter<"SponsorReward"> | string
    description?: StringNullableFilter<"SponsorReward"> | string | null
    points_cost?: IntFilter<"SponsorReward"> | number
    quantity?: IntNullableFilter<"SponsorReward"> | number | null
    redeemed_count?: IntFilter<"SponsorReward"> | number
    is_active?: BoolFilter<"SponsorReward"> | boolean
    display_on_leaderboard?: BoolFilter<"SponsorReward"> | boolean
    created_at?: DateTimeFilter<"SponsorReward"> | Date | string
    updated_at?: DateTimeFilter<"SponsorReward"> | Date | string
    expires_at?: DateTimeNullableFilter<"SponsorReward"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"SponsorReward"> | Date | string | null
  }

  export type SponsorCreateWithoutRewardsInput = {
    name: string
    logo_url?: string | null
    description?: string | null
    contact_email?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    created_by_admin?: UserCreateNestedOneWithoutCreatedSponsorsInput
  }

  export type SponsorUncheckedCreateWithoutRewardsInput = {
    sponsor_id?: number
    name: string
    logo_url?: string | null
    description?: string | null
    contact_email?: string | null
    is_active?: boolean
    created_by_admin_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type SponsorCreateOrConnectWithoutRewardsInput = {
    where: SponsorWhereUniqueInput
    create: XOR<SponsorCreateWithoutRewardsInput, SponsorUncheckedCreateWithoutRewardsInput>
  }

  export type UserRedemptionCreateWithoutRewardInput = {
    status?: $Enums.RedemptionStatus
    claimed_at?: Date | string
    fulfilled_at?: Date | string | null
    deleted_at?: Date | string | null
    user: UserCreateNestedOneWithoutRedemptionsInput
  }

  export type UserRedemptionUncheckedCreateWithoutRewardInput = {
    redemption_id?: number
    user_id: number
    status?: $Enums.RedemptionStatus
    claimed_at?: Date | string
    fulfilled_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type UserRedemptionCreateOrConnectWithoutRewardInput = {
    where: UserRedemptionWhereUniqueInput
    create: XOR<UserRedemptionCreateWithoutRewardInput, UserRedemptionUncheckedCreateWithoutRewardInput>
  }

  export type UserRedemptionCreateManyRewardInputEnvelope = {
    data: UserRedemptionCreateManyRewardInput | UserRedemptionCreateManyRewardInput[]
    skipDuplicates?: boolean
  }

  export type SponsorUpsertWithoutRewardsInput = {
    update: XOR<SponsorUpdateWithoutRewardsInput, SponsorUncheckedUpdateWithoutRewardsInput>
    create: XOR<SponsorCreateWithoutRewardsInput, SponsorUncheckedCreateWithoutRewardsInput>
    where?: SponsorWhereInput
  }

  export type SponsorUpdateToOneWithWhereWithoutRewardsInput = {
    where?: SponsorWhereInput
    data: XOR<SponsorUpdateWithoutRewardsInput, SponsorUncheckedUpdateWithoutRewardsInput>
  }

  export type SponsorUpdateWithoutRewardsInput = {
    name?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by_admin?: UserUpdateOneWithoutCreatedSponsorsNestedInput
  }

  export type SponsorUncheckedUpdateWithoutRewardsInput = {
    sponsor_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_by_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserRedemptionUpsertWithWhereUniqueWithoutRewardInput = {
    where: UserRedemptionWhereUniqueInput
    update: XOR<UserRedemptionUpdateWithoutRewardInput, UserRedemptionUncheckedUpdateWithoutRewardInput>
    create: XOR<UserRedemptionCreateWithoutRewardInput, UserRedemptionUncheckedCreateWithoutRewardInput>
  }

  export type UserRedemptionUpdateWithWhereUniqueWithoutRewardInput = {
    where: UserRedemptionWhereUniqueInput
    data: XOR<UserRedemptionUpdateWithoutRewardInput, UserRedemptionUncheckedUpdateWithoutRewardInput>
  }

  export type UserRedemptionUpdateManyWithWhereWithoutRewardInput = {
    where: UserRedemptionScalarWhereInput
    data: XOR<UserRedemptionUpdateManyMutationInput, UserRedemptionUncheckedUpdateManyWithoutRewardInput>
  }

  export type UserCreateWithoutRedemptionsInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogCreateNestedManyWithoutTarget_userInput
    posts?: PostCreateNestedManyWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorCreateNestedManyWithoutCreated_by_adminInput
  }

  export type UserUncheckedCreateWithoutRedemptionsInput = {
    user_id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.UserRole
    is_email_verified?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAdminInput
    chatbotConversations?: ChatbotConversationUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    craftIdeas?: CraftIdeaUncheckedCreateNestedManyWithoutGenerated_by_userInput
    createdChallenges?: EcoChallengeUncheckedCreateNestedManyWithoutCreated_by_adminInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    moderationLogs?: ModerationLogUncheckedCreateNestedManyWithoutAdminInput
    moderationTargets?: ModerationLogUncheckedCreateNestedManyWithoutTarget_userInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsResolved?: ReportUncheckedCreateNestedManyWithoutResolverInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    verifiedChallenges?: UserChallengeUncheckedCreateNestedManyWithoutVerified_byInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    createdSponsors?: SponsorUncheckedCreateNestedManyWithoutCreated_by_adminInput
  }

  export type UserCreateOrConnectWithoutRedemptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRedemptionsInput, UserUncheckedCreateWithoutRedemptionsInput>
  }

  export type SponsorRewardCreateWithoutClaimsInput = {
    title: string
    description?: string | null
    points_cost: number
    quantity?: number | null
    redeemed_count?: number
    is_active?: boolean
    display_on_leaderboard?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    expires_at?: Date | string | null
    deleted_at?: Date | string | null
    sponsor: SponsorCreateNestedOneWithoutRewardsInput
  }

  export type SponsorRewardUncheckedCreateWithoutClaimsInput = {
    reward_id?: number
    sponsor_id: number
    title: string
    description?: string | null
    points_cost: number
    quantity?: number | null
    redeemed_count?: number
    is_active?: boolean
    display_on_leaderboard?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    expires_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type SponsorRewardCreateOrConnectWithoutClaimsInput = {
    where: SponsorRewardWhereUniqueInput
    create: XOR<SponsorRewardCreateWithoutClaimsInput, SponsorRewardUncheckedCreateWithoutClaimsInput>
  }

  export type UserUpsertWithoutRedemptionsInput = {
    update: XOR<UserUpdateWithoutRedemptionsInput, UserUncheckedUpdateWithoutRedemptionsInput>
    create: XOR<UserCreateWithoutRedemptionsInput, UserUncheckedCreateWithoutRedemptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRedemptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRedemptionsInput, UserUncheckedUpdateWithoutRedemptionsInput>
  }

  export type UserUpdateWithoutRedemptionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUpdateManyWithoutTarget_userNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUpdateManyWithoutCreated_by_adminNestedInput
  }

  export type UserUncheckedUpdateWithoutRedemptionsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    announcements?: AnnouncementUncheckedUpdateManyWithoutAdminNestedInput
    chatbotConversations?: ChatbotConversationUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    craftIdeas?: CraftIdeaUncheckedUpdateManyWithoutGenerated_by_userNestedInput
    createdChallenges?: EcoChallengeUncheckedUpdateManyWithoutCreated_by_adminNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    moderationLogs?: ModerationLogUncheckedUpdateManyWithoutAdminNestedInput
    moderationTargets?: ModerationLogUncheckedUpdateManyWithoutTarget_userNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsResolved?: ReportUncheckedUpdateManyWithoutResolverNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    verifiedChallenges?: UserChallengeUncheckedUpdateManyWithoutVerified_byNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    createdSponsors?: SponsorUncheckedUpdateManyWithoutCreated_by_adminNestedInput
  }

  export type SponsorRewardUpsertWithoutClaimsInput = {
    update: XOR<SponsorRewardUpdateWithoutClaimsInput, SponsorRewardUncheckedUpdateWithoutClaimsInput>
    create: XOR<SponsorRewardCreateWithoutClaimsInput, SponsorRewardUncheckedCreateWithoutClaimsInput>
    where?: SponsorRewardWhereInput
  }

  export type SponsorRewardUpdateToOneWithWhereWithoutClaimsInput = {
    where?: SponsorRewardWhereInput
    data: XOR<SponsorRewardUpdateWithoutClaimsInput, SponsorRewardUncheckedUpdateWithoutClaimsInput>
  }

  export type SponsorRewardUpdateWithoutClaimsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points_cost?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    redeemed_count?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    display_on_leaderboard?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sponsor?: SponsorUpdateOneRequiredWithoutRewardsNestedInput
  }

  export type SponsorRewardUncheckedUpdateWithoutClaimsInput = {
    reward_id?: IntFieldUpdateOperationsInput | number
    sponsor_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points_cost?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    redeemed_count?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    display_on_leaderboard?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnnouncementCreateManyAdminInput = {
    announcement_id?: number
    title: string
    content: string
    is_active?: boolean
    created_at?: Date | string
    expires_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type CommentCreateManyUserInput = {
    comment_id?: number
    post_id: number
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type CraftIdeaCreateManyGenerated_by_userInput = {
    idea_id?: number
    idea_json: JsonNullValueInput | InputJsonValue
    recycled_materials?: NullableJsonNullValueInput | InputJsonValue
    generated_image_url?: string | null
    is_saved?: boolean
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type EcoChallengeCreateManyCreated_by_adminInput = {
    challenge_id?: number
    title: string
    description: string
    points_reward: number
    waste_kg?: number
    is_active?: boolean
    source?: $Enums.ChallengeSource
    material_type: $Enums.MaterialType
    category: $Enums.ChallengeCategory
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    start_at?: Date | string
    expires_at?: Date | string | null
  }

  export type LikeCreateManyUserInput = {
    like_id?: number
    post_id: number
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ModerationLogCreateManyAdminInput = {
    log_id?: number
    action: $Enums.ModerationAction
    target_id: string
    target_user_id?: number | null
    reason?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ModerationLogCreateManyTarget_userInput = {
    log_id?: number
    admin_id?: number | null
    action: $Enums.ModerationAction
    target_id: string
    reason?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type PostCreateManyUserInput = {
    post_id?: number
    title: string
    content: string
    image_url?: string | null
    tags?: PostCreatetagsInput | string[]
    category: $Enums.Category
    featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ReportCreateManyReporterInput = {
    report_id?: number
    reported_post_id?: number | null
    reported_comment_id?: number | null
    reason: string
    status?: $Enums.ReportStatus
    moderator_notes?: string | null
    resolved_by_admin_id?: number | null
    created_at?: Date | string
    resolved_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type ReportCreateManyResolverInput = {
    report_id?: number
    reporter_id: number
    reported_post_id?: number | null
    reported_comment_id?: number | null
    reason: string
    status?: $Enums.ReportStatus
    moderator_notes?: string | null
    created_at?: Date | string
    resolved_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type UserChallengeCreateManyUserInput = {
    user_challenge_id?: number
    challenge_id: number
    status?: $Enums.ChallengeStatus
    proof_url?: string | null
    completed_at?: Date | string | null
    verified_at?: Date | string | null
    verified_by_admin_id?: number | null
    verification_type?: $Enums.VerificationType | null
    ai_confidence_score?: number | null
    points_awarded?: number
    waste_kg_saved?: number
    admin_notes?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    skipped_at?: Date | string | null
  }

  export type UserChallengeCreateManyVerified_byInput = {
    user_challenge_id?: number
    user_id: number
    challenge_id: number
    status?: $Enums.ChallengeStatus
    proof_url?: string | null
    completed_at?: Date | string | null
    verified_at?: Date | string | null
    verification_type?: $Enums.VerificationType | null
    ai_confidence_score?: number | null
    points_awarded?: number
    waste_kg_saved?: number
    admin_notes?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    skipped_at?: Date | string | null
  }

  export type RefreshTokenCreateManyUserInput = {
    token_id?: number
    token_hash: string
    expires_at: Date | string
    created_at?: Date | string
    last_used?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type SponsorCreateManyCreated_by_adminInput = {
    sponsor_id?: number
    name: string
    logo_url?: string | null
    description?: string | null
    contact_email?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type UserRedemptionCreateManyUserInput = {
    redemption_id?: number
    reward_id: number
    status?: $Enums.RedemptionStatus
    claimed_at?: Date | string
    fulfilled_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type AnnouncementUpdateWithoutAdminInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnnouncementUncheckedUpdateWithoutAdminInput = {
    announcement_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnnouncementUncheckedUpdateManyWithoutAdminInput = {
    announcement_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    reports?: ReportUpdateManyWithoutReported_commentNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reports?: ReportUncheckedUpdateManyWithoutReported_commentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CraftIdeaUpdateWithoutGenerated_by_userInput = {
    idea_json?: JsonNullValueInput | InputJsonValue
    recycled_materials?: NullableJsonNullValueInput | InputJsonValue
    generated_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CraftIdeaUncheckedUpdateWithoutGenerated_by_userInput = {
    idea_id?: IntFieldUpdateOperationsInput | number
    idea_json?: JsonNullValueInput | InputJsonValue
    recycled_materials?: NullableJsonNullValueInput | InputJsonValue
    generated_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CraftIdeaUncheckedUpdateManyWithoutGenerated_by_userInput = {
    idea_id?: IntFieldUpdateOperationsInput | number
    idea_json?: JsonNullValueInput | InputJsonValue
    recycled_materials?: NullableJsonNullValueInput | InputJsonValue
    generated_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EcoChallengeUpdateWithoutCreated_by_adminInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points_reward?: IntFieldUpdateOperationsInput | number
    waste_kg?: FloatFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    source?: EnumChallengeSourceFieldUpdateOperationsInput | $Enums.ChallengeSource
    material_type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    category?: EnumChallengeCategoryFieldUpdateOperationsInput | $Enums.ChallengeCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participants?: UserChallengeUpdateManyWithoutChallengeNestedInput
  }

  export type EcoChallengeUncheckedUpdateWithoutCreated_by_adminInput = {
    challenge_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points_reward?: IntFieldUpdateOperationsInput | number
    waste_kg?: FloatFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    source?: EnumChallengeSourceFieldUpdateOperationsInput | $Enums.ChallengeSource
    material_type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    category?: EnumChallengeCategoryFieldUpdateOperationsInput | $Enums.ChallengeCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participants?: UserChallengeUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type EcoChallengeUncheckedUpdateManyWithoutCreated_by_adminInput = {
    challenge_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points_reward?: IntFieldUpdateOperationsInput | number
    waste_kg?: FloatFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    source?: EnumChallengeSourceFieldUpdateOperationsInput | $Enums.ChallengeSource
    material_type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    category?: EnumChallengeCategoryFieldUpdateOperationsInput | $Enums.ChallengeCategory
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LikeUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post?: PostUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutUserInput = {
    like_id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LikeUncheckedUpdateManyWithoutUserInput = {
    like_id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModerationLogUpdateWithoutAdminInput = {
    action?: EnumModerationActionFieldUpdateOperationsInput | $Enums.ModerationAction
    target_id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    target_user?: UserUpdateOneWithoutModerationTargetsNestedInput
  }

  export type ModerationLogUncheckedUpdateWithoutAdminInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    action?: EnumModerationActionFieldUpdateOperationsInput | $Enums.ModerationAction
    target_id?: StringFieldUpdateOperationsInput | string
    target_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModerationLogUncheckedUpdateManyWithoutAdminInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    action?: EnumModerationActionFieldUpdateOperationsInput | $Enums.ModerationAction
    target_id?: StringFieldUpdateOperationsInput | string
    target_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModerationLogUpdateWithoutTarget_userInput = {
    action?: EnumModerationActionFieldUpdateOperationsInput | $Enums.ModerationAction
    target_id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: UserUpdateOneWithoutModerationLogsNestedInput
  }

  export type ModerationLogUncheckedUpdateWithoutTarget_userInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    action?: EnumModerationActionFieldUpdateOperationsInput | $Enums.ModerationAction
    target_id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModerationLogUncheckedUpdateManyWithoutTarget_userInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    action?: EnumModerationActionFieldUpdateOperationsInput | $Enums.ModerationAction
    target_id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostUpdatetagsInput | string[]
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUpdateManyWithoutPostNestedInput
    likes?: LikeUpdateManyWithoutPostNestedInput
    reports?: ReportUpdateManyWithoutReported_postNestedInput
  }

  export type PostUncheckedUpdateWithoutUserInput = {
    post_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostUpdatetagsInput | string[]
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReported_postNestedInput
  }

  export type PostUncheckedUpdateManyWithoutUserInput = {
    post_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostUpdatetagsInput | string[]
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUpdateWithoutReporterInput = {
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    moderator_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reported_comment?: CommentUpdateOneWithoutReportsNestedInput
    reported_post?: PostUpdateOneWithoutReportsNestedInput
    resolver?: UserUpdateOneWithoutReportsResolvedNestedInput
  }

  export type ReportUncheckedUpdateWithoutReporterInput = {
    report_id?: IntFieldUpdateOperationsInput | number
    reported_post_id?: NullableIntFieldUpdateOperationsInput | number | null
    reported_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    moderator_notes?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_by_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUncheckedUpdateManyWithoutReporterInput = {
    report_id?: IntFieldUpdateOperationsInput | number
    reported_post_id?: NullableIntFieldUpdateOperationsInput | number | null
    reported_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    moderator_notes?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_by_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUpdateWithoutResolverInput = {
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    moderator_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reported_comment?: CommentUpdateOneWithoutReportsNestedInput
    reported_post?: PostUpdateOneWithoutReportsNestedInput
    reporter?: UserUpdateOneRequiredWithoutReportsFiledNestedInput
  }

  export type ReportUncheckedUpdateWithoutResolverInput = {
    report_id?: IntFieldUpdateOperationsInput | number
    reporter_id?: IntFieldUpdateOperationsInput | number
    reported_post_id?: NullableIntFieldUpdateOperationsInput | number | null
    reported_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    moderator_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUncheckedUpdateManyWithoutResolverInput = {
    report_id?: IntFieldUpdateOperationsInput | number
    reporter_id?: IntFieldUpdateOperationsInput | number
    reported_post_id?: NullableIntFieldUpdateOperationsInput | number | null
    reported_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    moderator_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserChallengeUpdateWithoutUserInput = {
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    proof_url?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_type?: NullableEnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType | null
    ai_confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    points_awarded?: IntFieldUpdateOperationsInput | number
    waste_kg_saved?: FloatFieldUpdateOperationsInput | number
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    challenge?: EcoChallengeUpdateOneRequiredWithoutParticipantsNestedInput
    verified_by?: UserUpdateOneWithoutVerifiedChallengesNestedInput
  }

  export type UserChallengeUncheckedUpdateWithoutUserInput = {
    user_challenge_id?: IntFieldUpdateOperationsInput | number
    challenge_id?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    proof_url?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_by_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    verification_type?: NullableEnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType | null
    ai_confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    points_awarded?: IntFieldUpdateOperationsInput | number
    waste_kg_saved?: FloatFieldUpdateOperationsInput | number
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserChallengeUncheckedUpdateManyWithoutUserInput = {
    user_challenge_id?: IntFieldUpdateOperationsInput | number
    challenge_id?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    proof_url?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_by_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    verification_type?: NullableEnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType | null
    ai_confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    points_awarded?: IntFieldUpdateOperationsInput | number
    waste_kg_saved?: FloatFieldUpdateOperationsInput | number
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserChallengeUpdateWithoutVerified_byInput = {
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    proof_url?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_type?: NullableEnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType | null
    ai_confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    points_awarded?: IntFieldUpdateOperationsInput | number
    waste_kg_saved?: FloatFieldUpdateOperationsInput | number
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    challenge?: EcoChallengeUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutUserChallengesNestedInput
  }

  export type UserChallengeUncheckedUpdateWithoutVerified_byInput = {
    user_challenge_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    challenge_id?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    proof_url?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_type?: NullableEnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType | null
    ai_confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    points_awarded?: IntFieldUpdateOperationsInput | number
    waste_kg_saved?: FloatFieldUpdateOperationsInput | number
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserChallengeUncheckedUpdateManyWithoutVerified_byInput = {
    user_challenge_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    challenge_id?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    proof_url?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_type?: NullableEnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType | null
    ai_confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    points_awarded?: IntFieldUpdateOperationsInput | number
    waste_kg_saved?: FloatFieldUpdateOperationsInput | number
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    token_hash?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    token_id?: IntFieldUpdateOperationsInput | number
    token_hash?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    token_id?: IntFieldUpdateOperationsInput | number
    token_hash?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SponsorUpdateWithoutCreated_by_adminInput = {
    name?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rewards?: SponsorRewardUpdateManyWithoutSponsorNestedInput
  }

  export type SponsorUncheckedUpdateWithoutCreated_by_adminInput = {
    sponsor_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rewards?: SponsorRewardUncheckedUpdateManyWithoutSponsorNestedInput
  }

  export type SponsorUncheckedUpdateManyWithoutCreated_by_adminInput = {
    sponsor_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserRedemptionUpdateWithoutUserInput = {
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    claimed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfilled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reward?: SponsorRewardUpdateOneRequiredWithoutClaimsNestedInput
  }

  export type UserRedemptionUncheckedUpdateWithoutUserInput = {
    redemption_id?: IntFieldUpdateOperationsInput | number
    reward_id?: IntFieldUpdateOperationsInput | number
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    claimed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfilled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserRedemptionUncheckedUpdateManyWithoutUserInput = {
    redemption_id?: IntFieldUpdateOperationsInput | number
    reward_id?: IntFieldUpdateOperationsInput | number
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    claimed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfilled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatbotMessageCreateManyConversationInput = {
    message_id?: number
    sender: $Enums.MessageSender
    content: string
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ChatbotMessageUpdateWithoutConversationInput = {
    sender?: EnumMessageSenderFieldUpdateOperationsInput | $Enums.MessageSender
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatbotMessageUncheckedUpdateWithoutConversationInput = {
    message_id?: IntFieldUpdateOperationsInput | number
    sender?: EnumMessageSenderFieldUpdateOperationsInput | $Enums.MessageSender
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatbotMessageUncheckedUpdateManyWithoutConversationInput = {
    message_id?: IntFieldUpdateOperationsInput | number
    sender?: EnumMessageSenderFieldUpdateOperationsInput | $Enums.MessageSender
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentCreateManyPostInput = {
    comment_id?: number
    user_id: number
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type LikeCreateManyPostInput = {
    like_id?: number
    user_id: number
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ReportCreateManyReported_postInput = {
    report_id?: number
    reporter_id: number
    reported_comment_id?: number | null
    reason: string
    status?: $Enums.ReportStatus
    moderator_notes?: string | null
    resolved_by_admin_id?: number | null
    created_at?: Date | string
    resolved_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type CommentUpdateWithoutPostInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    reports?: ReportUpdateManyWithoutReported_commentNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reports?: ReportUncheckedUpdateManyWithoutReported_commentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LikeUpdateWithoutPostInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutPostInput = {
    like_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LikeUncheckedUpdateManyWithoutPostInput = {
    like_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUpdateWithoutReported_postInput = {
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    moderator_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reported_comment?: CommentUpdateOneWithoutReportsNestedInput
    reporter?: UserUpdateOneRequiredWithoutReportsFiledNestedInput
    resolver?: UserUpdateOneWithoutReportsResolvedNestedInput
  }

  export type ReportUncheckedUpdateWithoutReported_postInput = {
    report_id?: IntFieldUpdateOperationsInput | number
    reporter_id?: IntFieldUpdateOperationsInput | number
    reported_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    moderator_notes?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_by_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUncheckedUpdateManyWithoutReported_postInput = {
    report_id?: IntFieldUpdateOperationsInput | number
    reporter_id?: IntFieldUpdateOperationsInput | number
    reported_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    moderator_notes?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_by_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportCreateManyReported_commentInput = {
    report_id?: number
    reporter_id: number
    reported_post_id?: number | null
    reason: string
    status?: $Enums.ReportStatus
    moderator_notes?: string | null
    resolved_by_admin_id?: number | null
    created_at?: Date | string
    resolved_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type ReportUpdateWithoutReported_commentInput = {
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    moderator_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reported_post?: PostUpdateOneWithoutReportsNestedInput
    reporter?: UserUpdateOneRequiredWithoutReportsFiledNestedInput
    resolver?: UserUpdateOneWithoutReportsResolvedNestedInput
  }

  export type ReportUncheckedUpdateWithoutReported_commentInput = {
    report_id?: IntFieldUpdateOperationsInput | number
    reporter_id?: IntFieldUpdateOperationsInput | number
    reported_post_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    moderator_notes?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_by_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUncheckedUpdateManyWithoutReported_commentInput = {
    report_id?: IntFieldUpdateOperationsInput | number
    reporter_id?: IntFieldUpdateOperationsInput | number
    reported_post_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    moderator_notes?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_by_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserChallengeCreateManyChallengeInput = {
    user_challenge_id?: number
    user_id: number
    status?: $Enums.ChallengeStatus
    proof_url?: string | null
    completed_at?: Date | string | null
    verified_at?: Date | string | null
    verified_by_admin_id?: number | null
    verification_type?: $Enums.VerificationType | null
    ai_confidence_score?: number | null
    points_awarded?: number
    waste_kg_saved?: number
    admin_notes?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    skipped_at?: Date | string | null
  }

  export type UserChallengeUpdateWithoutChallengeInput = {
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    proof_url?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification_type?: NullableEnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType | null
    ai_confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    points_awarded?: IntFieldUpdateOperationsInput | number
    waste_kg_saved?: FloatFieldUpdateOperationsInput | number
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserChallengesNestedInput
    verified_by?: UserUpdateOneWithoutVerifiedChallengesNestedInput
  }

  export type UserChallengeUncheckedUpdateWithoutChallengeInput = {
    user_challenge_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    proof_url?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_by_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    verification_type?: NullableEnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType | null
    ai_confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    points_awarded?: IntFieldUpdateOperationsInput | number
    waste_kg_saved?: FloatFieldUpdateOperationsInput | number
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserChallengeUncheckedUpdateManyWithoutChallengeInput = {
    user_challenge_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    proof_url?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verified_by_admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    verification_type?: NullableEnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType | null
    ai_confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    points_awarded?: IntFieldUpdateOperationsInput | number
    waste_kg_saved?: FloatFieldUpdateOperationsInput | number
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SponsorRewardCreateManySponsorInput = {
    reward_id?: number
    title: string
    description?: string | null
    points_cost: number
    quantity?: number | null
    redeemed_count?: number
    is_active?: boolean
    display_on_leaderboard?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    expires_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type SponsorRewardUpdateWithoutSponsorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points_cost?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    redeemed_count?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    display_on_leaderboard?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claims?: UserRedemptionUpdateManyWithoutRewardNestedInput
  }

  export type SponsorRewardUncheckedUpdateWithoutSponsorInput = {
    reward_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points_cost?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    redeemed_count?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    display_on_leaderboard?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claims?: UserRedemptionUncheckedUpdateManyWithoutRewardNestedInput
  }

  export type SponsorRewardUncheckedUpdateManyWithoutSponsorInput = {
    reward_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points_cost?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    redeemed_count?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    display_on_leaderboard?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserRedemptionCreateManyRewardInput = {
    redemption_id?: number
    user_id: number
    status?: $Enums.RedemptionStatus
    claimed_at?: Date | string
    fulfilled_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type UserRedemptionUpdateWithoutRewardInput = {
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    claimed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfilled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutRedemptionsNestedInput
  }

  export type UserRedemptionUncheckedUpdateWithoutRewardInput = {
    redemption_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    claimed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfilled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserRedemptionUncheckedUpdateManyWithoutRewardInput = {
    redemption_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    status?: EnumRedemptionStatusFieldUpdateOperationsInput | $Enums.RedemptionStatus
    claimed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfilled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}
import { AppError } from "../../utils/error";
import { aiImage } from "../gemini/client";
import { config } from "../../config";

export const generateCraftImage = async (
  craftTitle: string,
  craftDescription: string,
  materials: string,
  referenceImageBase64?: string
) => {
  try {
    const prompt = `
Create a high-quality craft image.

Craft Title: ${craftTitle}
Craft Description: ${craftDescription}
Materials: ${materials}

If a reference image is provided, use it as style/shape inspiration.
`.trim();

    const payload: any = {
      model: config.ai.imageModel,
      prompt,
      config: {
        numberOfImages: 1,
      },
    };

    // ‚úÖ FIX: Properly handle the reference image
    if (referenceImageBase64) {
      console.log('üñºÔ∏è  Adding reference image to Imagen payload');
      
      // Remove data URI prefix if present (data:image/jpeg;base64,)
      let cleanBase64 = referenceImageBase64;
      let mimeType = "image/jpeg";
      
      if (referenceImageBase64.includes(',')) {
        const parts = referenceImageBase64.split(',');
        cleanBase64 = parts[1];
        
        // Extract mime type from data URI
        const dataUriPrefix = parts[0];
        if (dataUriPrefix.includes('image/png')) {
          mimeType = "image/png";
        } else if (dataUriPrefix.includes('image/webp')) {
          mimeType = "image/webp";
        } else if (dataUriPrefix.includes('image/jpeg') || dataUriPrefix.includes('image/jpg')) {
          mimeType = "image/jpeg";
        }
      }
      
      console.log('üñºÔ∏è  Reference Image MIME Type:', mimeType);
      console.log('üñºÔ∏è  Reference Image Base64 length:', cleanBase64.length);
      console.log('üñºÔ∏è  Reference Image Base64 preview:', cleanBase64.substring(0, 50));
      
      payload.referenceImages = [
        {
          mimeType: mimeType,
          image: {
            imageBytes: cleanBase64  // ‚úÖ Use cleaned base64 without data URI prefix
          }
        }
      ];
    } else {
      console.log('‚ÑπÔ∏è  No reference image provided');
    }

    console.log('üé® Calling Imagen API with payload:', {
      model: payload.model,
      hasReferenceImage: !!payload.referenceImages,
      promptLength: payload.prompt.length
    });

    // Call Imagen
    const response = await aiImage.models.generateImages(payload);

    const images = response.generatedImages ?? [];
    if (images.length === 0) {
      throw new AppError("No images generated by Imagen", 500);
    }

    const imgBytes = images[0].image?.imageBytes;
    if (!imgBytes) {
      throw new AppError("Image generation failed - no image data returned", 500);
    }

    console.log('‚úÖ Image generated successfully by Imagen');
    console.log('‚úÖ Generated image size:', imgBytes.length, 'bytes');

    // Return the Base64 string with data URI prefix for display
    return `data:image/png;base64,${imgBytes}`;

  } catch (err: any) {
    console.error("‚ùå Craft Image Generation Error:", err);
    console.error("‚ùå Error details:", {
      message: err.message,
      stack: err.stack,
      name: err.name
    });
    throw new AppError(err.message || "Image generation failed", 500);
  }
};